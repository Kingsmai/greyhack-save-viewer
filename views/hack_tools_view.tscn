[gd_scene format=3 uid="uid://nat0nt4123d4"]

[node name="HackTools" type="MarginContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
metadata/_tab_index = 9

[node name="TabContainer" type="TabContainer" parent="."]
layout_mode = 2
current_tab = 0

[node name="viper" type="MarginContainer" parent="TabContainer"]
layout_mode = 2
metadata/_tab_index = 0

[node name="ScrollContainer" type="ScrollContainer" parent="TabContainer/viper"]
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="TabContainer/viper/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Disclaimer" type="RichTextLabel" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "[color=yellow]Disclaimer:[/color] Viper Source code can be found at [url]https://github.com/EntitySeaker/viper-git[/url]"
fit_content = true

[node name="Instruction" type="RichTextLabel" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Get [color=red]root[/color] privileges in your terminal"
fit_content = true

[node name="LineEdit" type="LineEdit" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
text = "sudo -s"
editable = false

[node name="Instruction2" type="RichTextLabel" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Create a directory called [color=cyan][code]volk[/code][/color] in the /home directory"
fit_content = true

[node name="LineEdit2" type="LineEdit" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
text = "mkdir /home/volks"
editable = false

[node name="Instruction3" type="RichTextLabel" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]viper.img.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/home/volk/viper.img[/color]. Make sure to keep 'Allow import' checked."
fit_content = true

[node name="ViperImgCodeEdit" type="CodeEdit" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 500)
layout_mode = 2
text = "ascii_print = function()
    out = \"\"
    out = out+\"<size=15><color=#404040>\"+\"#\"*67+\"\\n\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-4px>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#6b6b6b>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#c7c7c7>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#dfdfdf>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#e4e4e4>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#f1f1f1>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#c4c4c4>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#686868>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-8px>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#919191>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#e9e9e9>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#f5f5f5>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#f2f2f2>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#6e6e6e>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#7a7a7a>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#f2f2f2>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#9a9a9a>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-12px>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#959595>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#e3e3e3>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#8a8a8a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#333333>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#444444>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#838383>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#e6e6e6>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#929292>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-16px>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#7c7c7c>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#b5b5b5>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#848484>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#797979>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#6e6e6e>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#7e7e7e>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#b3b3b3>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#6d6d6d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=312>\"+\"@@@@@@\"+\"<pos=422>\"+\"@@@@@@\"
    out = out+\"<voffset=-20px>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-24px>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#5d5d5d>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#b8b8b8>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#9e9e9e>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#696969>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-28px>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#676767>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#b7b7b7>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#313131>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ebebeb>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#3b3b3b>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#b9b9b9>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#676767>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-32px>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#979797>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#acacac>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#9c9c9c>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#929292>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#b9b9b9>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#909090>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-36px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#aaaaaa>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#4e4e4e>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#b8b8b8>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#c1c1c1>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#bfbfbf>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#969696>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#c2c2c2>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#adadad>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#555555>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#969696>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=304>\"+\"@@\"+\"<pos=349>\"+\"@@@\"+\"<pos=413>\"+\"@@!\"+\"<pos=461>\"+\"@@@\"
    out = out+\"<voffset=-40px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#eaeaea>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#f3f3f3>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#b0b0b0>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#9e9e9e>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#101010>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#e0e0e0>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-44px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#5f5f5f>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#c5c5c5>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#b8b8b8>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#6a6a6a>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-48px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#999999>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#676767>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#5d5d5d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#606060>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#dfdfdf>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#f5f5f5>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#dadada>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#6f6f6f>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#616161>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#616161>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#ababab>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#f1f1f1>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-52px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#d2d2d2>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#c5c5c5>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-56px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#595959>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#5a5a5a>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=321>\"+\".!!\"+\"@!\"+\"<pos=412>\"+\"@!@\"+\"<pos=462>\"+\"!@!\"
    out = out+\"<voffset=-60px>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#c8c8c8>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#b9b9b9>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#0a0a0a>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-64px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#434343>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#f5f5f5>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#414141>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-68px>\"
    out = out+\"<pos=40px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#d3d3d3>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#1d1d1d>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ababab>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#bebebe>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#969696>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#eeeeee>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#e1e1e1>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#989898>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#c7c7c7>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#949494>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#2a2a2a>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#d8d8d8>\"
    out = out+\"<pos=212px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-72px>\"
    out = out+\"<pos=40px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#c4c4c4>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#9f9f9f>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#6a6a6a>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#bababa>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#c8c8c8>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#a5a5a5>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#969696>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#dedede>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#f3f3f3>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#c1c1c1>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#6c6c6c>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#a5a5a5>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#aaaaaa>\"
    out = out+\"<pos=212px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-76px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#292929>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#5e5e5e>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#9b9b9b>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#5b5b5b>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#606060>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#f2f2f2>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#575757>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#747474>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#ebebeb>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#9a9a9a>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#5c5c5c>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#404040>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#ececec>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=313>\"+\"!!:\"+\"<pos=412>\"+\"!!:\"+\"<pos=462>\"+\"!!!\"
    out = out+\"<voffset=-80px>\"
    out = out+\"<pos=44px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#939393>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#dddddd>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#7f7f7f>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#4f4f4f>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#8b8b8b>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#e0e0e0>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#f5f5f5>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#eaeaea>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#c4c4c4>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#323232>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#454545>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#cccccc>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#f3f3f3>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#d3d3d3>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#9d9d9d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#393939>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#323232>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#767676>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#d3d3d3>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#919191>\"
    out = out+\"<pos=208px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-84px>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#f7f7f7>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#9e9e9e>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#464646>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#7c7c7c>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#cacaca>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#9f9f9f>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#a5a5a5>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#f2f2f2>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#c8c8c8>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#787878>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#343434>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#a4a4a4>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#f1f1f1>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-88px>\"
    out = out+\"<pos=48px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#979797>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#cecece>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#8d8d8d>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#3f3f3f>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#474747>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#8f8f8f>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#d6d6d6>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#e8e8e8>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#7e7e7e>\"
    out = out+\"<pos=204px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-92px>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#f0f0f0>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#6b6b6b>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#c8c8c8>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#c7c7c7>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#cbcbcb>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#fbfbfb>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#b3b3b3>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#7f7f7f>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#eeeeee>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-96px>\"
    out = out+\"<pos=52px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#868686>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#e8e8e8>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#686868>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#c8c8c8>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#cacaca>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#5b5b5b>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#dbdbdb>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#7d7d7d>\"
    out = out+\"<pos=200px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=304>\"+\":.::::::\"+\"<pos=383>\"+\"()\"+\"<pos=423>\"+\"::..::\"
    out = out+\"<voffset=-100px>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#ededed>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#fefefe>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#4e4e4e>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#111111>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#eaeaea>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#d2d2d2>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#d5d5d5>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#dadada>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#535353>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#e5e5e5>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-104px>\"
    out = out+\"<pos=56px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#737373>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#c1c1c1>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#717171>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#e0e0e0>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#e2e2e2>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#6f6f6f>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#bcbcbc>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#6b6b6b>\"
    out = out+\"<pos=196px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-108px>\"
    out = out+\"<pos=60px><size=7px><sprite=0 color=#151515>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#dbdbdb>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#0c0c0c>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#d9d9d9>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#f5f5f5>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#f9f9f9>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#cecece>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#d9d9d9>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-112px>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#707070>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#8d8d8d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#454545>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#525252>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#999999>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#6c6c6c>\"
    out = out+\"<pos=192px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-116px>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#dbdbdb>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#efefef>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#010101>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#b4b4b4>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#9e9e9e>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ebebeb>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#d1d1d1>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-120px>\"
    out = out+\"<pos=64px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#646464>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#6a6a6a>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=96px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=100px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=152px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=156px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#686868>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#616161>\"
    out = out+\"<pos=188px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-124px>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#d9d9d9>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#d3d3d3>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#cdcdcd>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#c8c8c8>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-128px>\"
    out = out+\"<pos=68px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#6b6b6b>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#fdfdfd>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#3c3c3c>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#474747>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#5f5f5f>\"
    out = out+\"<pos=184px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-132px>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#dadada>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#a7a7a7>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#adadad>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#c7c7c7>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-136px>\"
    out = out+\"<pos=72px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#626262>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#fafafa>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#f1f1f1>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#555555>\"
    out = out+\"<pos=180px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=238>\"+\"____<pos=301>____<pos=346>__\"
    out = out+\"<voffset=-140px>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#e3e3e3>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#7c7c7c>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#898989>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#c7c7c7>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-144px>\"
    out = out+\"<pos=76px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#5e5e5e>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#efefef>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#e2e2e2>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#484848>\"
    out = out+\"<pos=176px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-148px>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#e6e6e6>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#3c3c3c>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#474747>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#cecece>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-152px>\"
    out = out+\"<pos=80px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#646464>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#7d7d7d>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#757575>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#606060>\"
    out = out+\"<pos=172px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#e60000>\"+\"<pos=238>\"+\"\\<pos=274>\\<pos=292>/<pos=328>/|__|______<pos=463>____<pos=508>_______\"
    out = out+\"<voffset=-156px>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#7c7c7c>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#696969>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-160px>\"
    out = out+\"<pos=84px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#404040>\"
    out = out+\"<pos=92px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=160px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#414141>\"
    out = out+\"<pos=168px><size=7px><sprite=0 color=#0d0d0d>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-164px>\"
    out = out+\"<pos=88px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<pos=164px><size=7px><sprite=0 color=#0d0d0d>\"
    out = out+\"<voffset=-168px>\"
    out = out+\"<voffset=-172px>\"
    out = out+\"<voffset=-176px>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#0a0a0a>\"+\"<size=15><color=#e60000>\"+\"<pos=247>\"+\"\\<pos=283>Y<pos=319>/<pos=337>|<pos=364>|\\____<pos=427>\\<pos=445>_/<pos=472>__<pos=500>\\\\_<pos=544>__<pos=571>\\\"
    out = out+\"<voffset=-180px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#2f2f2f>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#2f2f2f>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-184px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#7b7b7b>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#1a1a1a>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#7b7b7b>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-188px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#6b6b6b>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#6b6b6b>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-192px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#e4e4e4>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#e4e4e4>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-196px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#4d4d4d>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#4d4d4d>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"+\"<size=15><color=#e60000>\"+\"<pos=256>\"+\"\\     /  |  ||  |_> >\\  ___/ |  | \\/\"
    out = out+\"<voffset=-200px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#d8d8d8>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#d8d8d8>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-204px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#727272>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#727272>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-208px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#919191>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#919191>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#f6f6f6>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-212px>\"
    out = out+\"<pos=104px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#3d3d3d>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#ffffff>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#3d3d3d>\"
    out = out+\"<pos=148px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-216px>\"
    out = out+\"<pos=108px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#5f5f5f>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#efefef>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#fcfcfc>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#f8f8f8>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#efefef>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#5f5f5f>\"
    out = out+\"<pos=144px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-218px>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-220px>\"
    out = out+\"<pos=112px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=116px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#787878>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#dcdcdc>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#dcdcdc>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#787878>\"
    out = out+\"<pos=136px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=140px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-224px>\"
    out = out+\"<pos=120px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=124px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=128px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<pos=132px><size=7px><sprite=0 color=#0a0a0a>\"
    out = out+\"<voffset=-228px>\"

    out = out+\"<voffset=-216px>\"
    out = out+\"<size=15><color=#e60000>\"+\"<pos=265>\"+\"\\___/   |__||   __/  \\___  >|__|\"
    out = out+\"<voffset=-237px>\"+\"<pos=373px>\"+\"<color=#e60000>|__|<pos=489>\\/\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<voffset=-257px>\"+\"<size=15><color=#404040><pos=0px>\"+\"#\"+\"<pos=594px>\"+\"#\"
    out = out+\"<size=17><color=white>\"+\"<pos=20><b>Created by: Volk</b>\\n\"
    out = out+\"<size=15><color=#404040>\"+\"#\"*67

    info = do_style(\"LIBRARY \", \"title\")+do_style(\"PUBLICIP \", \"title\")+do_style(\"LOCALIP \", \"title\")+do_style(\"VERSION\", \"title\")
    info = info+char(10)+do_style(\"------- \", \"outline\")+do_style(\"-------- \", \"outline\")+do_style(\"------- \", \"outline\")+do_style(\"-------\", \"outline\")
    info = info+char(10)+do_style(typeof(main_session.MetaxploitLib).lower.replace(\"lib\",\"\")+\" \", \"outline\")+do_style(main_session.MetaxploitLibPublicIP+\" \", \"outline\")+do_style(main_session.MetaxploitLibLocalIP+\" \", \"outline\")+do_style(main_session.MetaxploitLibVersion, \"outline\")
    info = info+char(10)+do_style(typeof(main_session.cryptoLib).lower.replace(\"lib\",\"\")+\" \", \"outline\")+do_style(main_session.cryptoLibPublicIP+\" \", \"outline\")+do_style(main_session.cryptoLibLocalIP+\" \", \"outline\")+do_style(main_session.cryptoLibVersion, \"outline\")
    
    print(out+ char(10) + char(10) + do_style(\"Version\", \"red\", \"static\")+do_style(\": \", \"dark_grey\", \"static\")+do_style(main_session.version, \"dark_grey\", \"static\")+char(10)+char(10)+format_columns(info)+char(10)+char(10), true)
end function"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction4" type="RichTextLabel" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]viper.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/wherever/you/want/viper[/color] or [color=cyan]/bin/[/color]."
fit_content = true

[node name="ViperCodeEdit" type="CodeEdit" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 500)
layout_mode = 2
text = "//AES128
AES128 = function(choice, key, text) // Returns null if any error (could mean undecryptable ciphertext)

	if typeof(key) != \"string\" then return null
	if key.len != 16 then return null
	if typeof(text) != \"string\" then return null
	if typeof(choice) != \"string\" then return null

	byte_key = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	for i in key.indexes
		byte_key[i] = key[i].code
	end for
	key = byte_key[0:]

	// Define lookup tables
	Sbox = []
	Sbox=Sbox+[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38]
	Sbox=Sbox+[54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179]
	Sbox=Sbox+[41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64]
	Sbox=Sbox+[143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70]
	Sbox=Sbox+[238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174]
	Sbox=Sbox+[8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105]
	Sbox=Sbox+[217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22]

	Rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54]

	Mult2 = []
	Mult2=Mult2+[0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90]
	Mult2=Mult2+[92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158]
	Mult2=Mult2+[160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224]
	Mult2=Mult2+[226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,27,25,31,29,19,17,23,21,11,9,15,13,3,1,7,5,59,57,63,61,51,49,55,53,43,41]
	Mult2=Mult2+[47,45,35,33,39,37,91,89,95,93,83,81,87,85,75,73,79,77,67,65,71,69,123,121,127,125,115,113,119,117,107,105,111,109,99,97,103,101,155]
	Mult2=Mult2+[153,159,157,147,145,151,149,139,137,143,141,131,129,135,133,187,185,191,189,179,177,183,181,171,169,175,173,163,161,167,165,219,217]
	Mult2=Mult2+[223,221,211,209,215,213,203,201,207,205,195,193,199,197,251,249,255,253,243,241,247,245,235,233,239,237,227,225,231,229]


	SubBytes = function(column)
		column = column[0:]
		for i in column.indexes
			column[i] = Sbox[column[i]]
		end for
		return column
	end function

	WordXor = function(word1, word2)
		result = [0, 0, 0, 0]
		for i in result.indexes
			result[i] = bitwise(\"^\", word1[i], word2[i])
		end for
		return result
	end function

	AddRoundKey = function(state, key, roundNum)
		roundKey = key[roundNum*4:roundNum*4+4]
		return [WordXor(state[0], roundKey[0]), WordXor(state[1], roundKey[1]), WordXor(state[2], roundKey[2]), WordXor(state[3], roundKey[3])]
	end function

	ExpandKey = function(key)
		W = [key[0:4], key[4:8], key[8:12], key[12:16]]
		
		for i in range(4, 40, 4)
			W = W + [[], [], [], []]
			W[i] = W[i-1][1:] + [W[i-1][0]] // RotWord
			W[i] = SubBytes(W[i])
			W[i] = WordXor(W[i-4], W[i])
			W[i][0] = bitwise(\"^\", Rcon[i/4-1], W[i][0])
			for j in range(i+1, i+3)
				W[j] = WordXor(W[j-4], W[j-1])
			end for
		end for
		return W
	end function

	aesEncrypt = function(key, block) // Expects already formatted block
		Mult2 = @Mult2
		key = key[0:]
		State = block[0:]
		
		// Declaring functions
		ShiftRows = function(state)
			state = state[0:]
			tmp = state[0][1]
			state[0][1] = state[1][1]
			state[1][1] = state[2][1]
			state[2][1] = state[3][1]
			state[3][1] = tmp
			
			for i in range(1)
				tmp = state[0][2]
				state[0][2] = state[1][2]
				state[1][2] = state[2][2]
				state[2][2] = state[3][2]
				state[3][2] = tmp
			end for
			
			tmp = state[3][3]
			state[3][3] = state[2][3]
			state[2][3] = state[1][3]
			state[1][3] = state[0][3]
			state[0][3] = tmp
			return state
		end function
		
		matrix = [[2, 3, 1, 1], [1, 2, 3, 1], [1, 1, 2, 3], [3, 1, 1, 2]]
		
		MixColumns = function(state)
			state = state[0:]
			for column in state.indexes
				endcolumn = [0, 0, 0, 0]
				for i in matrix.indexes
					tmp = state[column][0:]
					for j in matrix[i].indexes
						if matrix[i][j] == 1 then continue
						tmp[j] = Mult2[state[column][j]]
						if matrix[i][j] != 3 then continue
						tmp[j] = bitwise(\"^\", tmp[j], state[column][j])
					end for
					endcolumn[i] = bitwise(\"^\", bitwise(\"^\", bitwise(\"^\", tmp[0], tmp[1]), tmp[2]), tmp[3])
				end for
				state[column] = endcolumn[0:]
			end for
			return state
		end function
		
		// The algorithm
		State = AddRoundKey(State, key, 0)
		
		for round in range(1, 9)
			State = [SubBytes(State[0]), SubBytes(State[1]), SubBytes(State[2]), SubBytes(State[3])]
			State = ShiftRows(State)
			State = MixColumns(State)
			State = AddRoundKey(State, key, round)
		end for
			
		State = [SubBytes(State[0]), SubBytes(State[1]), SubBytes(State[2]), SubBytes(State[3])]
		State = ShiftRows(State)
		State = AddRoundKey(State, key, 10)
		
		return State
	end function


	aesDecrypt = function(key, block) // Expects already formatted block
		Mult2 = @Mult2
		Sbox = @Sbox
		key = key[0:]
		State = block[0:]
		
		// Declare functions
		InvShiftRows = function(state)
			state = state[0:]
			tmp = state[3][1]
			state[3][1] = state[2][1]
			state[2][1] = state[1][1]
			state[1][1] = state[0][1]
			state[0][1] = tmp
			
			for i in range(1)
				tmp = state[3][2]
				state[3][2] = state[2][2]
				state[2][2] = state[1][2]
				state[1][2] = state[0][2]
				state[0][2] = tmp
			end for
			
			tmp = state[0][3]
			state[0][3] = state[1][3]
			state[1][3] = state[2][3]
			state[2][3] = state[3][3]
			state[3][3] = tmp
			return state
		end function
		
		InvSubBytes = function(column)
			column = column[0:]
			for i in column.indexes
				column[i] = Sbox.indexOf(column[i])
			end for
			return column
		end function
		
		matrix = [[14, 11, 13, 9], [9, 14, 11, 13], [13, 9, 14, 11], [11, 13, 9, 14]]
		
		InvMixColumns = function(state)
			state = state[0:]
			for column in state.indexes
				endcolumn = [0, 0, 0, 0]
				for i in matrix.indexes
					tmp = state[column][0:]
					for j in matrix[i].indexes
						if matrix[i][j] == 9 then
							tmp[j] = bitwise(\"^\", Mult2[Mult2[Mult2[state[column][j]]]], state[column][j])
						else if matrix[i][j] == 11 then
							tmp[j] = bitwise(\"^\", Mult2[bitwise(\"^\", Mult2[Mult2[state[column][j]]], state[column][j])], state[column][j])
						else if matrix[i][j] == 13 then
							tmp[j] = bitwise(\"^\", Mult2[Mult2[bitwise(\"^\", Mult2[state[column][j]], state[column][j])]], state[column][j])
						else
							tmp[j] = Mult2[bitwise(\"^\", Mult2[bitwise(\"^\", Mult2[state[column][j]], state[column][j])], state[column][j])]
						end if
					end for
					endcolumn[i] = bitwise(\"^\", bitwise(\"^\", bitwise(\"^\", tmp[0], tmp[1]), tmp[2]), tmp[3])
				end for
				state[column] = endcolumn[0:]
			end for
			return state
		end function
		
		// The actual algorithm
		State = AddRoundKey(State, key, 10)
		
		for round in range(9, 1)
			State = InvShiftRows(State)
			State = [InvSubBytes(State[0]), InvSubBytes(State[1]), InvSubBytes(State[2]), InvSubBytes(State[3])]
			State = AddRoundKey(State, key, round)
			State = InvMixColumns(State)
		end for
		
		State = InvShiftRows(State)
		State = [InvSubBytes(State[0]), InvSubBytes(State[1]), InvSubBytes(State[2]), InvSubBytes(State[3])]
		State = AddRoundKey(State, key, 0)
		
		return State
	end function


	// Generate IV
	IV = []
	for byte in key
		IV = IV + [floor(rnd(byte)*256)] // Warning: rnd is not cryptographically secure
	end for

	key = ExpandKey(key)

	b64Table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"

	if choice == \"encrypt\" then
		Blocks = [[]]
		b=0
		for char in text
			Blocks[b] = Blocks[b] + [code(char)]
			if Blocks[b].len == 16 then
				Blocks = Blocks + [[]]
				b=b+1
			end if
		end for
		
		// Pad with CMS (Crytographic Message Syntax)
		padNum = 16 - Blocks[-1].len
		for i in range(padNum-1)
			Blocks[-1] = Blocks[-1] + [padNum]
		end for
		
		// XOR first block with IV
		for i in IV.indexes
			Blocks[0][i] = bitwise(\"^\", Blocks[0][i], IV[i])
		end for
		
		// Format blocks
		for i in Blocks.indexes
			Blocks[i] = [Blocks[i][0:4], Blocks[i][4:8], Blocks[i][8:12], Blocks[i][12:16]]
		end for
		
		// Encode blocks
		Blocks[0] = aesEncrypt(key, Blocks[0])
		if Blocks.len > 1 then
			for i in range(1, Blocks.len-1)
				for column in Blocks[i].indexes
					for byte in Blocks[i][column].indexes
						Blocks[i][column][byte] = bitwise(\"^\", Blocks[i][column][byte], Blocks[i-1][column][byte])
					end for
				end for
				Blocks[i] = aesEncrypt(key, Blocks[i])
			end for
		end if
		
		// Convert blocks to array of bytes
		arr = []
		for Block in Blocks
			for column in Block
				for byte in column
					arr = arr + [byte]
				end for
			end for
		end for
		
		// Convert array into base 64
		output = \"\"
		for i in range(0, arr.len-1, 3)
			buffer = arr[i]*65536
			if arr.hasIndex(i+1) then
				buffer = buffer+arr[i+1]*256
				if arr.hasIndex(i+2) then buffer = buffer+arr[i+2]
			end if
			
			if arr.hasIndex(i+2) then
				for j in range(3)
					output = output + b64Table[floor(buffer/64^j)%64]
				end for
			else
				if arr.hasIndex(i+1) then
					for j in range(3,1)
						output = output + b64Table[floor(buffer/64^j)%64]
					end for
				else
					for j in range(3,2)
						output = output + b64Table[floor(buffer/64^j)%64]
					end for
				end if
			end if
		end for
		return output
	end if

	if choice == \"decrypt\" then
		if text.len % 4 == 1 then return null
		
		// Convert base 64 into sextet array
		s_arr = text.values
		for i in s_arr.indexes
			tmp = b64Table.indexOf(s_arr[i])
			if tmp == null then return null
			s_arr[i] = tmp
		end for
		
		// Convert sextets to bytes
		b_arr = []
		for i in range(0, s_arr.len-1, 4)
			buffer = s_arr[i]*262144
			if s_arr.hasIndex(i+1) then
				buffer = buffer+s_arr[i+1]*4096
				if s_arr.hasIndex(i+2) then
					buffer = buffer+s_arr[i+2]*64
					if s_arr.hasIndex(i+3) then buffer = buffer+s_arr[i+3]
				end if
			end if
			
			if s_arr.hasIndex(i+3) then
				for j in range(2)
					b_arr = b_arr + [floor(buffer/256^j)%256]
				end for
			else
				if s_arr.hasIndex(i+2) then
					for j in range(2,1)
						b_arr = b_arr + [floor(buffer/256^j)%256]
					end for
				else
					b_arr = b_arr + [floor(buffer/65526)%256]
				end if
			end if
		end for
		
		// Convert byte array to blocks
		Blocks = [[]]
		b=0
		while b_arr.len > 0
			if Blocks[b].len == 16 then
				Blocks = Blocks + [[]]
				b=b+1
			end if
			Blocks[b] = Blocks[b] + [b_arr.pull]
		end while
		if Blocks[-1].len != 16 then return null
		
		// Format blocks
		for i in Blocks.indexes
			Blocks[i] = [Blocks[i][0:4], Blocks[i][4:8], Blocks[i][8:12], Blocks[i][12:16]]
		end for
		
		// Decode blocks
		NewBlocks = Blocks[0:]
		for i in Blocks.indexes
			NewBlocks[i] = aesDecrypt(key, Blocks[i])
		end for
		
		// XOR blocks
		for column in Blocks[0].indexes
			for byte in Blocks[i][column].indexes
				NewBlocks[0][column][byte] = bitwise(\"^\", NewBlocks[0][column][byte], IV[column*4+byte])
			end for
		end for
		if Blocks.len > 1 then
			for i in range(1, Blocks.len-1)
				for column in Blocks[i].indexes
					for byte in Blocks[i][column].indexes
						NewBlocks[i][column][byte] = bitwise(\"^\", NewBlocks[i][column][byte], Blocks[i-1][column][byte])
					end for
				end for
			end for
		end if
		
		Blocks = NewBlocks[0:]
		
		// Convert blocks to array of bytes
		arr = []
		for Block in Blocks
			for column in Block
				for byte in column
					arr = arr + [byte]
				end for
			end for
		end for
		
		// Remove padding
		if arr[-1] > 16 or arr[-1] == 0 then return null
		for i in range(arr[-1]-1)
			arr.pop
		end for
		
		// Convert array to text
		output = \"\"
		for byte in arr
			output = output + char(byte)
		end for
		return output
	end if

	return null
end function
Escape = function(text)
    return text.replace(\"(?=\\\\|\\.|\\+|\\*|\\?|\\^|\\$|\\(|\\)|\\[|\\]|\\{|\\}|\\|)\",\"\\\")
end function
//json Parser
//parse(file.get_content) //will load a json text file into a map
//toJSON(map) //will convert the map to json string
Parser={\"hex_digit_map\":{},\"escape_to\":[\"\\\\\",\"\\\"\"\",\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\r\"],\"eol\":char(13),\"escape_from\":[\"\\\",\"\"\"\",char(8),char(9),char(10),char(12),char(13)],\"escape_indexes\":0,\"white_space\":\" \"+char(9)+char(10)+char(13),\"source\":\"\",\"source_len\":0,\"p\":0,\"classID\":\"ParserLib   1.0.0-rc.1\"}
Parser.hex_to_int=function(s)
	r=0
	for c in s
		r=r*16+self.hex_digit_map[c]
	end for
	return r
end function
Parser.escape=function(s)
	self.escape_indexes=self.escape_from.indexes
	for i in self.escape_indexes
		s=s.replace(Escape(self.escape_from[i]),self.escape_to[i])
	end for
	return s
end function
Parser.unescape=function(s)
	r=[]
	for i in range(0,15)
		if i<10 then
			self.hex_digit_map[str(i)]=i
		else
			self.hex_digit_map[char(55+i)]=i
			hex_digit_map[char(87+i)]=i
		end if
	end for
	i=0
	m=s.len
	while i<m
		d=1
		if s[i]==\"\\\" then
			d=2
			c=s[i+1]
			if c==\"b\" then
				r.push char(8)
				i=i+d
				continue
			end if
			if c==\"t\" then
				r.push char(9)
				i=i+d
				continue
			end if
			if c==\"n\" then
				r.push char(10)
				i=i+d
				continue
			end if
			if c==\"f\" then
				r.push char(12)
				i=i+d
				continue
			end if
			if c==\"r\" then
				r.push char(13)
				i=i+d
				continue
			end if
			if c==\"u\" then
				h=s[i+2:i+6]
				r.push char(self.hex_to_int(h))
				d=6
				i=i+d
				continue
			end if
			r.push c
		else
			r.push s[i]
		end if
		i=i+d
	end while
	return r.join(\"\")
end function
Parser.init=function(s)
	self.source=s
	self.source_len=s.len
end function
Parser.parse=function(s=null)
	if s!=null then self.init s
	self.p=0
	return self.parse_element
end function
Parser.skip_white_space=function
	while self.p<self.source_len
		c = self.source[self.p]
		if self.white_space.indexOf(c)==null then break
		self.p=self.p+1
	end while
end function
Parser.parse_element=function
	return self.parse_value
end function
Parser.parse_value=function
	self.skip_white_space
	if not self.source.hasIndex(self.p) then return 0
	c=self.source[self.p]
	if c==\"\"\"\" then return self.parse_string
	if \"0123456789-.\".indexOf(c)!=null then return self.parse_number
	if c==\"[\" then return self.parse_list
	if c==\"{\" then return self.parse_map
	if c==\"t\" and self.source[self.p:self.p+4]==\"true\" then
		self.p=self.p+4
		return 1
	end if
	if c==\"f\" and self.source[self.p:self.p+5]==\"false\" then
		self.p=self.p+5
		return 0
	end if
	if c==\"n\" and self.source[self.p:self.p+4]==\"null\" then
		self.p=self.p+4
		return null
	end if
end function
Parser.parse_list=function
	self.p=self.p+1
	self.skip_white_space
	r=[]
	while self.p<self.source_len
		c=self.source[self.p]
		if c==\"]\" then break
		r.push self.parse_element
		self.skip_white_space
		c=self.source[self.p]
		if c==\",\" then
			self.p=self.p+1
			self.skip_white_space
		end if
	end while
	self.p=self.p+1
	return r
end function
Parser.parse_map=function
	self.p=self.p+1
	self.skip_white_space
	r={}
	while self.p<self.source_len
		c=self.source[self.p]
		if c==\"}\" then break
		if c!=\"\"\"\" then
			Error.er(\"Object member key must be a string literal\"+Str.n+\"Error at position \"+self.p+\": \"+self.source[self.p-60:self.p+60],\"JSON\")
			return null
		end if
		k=self.parse_string
		self.skip_white_space
		if self.source[self.p]!=\":\" then
			Error.er(\"Colon expected\"+Str.n+\"Error at position \"+self.p+\": \"+self.source[self.p-60:self.p+60])
			return null
		end if
		self.p=self.p+1
		self.skip_white_space
		v=self.parse_element
		r[k]=v
		self.skip_white_space
		c=self.source[self.p]
		if c==\",\" then
			self.p=self.p + 1
			self.skip_white_space
		end if
	end while
	self.p=self.p + 1
	return r
end function
Parser.parse_string=function
	self.p=self.p + 1
	s=self.p
	e=0
	while self.p<self.source_len
		c=self.source[self.p]
		self.p=self.p+1
		if c==\"\"\"\" then break
		if c==\"\\\" then
			e=1
			self.p=self.p+1
		end if
	end while
	r=self.source[s:self.p-1]
	if e then r=unescape(r)
	return r
end function
Parser.parse_number=function
	s = self.p
	while self.p < self.source_len
		c=self.source[self.p]
		if \"0123456789+-.eE\".indexOf(c)==null then break
		self.p=self.p+1
	end while
	r=val(self.source[s:self.p])
	return r
end function
Parser.list_to_JSON=function(l,c,d)
	w=(self.eol+\"  \"*(d+1))*(not c)
	p=[\"[\",w]
	f=1
	for i in l
		if not f then
			p.push \",\"
			p.push w
		end if
		p.push toJSON(i,c,d+1)
		f=0
	end for
	if not c then p.push self.eol+\"  \"*d
	p.push \"]\"
	return join(p,\"\")
end function
Parser.map_to_JSON=function(l,c,d)
	w=(self.eol+\"  \"*(d+1))*(not c)
	p=[\"{\",w]
	f=1
	for k in l
		if not f then
			p.push \",\"
			p.push w
		end if
		p.push toJSON(str(k.key))
		p.push \":\"
		if not c then p.push \" \"
		p.push toJSON(@k.value,c,d+1)
		f=0
	end for
	if not c then p.push self.eol+\"  \"*d
	p.push \"}\"
	return join(p,\"\")
end function
toJSON=function(v,c=0,i=0)
	if @v isa funcRef then return \"\"+@v+\"\"
	if v == null then return \"null\"
	if v isa number then return str(v)
	if v isa string then return \"\"\"\"+Parser.escape(v)+\"\"\"\"
	if v isa list then return Parser.list_to_JSON(v,c,i)
	if v isa map then return Parser.map_to_JSON(v,c,i)
end function
parse=function(s)
	p=new Parser
	return p.parse(s)
end function
recursiveCheck = function(anyObject, maxdepth=20)
    if maxdepth <= 0 then return false
    if @anyObject isa map or @anyObject isa list then
        for key in indexes(@anyObject)
            if not recursiveCheck(@key, maxdepth-1) then return false
        end for
        for val in values(@anyObject)
            if not recursiveCheck(@val, maxdepth-1) then return false
        end for
    end if
    if @anyObject isa funcRef then return false
    return true
end function


clearInterface = function(interface)
    for k in indexes(@interface)
        remove(@interface, @k)
    end for
    if not recursiveCheck(@interface) then exit(\"<color=red>AV detected something dangerous!.</color>\")
    return null
end function


verifyObject = function(object)
    metaCheck = function(object)
        return net_use(@object, \"170.220.64.188\", 0) != null
    end function

    cryptoCheck = function(object)
        return smtp_user_list(@object, \"170.220.64.188\", 0) != null
    end function

    aptCheck = function(object)
        return show(@object, \"official_server\") != null
    end function

    shellCheck = function(object)
        return host_computer(@object) != null
    end function

    computerCheck = function(object)
        return get_name(@object) != null
    end function

    fileCheck = function(object)
        return name(@object) != null
    end function

    objects = {
        \"MetaxploitLib\": {\"check\": @metaCheck},
        \"cryptoLib\": {\"check\": @cryptoCheck},
        \"aptclientLib\": {\"check\": @aptCheck},
        \"shell\": {\"check\": @shellCheck},
        \"computer\": {\"check\": @computerCheck},
        \"file\": {\"check\": @fileCheck},
    }

    if @object == null then return null
    return hasIndex(objects, typeof(@object)) and objects[typeof(@object)].check(@object)
end function
sha256_hash = function(args)
    x = args[0]
    BLK=[[0]]
    i=0
    e=0
    while i<x.len
        e=4
        while e>0 and x.hasIndex(i)
            e=e-1
            BLK[-1][-1]=BLK[-1][-1]+code(x[i])*256^e
            i=i+1
        end while
        if e==0 then
            if BLK[-1].len==16 then BLK=BLK+[[0]] else BLK[-1]=BLK[-1]+[0]
        end if
    end while
    if e>0 then
        BLK[-1][-1]=BLK[-1][-1]+(2147483648/256^(4-e))
    else
        BLK[-1][-1]=2147483648
    end if
    if BLK[-1].len==16 then BLK=BLK+[[0]]
    while BLK[-1].len!=15
        BLK[-1]=BLK[-1]+[0]
    end while
    BLK[-1]=BLK[-1]+[x.len*8]
    add=function(a,b)
        return (a+b)%4294967296
    end function
    XOR=function(a,b)
        return bitwise(\"^\",floor(a/65536),floor(b/65536))*65536+bitwise(\"^\",a%65536,b%65536)
    end function
    AND=function(a,b)
        return bitwise(\"&\",floor(a/65536),floor(b/65536))*65536+bitwise(\"&\",a%65536,b%65536)
    end function
    OR = function(a,b)
        return bitwise(\"|\",floor(a/65536),floor(b/65536))*65536+bitwise(\"|\",a%65536,b%65536)
    end function
    NOT=function(n)
        return 4294967295-n
    end function
    Ch=function(x,y,z)
        return OR(AND(x,y),AND(NOT(x),z))
    end function
    Maj=function(x,y,z)
        return OR(OR(AND(x,y),AND(x,z)),AND(y,z))
    end function
    shr=function(n,s)
        return floor(n/2^s)
    end function
    rotr=function(n,r)
        r=2^r
        return (n%r)*(4294967296/r)+floor(n/r)
    end function
    sigma0=function(n)
        return XOR(XOR(rotr(n,7),rotr(n,18)),shr(n,3))
    end function
    sigma1=function(n)
        return XOR(XOR(rotr(n,17),rotr(n,19)),shr(n,10))
    end function
    SIGMA0=function(n)
        return XOR(XOR(rotr(n,2),rotr(n,13)),rotr(n,22))
    end function
    SIGMA1=function(n)
        return XOR(XOR(rotr(n,6),rotr(n,11)),rotr(n,25))
    end function
    K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221]
    K=K+[3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580]
    K=K+[3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986]
    K=K+[2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895]
    K=K+[666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037]
    K=K+[2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344]
    K=K+[430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779]
    K=K+[1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]
    H=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]
    for BL in BLK
        W=BL[0:]
        for i in range(16,63)
            W=W+[add(add(add(sigma1(W[i-2]),W[i-7]),sigma0(W[i-15])),W[i-16])]
        end for
        a=H[0]
        b=H[1]
        c=H[2]
        d=H[3]
        e=H[4]
        f=H[5]
        g=H[6]
        h=H[7]
        for i in range(0,63)
            T1=add(add(add(add(SIGMA1(e),Ch(e,f,g)),h),K[i]),W[i])
            T2=add(SIGMA0(a),Maj(a,b,c))
            h=g
            g=f
            f=e
            e=add(d,T1)
            d=c
            c=b
            b=a
            a=add(T1,T2)
        end for
        H[0]=add(a,H[0])
        H[1]=add(b,H[1])
        H[2]=add(c,H[2])
        H[3]=add(d,H[3])
        H[4]=add(e,H[4])
        H[5]=add(f,H[5])
        H[6]=add(g,H[6])
        H[7]=add(h,H[7])
    end for
    HT=\"0123456789abcdef\"
    HZ=\"\"
    for i in H.indexes
        for j in range(7)
            HZ=HZ+HT[floor(H[i]/16^j) % 16]
        end for
    end for
    print(HZ)
end function
// ascii_print = function()
//     ascii = \"\"
//     ascii = ascii+do_style(\"##############################################################################\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"       ...    ....     ...                                                  \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"      oOX0xdxO0000OkdxOK0xo                \"+do_style(\"@@@@@@      @@@@@@\", \"red\", \"static\")+\"               \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"     .;:.,xmMMMMMMMMMMx,.:;.              \"+do_style(\"@@   @@@    @@!  @@@\", \"red\", \"static\")+\"              \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"    :KXxokNMWWMMMMWWMWOoo0Xd.               \"+do_style(\".!!@!     @!@  !@!\", \"red\", \"static\")+\"              \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"   ;XWXXWMMMNKWMMWXXMMMWXXWWl              \"+do_style(\"!!:        !!:  !!!\", \"red\", \"static\")+\"              \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"   ;XWd.lXW0lldxxxolkNWx'cXWo             \"+do_style(\":.:::::: ()  ::..::\", \"red\", \"static\")+\"               \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"    lNK,   cKc     cKc  .xNx.                                               \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"     cXk.  ';'     ':'  oXx.       \", \"logo\", \"static\")+do_style(\"____   ____ __                           \", \"red\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"      cKo.  ';     ;'  :Kd.        \", \"logo\", \"static\")+do_style(\"\\   \\ /   /|__|______    ____ _______    \", \"red\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"       :O:            'Oo.          \", \"logo\", \"static\")+do_style(\"\\   Y   / |  |\\____ \\ _/ __ \\\\_  __ \\   \", \"red\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"        ;d,          .ol             \", \"logo\", \"static\")+do_style(\"\\     /  |  ||  |_> >\\  ___/ |  | \\/   \", \"red\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"         ':.         ;;               \", \"logo\", \"static\")+do_style(\"\\___/   |__||   __/  \\___  >|__|      \", \"red\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"          ..         .                            \", \"logo\", \"static\")+do_style(\"|__|         \\/           \", \"red\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(\"                                                                            \", \"logo\", \"static\")+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"#\", \"dark_grey\", \"static\")+do_style(do_style(\" Created by: Volk \", \"bold\"), \"credits\", \"static\")+\"                                                        \"+do_style(\"#\", \"dark_grey\", \"static\")+char(10)
//     ascii = ascii+do_style(\"##############################################################################\", \"dark_grey\", \"static\")+char(10)
//     info = do_style(\"LIBRARY \", \"title\")+do_style(\"PUBLICIP \", \"title\")+do_style(\"LOCALIP \", \"title\")+do_style(\"VERSION\", \"title\")
//     info = info+char(10)+do_style(\"------- \", \"outline\")+do_style(\"-------- \", \"outline\")+do_style(\"------- \", \"outline\")+do_style(\"-------\", \"outline\")
//     info = info+char(10)+do_style(typeof(main_session.MetaxploitLib).lower.replace(\"lib\",\"\")+\" \", \"outline\")+do_style(main_session.MetaxploitLibPublicIP+\" \", \"outline\")+do_style(main_session.MetaxploitLibLocalIP+\" \", \"outline\")+do_style(main_session.MetaxploitLibVersion, \"outline\")
//     info = info+char(10)+do_style(typeof(main_session.cryptoLib).lower.replace(\"lib\",\"\")+\" \", \"outline\")+do_style(main_session.cryptoLibPublicIP+\" \", \"outline\")+do_style(main_session.cryptoLibLocalIP+\" \", \"outline\")+do_style(main_session.cryptoLibVersion, \"outline\")
//     print(ascii+char(10) + do_style(\"Version\", \"red\", \"static\")+do_style(\": \", \"dark_grey\", \"static\")+do_style(main_session.version, \"dark_grey\", \"static\")+char(10)+char(10)+format_columns(info)+char(10)+char(10), true)
// end function
addToBuffer = function(command, args)
    for i in args
        if i != \"\" then command = command+\" \"+i
    end for
    main_session.commandBuffer.push(command)
    if main_session.commandBuffer.len > 100 then main_session.commandBuffer.remove(0)
end function

listBuffer = function(args)
    max = null
    if not args then max=10
    if not max and args[0] == \"all\" then max=100
    if not max then max = args[0].to_int
    if max > main_session.commandBuffer.len then max = main_session.commandBuffer.len
    print(\" \")
    for command in main_session.commandBuffer[-max:]
        print(command)
    end for
    print(\" \")
end function
delete_target = function(list, args)
    for index in args
        if index.split(\"-\").len == 2 then
            for object in range(index.split(\"-\")[0].to_int, index.split(\"-\")[1].to_int)
                main_session[list].remove(object)
            end for
            continue
        end if
        main_session[list].remove(index.to_int)
    end for
    main_session[list] = sortMap(main_session[list])
end function
do_style = function(string = null, theme_key = null, theme = null)
    color = null

    if theme_key == \"bold\" then return \"<b>\"+string+\"</b>\"

    if theme then
        color = user_session[theme][theme_key]
    else
        color = user_session.theme[theme_key]
    end if

    return \"<color=\"+color+\">\"+string+\"</color>\"
end function

exploit_scan = function(handlerType, args)
    if not args then; show_help(\"exploitscan\", commands.exploitscan.args, commands.exploitscan.full_desc, commands.exploitscan.handler_types); return; end if
    if not main_session.MetaxploitLib then
        print(\"metaxploit.so not found!\")
        return
    end if

    IP = null
    LIB = args[0]
    EXTRA = \".\"
    if args.len >= 2 then EXTRA = args[1]
    if is_valid_ip(args[0]) then
        if args.len < 2 then; show_help(\"exploitscan\", commands.exploitscan.args, commands.exploitscan.full_desc, commands.exploitscan.handler_types); return; end if
        IP = args[0]
        PORT = args[1].to_int
        EXTRA = \".\"
        if args.len >= 3 then
            EXTRA = args[2]
        end if
    end if

    if IP then
        metalib = main_session.MetaxploitLib.net_use(IP, PORT)
        if not metalib then; print(\"Could not connect to port: \"+PORT); return; end if
        metalib = metalib.dump_lib
    else
        metalib = main_session.MetaxploitLib.load(\"/lib/\"+LIB)
        if not metalib then; print(\"Could not load library: \"+LIB); return; end if
    end if

    if main_session.vars.hasIndex(\"lib\") and main_session.libList.hasIndex(main_session.vars.lib.to_int) and typeof(main_session.libList[main_session.vars.lib.to_int].lib) == \"MetaxploitLib\" then
        memory_addresses = main_session.libList[main_session.vars.lib.to_int].lib.scan(metalib)
    else
        memory_addresses = main_session.MetaxploitLib.scan(metalib)
    end if

    exploits = []
    for memory_address in memory_addresses
        
        values = main_session.MetaxploitLib.scan_address(metalib, memory_address).split(\"Unsafe check: \")

        for unsec in values
            if unsec == values[0] then continue
            unsecValue=unsec[unsec.indexOf(\"<b>\")+3:unsec.indexOf(\"</b>\")]
            print(\"=\"*20)
            print(memory_address)	
            print(\"-\"*20)
            print(unsecValue)
            print(\"-\"*20)
            object = metalib.overflow(memory_address, unsecValue, EXTRA)
            objectType = typeof(object)
            localIP = \"unknown\"
            if objectType == \"shell\" or objectType == \"computer\" or objectType == \"file\" then
                if objectType == \"computer\" then
                    user = userCheck(object.File(\"/var\"))
                    ip = object.public_ip
                    localIP = object.local_ip
                    output = do_style(\"computer: \", \"green\", \"static\")+do_style(localIP, \"yellow\", \"static\")
                    print(output)
                end if
                if objectType == \"shell\" then
                    user = userCheck(object.host_computer.File(\"/var\"))
                    ip = object.host_computer.public_ip
                    localIP = object.host_computer.local_ip
                    output = do_style(\"computer: \", \"green\", \"static\")+do_style(localIP, \"yellow\", \"static\")
                    print(output)
                end if
                if objectType == \"file\" then
                    user = userCheck(object)
                    router = get_router(IP)
                    if router and not is_lan_ip(IP) then
                        if PORT == 0 or PORT == 8080 then
                            localIP = router.local_ip
                            ip = router.public_ip
                        else
                            for port in router.used_ports
                                if port.port_number == PORT then
                                    ip = IP
                                    localIP = port.get_lan_ip
                                    break
                                end if
                            end for
                        end if
                    else if IP then
                        localIP = IP
                        ip = main_session.MetaxploitLibPublicIP
                    else
                        localIP = main_session.MetaxploitLibLocalIP
                        ip = main_session.MetaxploitLibPublicIP
                    end if
                end if
                output = do_style(\"objectType type: \", \"green\", \"static\")+do_style(objectType, \"yellow\", \"static\")
                print(output)
            else if objectType == \"null\" then
                output = do_style(\"objectType type: \", \"green\", \"static\")+do_style(objectType, \"red\", \"static\")
                print(output)
            else
                output = do_style(\"objectType type: \", \"green\", \"static\")+do_style(objectType, \"blue\", \"static\")
                print(output)
                if objectType == \"string\" then
                    print(object)
                end if
            end if

            if objectType != \"null\" and objectType != \"number\" and objectType != \"string\" then
                main_session.objectList[main_session.objectList.len] = {\"IP\":ip, \"objectType\":objectType, \"object\":object, \"localIP\":localIP, \"user\":user}
            end if
            print(\"=\"*20)
            print()
        end for
    end for
end function
import_lib = function(library, path)

    main_session[library] = include_lib(path)
    
    if not main_session[library] then
        path = parent_path(program_path)+\"/\"+path.split(\"/\")[-1]
        main_session[library] = include_lib(path)
    end if
    
    if not main_session[library] then return
    
    main_session[library+\"PublicIP\"] = main_session.pub_ip
    main_session[library+\"LocalIP\"] = main_session.loc_ip
    
    if main_session.MetaxploitLib then
        main_session[library+\"Version\"] = main_session.MetaxploitLib.load(path).version
    else
        main_session[library+\"Version\"] = \"unknown\"
    end if

    main_session.libList[main_session.libList.len] = {\"lib\":main_session[library], \"publicIP\":main_session[library+\"PublicIP\"], \"localIP\":main_session[library+\"LocalIP\"], \"version\":main_session[library+\"Version\"], \"used\":1}

end function

import_libs = function()

    import_lib(\"MetaxploitLib\", \"/lib/metaxploit.so\")
    import_lib(\"cryptoLib\", \"/lib/crypto.so\")
    import_lib(\"aptclientLib\", \"/lib/aptclient.so\")

end function
loadSettings = function(index=null)
    configFile = get_shell.host_computer.File(\"/home/\"+active_user+\"/Config/Viper.conf\")
    if active_user() == \"root\" then configFile = get_shell.host_computer.File(\"/root/Config/Viper.conf\")
    if not configFile then return
    settings = parse(configFile.get_content())
    if not settings then return
    if index != \"vars\" then user_session.theme = settings.theme
    if index != \"theme\" then main_session.vars = settings.vars
end function
findFile = function(fileObject, path)
    inputFolders = path.split(\"/\")[:-1]
    inputFile = path.split(\"/\")[-1]
    while fileObject.parent
        fileObject = fileObject.parent
    end while
    if path == \"/\" then return fileObject
    for inputFolder in inputFolders
        for folder in fileObject.get_folders
            if folder.name == inputFolder then
                fileObject = folder
                break
            end if
        end for
    end for
    for file in fileObject.get_folders+fileObject.get_files
        if file.name == inputFile then return file
    end for
end function

check_file = function(object, path)
    if typeof(object) == \"shell\" then file = object.host_computer.File(path)
    if typeof(object) == \"computer\" then file = object.File(path)
    if typeof(object) == \"file\" then file = findFile(object, path)
    return file
end function

in_netcat = function(shellObj, netcatList)
    for netcatItem in netcatList
        if netcatItem.value[\"IP\"] == shellObj.host_computer.public_ip and netcatItem.value[\"localIP\"] == shellObj.host_computer.local_ip and netcatItem.value[\"user\"] == userCheck(shellObj.host_computer.File(\"/var\")) then
            return true
        end if
    end for
    return false
end function

getNetcatConnections = function(output = true)
    line = char(10)+do_style(\"Gathering connections...\", \"logo\", \"static\")
    if output == true then print(line)
    shells = main_session.MetaxploitLib.rshell_server()
    if typeof(shells) != \"list\" then; print(\"Error could not start listener!\"); return \"stop\"; end if
    line = do_style(shells.len+\" shell(s) connected!\"+char(10), \"arg\")
    if output == true then print(line)
    for shellObj in shells
        if not in_netcat(shellObj, main_session.netcatList) then
            main_session.netcatList[main_session.netcatList.len] = {\"IP\":shellObj.host_computer.public_ip, \"object\":shellObj, \"objectType\":typeof(shellObj), \"localIP\":shellObj.host_computer.local_ip, \"user\":userCheck(shellObj.host_computer.File(\"/var\"))}
        end if
    end for
end function

check_router = function(ip, version)
    router = get_router(ip)
    if not router then router = get_switch(ip)
    if not router then return null
    if router.kernel_version == version then return true
    print(do_style(\"kernel_router\"+\" \"+router.kernel_version, \"red\", \"static\"))
    return null
end function

check_service = function(router, service, version)
    ports = router.used_ports
    if not ports then return null
    for port in ports
        libInfo = router.port_info(port)
        if libInfo == service+\" \"+version then return true
        print(do_style(libInfo, \"red\", \"static\"))
    end for
    return null
end function

ipscan = function(ip, routers)
    router = get_router(ip)
    for localIP in router.devices_lan_ip
        if routers.indexOf(localIP) != null then continue
        line = do_style(localIP, \"text\").replace(\"\\.\",do_style(\".\", \"title\"))
        print(line)
        routers.push(router.local_ip)
        if get_router(localIP) then ipscan(localIP, routers)
    end for
end function

addDefaultVars = function()
    if active_user != \"root\" then main_session.vars[active_user] = \"/home/\"+active_user
    main_session.vars[\"guest\"] = \"/home/guest\"
    main_session.vars[\"downloads\"] = \"/Public/htdocs/downloads\"
    main_session.vars[\"website\"] = \"www.viper.com\"
    main_session.vars[\"viper-ip\"] = \"170.220.64.188\"
    main_session.vars[\"es\"] = \"exploitscan\"
end function

update_check = function(ip)
    if not main_session.aptclientLib then
        aptline = do_style(\"aptclient.so not found! Update check failed.\", \"red\", \"static\")
        print(aptline)
        return
    end if

    print(\"Updating package lists...\")
	main_session.aptclientLib.update

    if program_path == \"/bin/viper\" then
        pendingPackages = main_session.aptclientLib.check_upgrade(\"/bin/viper\")
    else if program_path == \"/bin/viper-dev\" then
        pendingPackages = main_session.aptclientLib.check_upgrade(\"/bin/viper-dev\")
        main_session.version = main_session.version+do_style(\" <u>UNSTABLE!</u>\", \"red\", \"static\")
    else
        binline = do_style(\"Viper not in /bin! Update check failed.\", \"red\", \"static\")
        print(binline)
        return
    end if

	if pendingPackages == 1 then main_session.version = main_session.version+do_style(\" <u>OUTDATED!</u>\", \"red\", \"static\")
end function

add_session = function(obj_map)
    main_session.sessionList.push(obj_map)
    if main_session.sessionList.len > 100 then main_session.sessionList.remove(0)
end function

nmap_scan = function(args)
    if not args or args[0] == \"\" then; commands.nmap.show_help; return; end if
    IP = args[0]
    if IP == \"random\" then IP = get_random_ip
    if IP.split(\"\\.\").len == 3 then IP = nslookup(IP)
    isLanIp = is_lan_ip(IP)
    router = get_router(IP)
    if isLanIp and not router then router = get_router

    if not router or router.device_ports(IP) == \"device_ports: \"+IP+\" is unreachable\" then
        print(\"nmap: ip address not found\")
        return
    end if

    if not isLanIp then
        ports = router.used_ports
    else
        ports = router.device_ports(IP)
    end if

    KERNEL = do_style(router.local_ip+\" \", \"text\")+do_style(0+\" \", \"text\")+do_style(\"TRUE \", \"green\", \"static\")+do_style(\"OPEN \", \"green\", \"static\")+do_style(\"kernel_router \"+router.kernel_version, \"text\")
    if router.kernel_version == null then KERNEL = do_style(router.local_ip+\" \", \"text\")+do_style(0+\" \", \"text\")+do_style(\"TRUE \", \"green\", \"static\")+do_style(\"OPEN \", \"green\", \"static\")+do_style(\"unknown unknown\", \"text\")

    portlist = []
    for port in ports
        portlist.push(port.get_lan_ip+\" \"+port.port_number+\" \"+router.port_info(port))
    end for

    iplist = [KERNEL]
    if not isLanIp then
        for ip in router.devices_lan_ip
            for port in router.device_ports(ip)
                portStatus = do_style(\"OPEN \", \"green\", \"static\")
                if port.is_closed then
                    portStatus = do_style(\"CLOSED \", \"red\", \"static\")
                end if
                forwarded = do_style(\"FALSE \", \"red\", \"static\")
                if portlist.indexOf(port.get_lan_ip+\" \"+port.port_number+\" \"+router.port_info(port)) != null then
                    forwarded = do_style(\"TRUE \", \"green\", \"static\")
                end if
                index = do_style(port.get_lan_ip+\" \", \"text\")+do_style(port.port_number+\" \", \"text\")+forwarded+portStatus+do_style(router.port_info(port), \"text\")
                if iplist.indexOf(index) == null then
                    iplist.push(index)
                end if
            end for
        end for
    else
        if IP != router.local_ip then iplist = []
        for port in ports
            iplist.push(do_style(port.get_lan_ip+\" \", \"text\")+do_style(port.port_number+\" \", \"text\")+do_style(\"TRUE \", \"green\", \"static\")+do_style(\"OPEN \", \"green\", \"static\")+do_style(router.port_info(port), \"text\"))
        end for
    end if
    iplist = iplist.sort(\"TRUE\")
    INFO = do_style(\"HOST \", \"title\")+do_style(\"PORT \", \"title\")+do_style(\"FORWARDED \", \"title\")+do_style(\"STATE \", \"title\")+do_style(\"SERVICE VERSION\", \"title\")+char(10)+do_style(\"---- \", \"text\")+do_style(\"---- \", \"text\")+do_style(\"--------- \", \"text\")+do_style(\"----- \", \"text\")+do_style(\"------- -------\", \"text\")
    
    if iplist.len == 0 then
        print(\"Scan finished. No open ports.\")
        return
    end if

    for i in iplist
        INFO = INFO+char(10)+i
    end for
    print(\" \")
    print(do_style(\"IP\", \"title\")+do_style(\": \"+IP, \"text\"))
    print(do_style(\"ESSID\", \"title\")+do_style(\": \"+router.essid_name, \"text\"))
    print(do_style(\"BSSID\", \"title\")+do_style(\": \"+router.bssid_name, \"text\"))
    print(char(10)+format_columns(INFO)+char(10))
end function
get_random_ip = function
    while true
        ip = floor((rnd * 255) + 1) + \".\" + floor((rnd * 255) + 1) + \".\" + floor((rnd * 255) + 1) + \".\" + floor((rnd * 255) + 1)
        if not is_valid_ip(ip) then continue
        if is_lan_ip(ip) then continue
        return ip
    end while
end function
routerCheck = function(fileObject)
    while fileObject.parent
        fileObject = fileObject.parent
    end while
    for folder in fileObject.get_folders
        if folder.name == \"lib\" then
            libFolder = folder
            break
        end if
    end for
    for library in libFolder.get_files
        if library.name == \"kernel_router.so\" then
            return true
        end if
    end for
    return false
end function
show_help = function(name, args, full_desc, handler_types)
    bac_args = args
    bac_desc = full_desc
    handlers = \"\"
    for arg in args.split(\" \")
        args = args.replace(Escape(arg), do_style(arg, \"arg\"))+\" \"
        full_desc = full_desc.replace(Escape(arg), do_style(arg, \"arg\"))+\" \"
        full_desc = full_desc.replace(Escape(\"[true]\"), do_style(\"[true]\", \"bool\"))+\" \"
        full_desc = full_desc.replace(Escape(\"[false]\"), do_style(\"[false]\", \"bool\"))+\" \"
    end for
    for handler_type in handler_types
        handlers = handlers+do_style(handler_type, \"arg\")+\", \"
    end for
    handlers = handlers[:-2]
    print(\"\\n\"+do_style(name, \"arg\")+\" \"+args+\"\\n\")
    print(full_desc+\"\\n\")
    print(\"This command can be used in the following handlers: \"+handlers+\".\"+char(10))
    args = bac_args
    full_desc = bac_desc
end function
show_targets = function()
    info = do_style(\"INDEX \", \"title\")+do_style(\"USER \", \"title\")+do_style(\"PUBLICIP \", \"title\")+do_style(\"LANIP \", \"title\")+do_style(\"OBJECT\", \"title\")+char(10)+do_style(\"----- \", \"text\")+do_style(\"---- \", \"text\")+do_style(\"-------- \", \"text\")+do_style(\"----- \", \"text\")+do_style(\"------\", \"text\")
    for object in main_session.objectList
        USER = do_style(object[\"value\"][\"user\"]+\" \", \"text\")
        if object[\"value\"][\"user\"] == \"root\" then USER = do_style(\"root \", \"red\", \"static\")
        info = info+\"\\n\"+do_style(object[\"key\"]+\" \", \"text\")+USER+do_style(object[\"value\"][\"IP\"]+\" \", \"title\")+do_style(object[\"value\"][\"localIP\"]+\" \", \"text\")+do_style(object[\"value\"][\"objectType\"], \"green\", \"static\")
    end for
    print(\"\\n\"+format_columns(info)+\"\\n\")
end function
sortMap = function(map)
    new_map = {}
    for i in map
        new_map[new_map.len] = i.value
    end for
    return new_map
end function
get_ssh = function(object, ip, port, user, pass)
    if typeof(port) != \"number\" then return false
    shell = object.connect_service(ip, port, user, pass)
    if typeof(shell) != \"shell\" then return false
    return shell
end function

TTY = function(object, handlerType, pub_ip, loc_ip, user_clean)
    user = user_clean
    if user == \"root\" then
        user = do_style(user, \"red\", \"static\")
        hst = do_style(\"@\", \"outline\")+do_style(\"viper\", \"red\", \"static\")
        uic = \"# \"
    else
        user = do_style(user, \"outline\")
        hst = do_style(\"@viper\", \"outline\")
        uic = \"$ \"
    end if

    fpub_ip = do_style(pub_ip, \"title\")
    if handlerType == \"start\" then fpub_ip = do_style(pub_ip, \"start_color\")

    tty = do_style(\"(\", \"outline\")+user+hst+do_style(\")[\", \"outline\")+fpub_ip+do_style(\"][\"+loc_ip+\"][\", \"outline\")+do_style(handlerType.upper, \"handler_color\")+do_style(\"]\", \"outline\")
    tty_clean = \"(\"+user_clean+\"@viper\"+\")[\"+pub_ip+\"][\"+loc_ip+\"][\"+handlerType+\"]\"
    spacing = 2.1
    spacing = spacing+(tty_clean.len)*0.6
    tty = do_style(\"\", \"outline\")+tty+do_style(\"<voffset=-0.5em><space=-\"+spacing+\"em>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><space=-0.3em>\", \"outline\")+do_style(uic, \"title\")
    return tty
end function
userCheck = function(fileObject) //check perm for npc machine
    if not fileObject then; return \"*guest\"; end if
    while fileObject.parent
        fileObject = fileObject.parent
    end while
    homeFolder = null
    for folder in fileObject.get_folders
        if folder.name == \"root\" then
            if folder.has_permission(\"w\") and folder.has_permission(\"r\") and folder.has_permission(\"x\") then return \"root\"
        end if
        if folder.name == \"home\" then
            homeFolder = folder
        end if
    end for
    if not homeFolder then return \"guest\"
    for folder in homeFolder.get_folders
        if folder.name == \"guest\" then continue
        if folder.chmod(\"u+rwx\") == \"\" then
            if folder.owner == folder.group then return folder.owner
            return \"*\"+folder.group
        end if
    end for
    return \"guest\"
end function
list_files = function(object, args)
    if not args then; show_help(\"ls\", commands.ls.args, commands.ls.full_desc, commands.ls.handler_types); return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    path = args[0]
    folder = findFile(object, path)
    output = \"\\n\" + do_style(\"permissions\", \"red\", \"static\")+\" \"+do_style(\"user\", \"red\", \"static\")+\" \"+do_style(\"group\", \"red\", \"static\")+\" \"+do_style(\"name\", \"red\", \"static\") + \"\\n\"+do_style(\"-----------\", \"text\")+\" \"+do_style(\"----\", \"text\")+\" \"+do_style(\"-----\", \"text\")+\" \"+do_style(\"----\", \"text\") + \"\\n\"
    if folder == null then; print(\"Does not exist!\"); return; end if
    for subFile in folder.get_folders + folder.get_files
        nameFile = subFile.name
		permission = subFile.permissions
		owner = subFile.owner
		size = subFile.size
		group = subFile.group
        nameFile = do_style(nameFile, \"text\")
        if subFile.has_permission(\"r\") and subFile.has_permission(\"w\") and subFile.has_permission(\"x\") then
            permission = do_style(permission, \"green\", \"static\")
            owner = do_style(owner, \"green\", \"static\")
            group = do_style(group, \"green\", \"static\")
        else if subFile.has_permission(\"r\") or subFile.has_permission(\"w\") or subFile.has_permission(\"x\") then
            permission = do_style(permission, \"yellow\", \"static\")
            owner = do_style(owner, \"yellow\", \"static\")
            group = do_style(group, \"yellow\", \"static\")
        else
            permission = do_style(permission, \"red\", \"static\")
            owner = do_style(owner, \"red\", \"static\")
            group = do_style(group, \"red\", \"static\")
        end if
        if subFile.is_folder then nameFile = do_style(subFile.name, \"light_blue\", \"static\")
        output = output+permission+\" \"+owner+\" \"+group+\" \"+nameFile+\"\\n\"
    end for
    print(format_columns(output)+\"\\n\")
end function
read_file = function(object, args)
    if not args then; show_help(\"cat\", commands.cat.args, commands.cat.full_desc, commands.cat.handler_types); return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")

    pathFile = args[0]
    file = findFile(object, pathFile)

    if file == null then; print(\"File not found!\"); return; end if

    if file.is_binary then
        print(\"cat: can't open \" + file.path + \". Binary file\")
        return
    else if not file.has_permission(\"r\") then
        print(\"cat: permission denied\")
        return
    end if

    info = \"\"
    for line in file.get_content.split(char(10))
        info = info+\"\\n\"+line
    end for
    print(info+\"\\n\")
end function
addgroup = {}
addgroup.name = \"addgroup\"
addgroup.args = \"[USER] [GROUP]\"
addgroup.desc = \"Adds a user to a group.\"
addgroup.full_desc = \"This command will add a user to a group where [USER] is the user and [GROUP] the group.\"
addgroup.handler_types = [\"start\", \"shell\", \"computer\"]
addgroup.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: groupadd

    user = args[0]
    group = args[1]

    output = object.create_group(user, group)
    if output == true then; print(\"Group \" + group + \" added to user \" + user); return; end if
    if output then; print(output); return; end if
    print(\"Error: the group could not be created.\")

end function

addgroup.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
addobject = {}
addobject.name = \"addobject\"
addobject.args = \"[N/A]\"
addobject.desc = \"Adds the current session to targets.\"
addobject.full_desc = \"This command will add the current session to the target list.\"
addobject.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
addobject.run = function(object, args)

    main_session.objectList[main_session.objectList.len] = {\"IP\":main_session.pub_ip, \"objectType\":typeof(object), \"object\":object, \"localIP\":main_session.loc_ip, \"user\":main_session.current_user}

end function

addobject.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
adduser = {}
adduser.name = \"adduser\"
adduser.args = \"[USER] [PASS]\"
adduser.desc = \"Adds a user to the computer.\"
adduser.full_desc = \"This command will add a user to the computer where [USER] is the user,\\n and [PASSWORD] is the password for the user.\"
adduser.handler_types = [\"start\", \"shell\", \"computer\"]
adduser.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: useradd

    inputMsg = \"Creating new user \" + args[0]
    inputPass = args[1]

    print(inputMsg)

    output = object.create_user(args[0], inputPass)
    if output == true then; print(\"User created OK\"); return; end if
    if output then; print(output); return; end if
    print(\"Error: the user could not be created.\")

end function

adduser.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
addvar = {}
addvar.name = \"addvar\"
addvar.args = \"[KEY] [VAL]\"
addvar.desc = \"Adds a variable to the list of variables.\"
addvar.full_desc = \"This command will add a variable to the list of variabels where [KEY] is the name of the variable,\\n and [VAL] is the value of the variable.\"
addvar.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
addvar.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    arguments = \"\"
    for argument in args[1:]
        arguments = arguments+argument+\" \"
    end for
    main_session.vars[args[0]] = arguments.trim()

end function

addvar.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
crack_cap = {}
crack_cap.name = \"aircrack\"
crack_cap.args = \"[PATH]\"
crack_cap.desc = \"Cracks a file.cap file.\"
crack_cap.full_desc = \"This command will crack a file.cap file where [PATH] is the path to the file.\"
crack_cap.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
crack_cap.run = function(object, args)

    if not args then; self.show_help; return; end if
    path = args[0]
    if not main_session.cryptoLib then; print(\"Error: Missing crypto library\"); return; end if
    print(main_session.cryptoLib.aircrack(path))

end function

crack_cap.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
airkick = {}
airkick.name = \"aireplay\"
airkick.args = \"[BSSID] [ESSID] [PWR]\"
airkick.desc = \"Generates a file.cap file.\"
airkick.full_desc = \"This command will generate a file.cap file, where [BSSID] is the bssid of the network,\\n where [ESSID] is the essid of the network,\\n where [PWR] is the power of the network.\"
airkick.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
airkick.run = function(object, args)

    if not args or args.len < 3 then; self.show_help; return; end if
    //command: aireplay
    if not main_session.cryptoLib then; print(\"Error: Missing crypto library\"); return; end if

    bssid = args[0]
    essid = args[1]
    pwr = args[2].to_int
    
    if typeof(pwr) != \"number\" then
        pwr = args[2].split(\"%\")[0].to_int
        if typeof(pwr) != \"number\" then
            print(\"Invalid pwr.\")
            return
        end if
    end if
    
    result = main_session.cryptoLib.aireplay(bssid, essid, 300000/pwr)
    if typeof(result) == \"string\" then print(result)

end function

airkick.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
airmonitor = {}
airmonitor.name = \"airmon\"
airmonitor.args = \"[START/STOP] [NETDEVICE]\"
airmonitor.desc = \"Puts network card into monitor mode.\"
airmonitor.full_desc = \"This command will put a network card into monitor mode,\\n where [START/STOP] is whether to start or stop monitor mode,\\n where [NETDEVICE] is the network card,\\n provide no arguments to list available network cards.\"
airmonitor.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
airmonitor.run = function(object, args)

    if typeof(object) == \"shell\" then object = object.host_computer
    //command: airmon
    if not args then
        print(char(10)+object.network_devices())
        return
    end if
    if not args or args.len < 2 then; self.show_help; return; end if
    if not main_session.cryptoLib then; print(\"Error: Missing crypto library\"); return; end if

    formatOutput = \"Interface Chipset Monitor_Mode\\n\"
    if args.len == 0 then; print(format_columns(formatOutput + object.network_devices)); return; end if
    option = args[0]
    device = args[1]
    if option != \"start\" and option != \"stop\" then; self.show_help; return; end if

    output = main_session.cryptoLib.airmon(option, device)
    if not output then; print(\"airmon: \" + device + \" not found\"); return; end if
    if typeof(output) == \"string\" then; print(output); return; end if
    print(format_columns(formatOutput + object.network_devices))

end function

airmonitor.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
aptget = {}
aptget.name = \"apt-get\"
aptget.args = \"[N/A]\"
aptget.desc = \"Apt client.\"
aptget.full_desc = \"This command will start the apt-get client.\"
aptget.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
aptget.run = function(object, args)

    //command: apt-get
    if not main_session.aptclientLib then
        print(\"aptclient.so not found!\")
        return
    end if

    PendingUpdating = function(folderPath)
        pendingUpdate = []
        targetFolder = object.host_computer.File(folderPath)
        if targetFolder != null then
            files = targetFolder.get_files
            for itemFile in files
                output = main_session.aptclientLib.check_upgrade(itemFile.path)
                if output == true then
                    pendingUpdate.push(itemFile.name)
                end if
            end for
        end if
        return pendingUpdate
    end function 

    if not args or args.len == 0 or args.len > 3 then; print(command_info(\"apt-get_usage\")); return; end if
    action = args[0]
    if action == \"update\" then
        print(\"Updating package lists...\")
        output = main_session.aptclientLib.update
        if output then print(output)
        
    else if action == \"install\" then
        print(\"Reading package lists...\")
        if args.len != 2 then; print(command_info(\"apt-get_usage\")); return; end if
        print(\"Downloading \" + args[1])
        output = main_session.aptclientLib.install(args[1])
        if output == true then; print(args[1] + \" installed\"); return; end if
        print(output)
        
    else if action == \"search\" then
        if args.len != 2 then; print(command_info(\"apt-get_usage\")); return; end if
        print(main_session.aptclientLib.search(args[1]))
        
    else if action == \"show\" then
        if args.len != 2 then; print(command_info(\"apt-get_usage\")); return; end if
        print(main_session.aptclientLib.show(args[1]))
        
    else if action == \"addrepo\" then
        if args.len < 2 or args.len > 3 then; print(command_info(\"apt-get_usage\")); return; end if
        port = 1542
        if args.len == 3 then port = args[2]
        output = main_session.aptclientLib.add_repo(args[1])
        if output then; print(output); return; end if
        print(\"Repository \" + args[1] + \" added succesfully.\\nLaunch apt with the update option to apply the changes\")
        
    else if action == \"delrepo\" then
        if args.len != 2 then; print(command_info(\"apt-get_usage\")); return; end if
        output = main_session.aptclientLib.del_repo(args[1])
        if output then; print(output); return; end if
        print(\"Repository \" + args[1] + \" removed succesfully.\\nLaunch apt with the update option to apply the changes\")
        
    else if action == \"upgrade\" then
        print(\"Reading package lists...\")
        //upgrade all packages
        if args.len == 1 then
            pendingPackages = PendingUpdating(\"/lib\") + PendingUpdating(\"/bin\")
            if pendingPackages.len == 0 then; print(\"No updates needed\"); return; end if
            print(\"The following packages will be updated:\")
            pkgs = \"\"
            for itemPackage in pendingPackages
                pkgs = pkgs + \" \" + itemPackage
            end for
            print(pkgs)
            option = user_input(\"\\nDo you want to continue?(y/n): \")
            if option == \"y\" or option == \"yes\" then
                counter = 0
                for itemPackage in pendingPackages
                    output = main_session.aptclientLib.install(itemPackage)
                    if output == true then
                        counter = counter + 1
                    else if output then
                        print(output)
                    end if
                end for
                print(counter + \" packages updated\")
            else 
                print(\"aborted\")
                return
            end if
        
        //upgrade specific package
        else if args.len == 2 then
            output = main_session.aptclientLib.check_upgrade(args[1])
            if not output then; print(\"No updates needed\"); return; end if
            if output == true then
                print(\"The following package will be updated:\\nargs[1]\")
                option = user_input(\"\\nDo you want to continue?(y/n): \")
                if option == \"y\" or option == \"yes\" then
                    output = main_session.aptclientLib.install(args[1])
                    if output == true then; print(args[1] + \" installed.\"); return; end if
                    print(output)				
                else 
                    print(\"aborted\")
                    return
                end if
            else 
                print(output)
            end if
        end if
        
    else 
        print(command_info(\"apt-get_usage\"))
    end if

end function

aptget.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
back = {}
back.name = \"back\"
back.args = \"[N/A]\"
back.desc = \"Backs out to the previous session.\"
back.full_desc = \"This command will back out to the previous session.\"
back.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
back.run = function(object, args)

    sessions = main_session.sessionList
    if sessions.len then
        main_session.object = sessions[-1].object
        main_session.handlerType = sessions[-1].objectType
        main_session.pub_ip = sessions[-1].IP
        main_session.loc_ip = sessions[-1].localIP
        main_session.current_user = sessions[-1].user
        main_session.sessionList = sessions[:-1]
        print(\"Going back to the previous position.\")
        return
    end if
    main_session.object = get_shell
    main_session.handlerType = \"start\"
    main_session.pub_ip = get_shell.host_computer.public_ip
    if params.indexOf(\"-a\") != null or params.indexOf(\"--anonymous\") != null then main_session.pub_ip = \"HIDDEN\"
    main_session.loc_ip = get_shell.host_computer.local_ip
    main_session.current_user = active_user
    print(\"Back at starting point.\")

end function

back.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
buffer = {}
buffer.name = \"buffer\"
buffer.args = \"(LEN/ALL)\"
buffer.desc = \"Shows used commands.\"
buffer.full_desc = \"This command will show the last used commands,\\n where (LEN/ALL) is a number of how many commands to show,\\n or \"\"ALL\"\" to list all commands inside the buffer.\"
buffer.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
buffer.run = function(object, args)

    listBuffer(args)

end function

buffer.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
cat = {}
cat.name = \"cat\"
cat.args = \"[PATH]\"
cat.desc = \"Prints the contents of a file.\"
cat.full_desc = \"This command will prints the contents of a file,\\n where [PATH] is the path to the file.\"
cat.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
cat.run = function(object, args)

    read_file(object, args)

end function

cat.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
chgrp = {}
chgrp.name = \"chgrp\"
chgrp.args = \"(-R) [GROUP] [PATH]\"
chgrp.desc = \"Changes the group of a file or directory.\"
chgrp.full_desc = \"This command will change the group of a file or directory where (-R) is recursion,\\n where [GROUP] is the new group of the file or directory,\\n where [PATH] is the path of the file or directory.\"
chgrp.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
chgrp.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    //command: chgrp

    group = args[0]
    pathFile = args[1]
    isRecursive = 0

    if args.len == 3 then
        group = args[1]
        pathFile = args[2]
        isRecursive = 1
    end if

    file = findFile(object, pathFile)
    if file == null then; print(\"chgrp: can't find \" + pathFile); return; end if
    output = file.set_group(group, isRecursive)
    if output then print(output)

end function

chgrp.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
chmodFile = {}
chmodFile.name = \"chmod\"
chmodFile.args = \"(-R) [PERMS] [PATH]\"
chmodFile.desc = \"Chmods a file or directory.\"
chmodFile.full_desc = \"This command will chmod a file or directory where (-R) is recursion,\\n where [PARMS] are the permissions of the file,\\n where [PATH] is the path to the file or directory.\"
chmodFile.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
chmodFile.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    //command: chmod
    permissions = args[0]
    pathFile = args[1]
    isRecursive = 0

    if args.len == 3 then
        permissions = args[1]
        pathFile = args[2]
        isRecursive = 1
    end if

    file = findFile(object, pathFile)
    if file == null then; print(\"chmod: can't find \" + pathFile); return; end if
    output = file.chmod(permissions, isRecursive)
    if output then print(output)

end function

chmodFile.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
chown = {}
chown.name = \"chown\"
chown.args = \"(-R) [OWNER] [PATH]\"
chown.desc = \"Changes the owner of a file or directory.\"
chown.full_desc = \"This command will change the owner of a file or directory where (-R) is recursion,\\n where [OWNER] is the new owner of the file or directory,\\n where [PATH] is the path to the file or directory.\"
chown.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
chown.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    //command: chown
    owner = args[0]
    pathFile = args[1]
    isRecursive = 0

    if args.len == 3 then
        owner = args[1]
        pathFile = args[2]
        isRecursive = 1
    end if

    file = findFile(object, pathFile)
    if file == null then; print(\"chown: can't find \" + pathFile); return; end if
    output = file.set_owner(owner, isRecursive)
    if output then print(output)

end function

chown.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
clear = {}
clear.name = \"clear\"
clear.args = \"[N/A]\"
clear.desc = \"Clears the screen.\"
clear.full_desc = \"This command will clear the screen.\"
clear.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
clear.run = function(object, args)

    ascii_print()

end function

clear.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
compile = {}
compile.name = \"compile\"
compile.args = \"[SRCPATH] [DESTPATH]\"
compile.desc = \"Compiles a program from source.\"
compile.full_desc = \"This command will compile a program from source where [SRCPATH] is the path to the sourcecode,\\n and [DESTPATH] the path of the compiled program.\"
compile.handler_types = [\"start\", \"shell\"]
compile.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    //command: compile
    pathSource = args[0]
    programPath = args[1]

    shell = object
    computer = shell.host_computer
    fileSource = computer.File(pathSource)
    folderDest = computer.File(programPath)

    if fileSource == null then; print(\"compile: can't find \"+ pathSource); return; end if
    if folderDest == null then; print(\"compile: can't find \" + programPath); return; end if
        
    output = shell.build(fileSource.path, folderDest.path)
    if output.len == 0 then
        print(\"compiled successfully.\")
    else
        print(output);
    end if

end function

compile.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
corruptlogs = {}
corruptlogs.name = \"corruptlogs\"
corruptlogs.args = \"[N/A]\"
corruptlogs.desc = \"Corrupts the logfile.\"
corruptlogs.full_desc = \"This command will currupt the logfile completely,\\n and does not leave any log (not even disconnected!).\"
corruptlogs.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
corruptlogs.run = function(object, args)

    if typeof(object) == \"shell\" then fileObj = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then fileObj = object.File(\"/var\")
    if typeof(object) == \"file\" then fileObj = object
    if not findFile(fileObj, \"/var/system.log\") or not findFile(fileObj, \"/var/system.log\").has_permission(\"w\") then
        no_perms = do_style(\"No permissions\", \"red\", \"static\")
        print(no_perms)
        return
    end if
    if typeof(object) == \"shell\" then
        object = object.host_computer
        object.touch(\"/var\", \"system.bac\")
        syslogbak = object.File(\"/var/system.bac\")
        syslogbak.set_content(\"\")

        syslog = object.File(\"/var/system.log\")
        syslog.delete
        syslogbak.move(\"/var\", \"system.log\")

    else if typeof(object) == \"computer\" then
        object.touch(\"/var\", \"system.bac\")
        syslogbak = object.File(\"/var/system.bac\")
        syslogbak.set_content(\"\")

        syslog = object.File(\"/var/system.log\")
        syslog.delete
        syslogbak.move(\"/var\", \"system.log\")

    else if typeof(object) == \"file\" then
        fstab = findFile(object, \"/etc/fstab\")
        fstab.copy(\"/var\", \"system.bac\")

        syslogbak = findFile(object, \"/var/system.bac\")
        syslogbak.set_content(\"\")

        syslog = findFile(object, \"/var/system.log\")
        syslog.delete
        syslogbak.move(\"/var\", \"system.log\")
    end if
    cleared = do_style(\"Logs are corrupted!\", \"green\", \"static\")
    print(cleared)

end function

corruptlogs.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
cp = {}
cp.name = \"cp\"
cp.args = \"[PATH] [DESTPATH]\"
cp.desc = \"Copies a file or directory.\"
cp.full_desc = \"This command will copy a file or directory where [PATH] is the path of the file or directory and,\\n [DESTPATH] the path where the file or directory should be copied to.\"
cp.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
cp.run = function(object, args)

    if args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\") 
    //command: cp
    origFile = args[0]
    destFolder = args[1]
    file = findFile(object, origFile)
    folder = findFile(object, destFolder)
    if not file then; print(\"cp: can't find \" + origFile); return; end if
    if not parent_path(destFolder) then; print(\"cp: can't find \" + parent_path(destFolder)); return; end if
    newName = \"\"
    if not folder then
        //Check if the user wants to put a new name.
        pathParent = parent_path(destFolder)           
        if pathParent == destFolder then			
            newName = destFolder
            destFolder = file.parent.path		
            output = file.copy(destFolder, newName)
            if output and output != 1 then print(output)
            exit
        end if
        folder = findFile(object, pathParent)
        newName = destFolder[destFolder.len - (destFolder.len - pathParent.len):]			
        if newName[0] == \"/\" then
            newName = newName[1:]
        end if
        if not folder then; print(\"cp: can't copy file. \" + parent_path(destFolder) + \" doesn't exist.\"); return; end if
    end if
    if folder then
        //Check if is trying to copy the file on itself. Ignored.
        if parent_path(file.path) != parent_path(folder.path) or file.name != folder.name then
            finalDest = folder.path    
            if(newName.len == 0) then
                newName = file.name
            end if
            if not folder.is_folder then			
                finalDest = parent_path(file.path)
                newName = folder.name
            end if
            output = file.copy(finalDest, newName)
            if output and output != 1 then print(output)
        end if
    end if

end function

cp.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
crack = {}
crack.name = \"crack\"
crack.args = \"[HASH]\"
crack.desc = \"Cracks an MD5 hash.\"
crack.full_desc = \"This command will crack an MD5 hash, where [HASH] is the hash without user.\"
crack.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
crack.run = function(object, args)

    if not args then; self.show_help; return; end if
    //command: decipher
    if not main_session.cryptoLib then; print(\"Error: Missing crypto library\"); return; end if

    GetPassword = function(userPass)
        password = main_session.cryptoLib.decipher(userPass)
        return password
    end function

    password = GetPassword(args[0])
        
    if not password then
        print(\"Can't find password\")
        return
    end if
    print(\"password found! => \" + password)

end function

crack.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
credits = {}
credits.name = \"credits\"
credits.args = \"[N/A]\"
credits.desc = \"Shows everyone that helped with Viper.\"
credits.full_desc = \"This command will show everyone that helped with Viper.\"
credits.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
credits.run = function(object, args)

    string = char(10)
    string = string+\"Maintainer: Volk\"+char(10)
    string = string+\"Viper is created by Volk.\"+char(10)
    string = string+\"My special thanks go to Eraser,\"+char(10)
    string = string+\"for helping me refactor Viper into a more effecient program.\"+char(10)
    print(string)

end function

credits.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function

deepscan = {}
deepscan.name = \"deepscan\"
deepscan.args = \"[IP]\"
deepscan.desc = \"Scans every IP behind a router.\"
deepscan.full_desc = \"This command will scan every IP behind a router where [IP] is the IP,\\n when used inside the network it will scan all IP's inside the network.\"
deepscan.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
deepscan.run = function(object, args)

    if not args or not args.len then; self.show_help; return; end if
    if args.len == 1 then
        ip = args[0]
        if not is_valid_ip(ip) then; print(\"IP \"+ip+\" not found!\"); return; end if
        router = get_router(ip)
        if not router then; print(do_style(\"IP is not a router or public IP!\", \"red\", \"static\")); return; end if
        print(\" \")
        print(do_style(router.local_ip, \"text\").replace(\"\\.\",do_style(\".\", \"title\")))
        ipscan(ip, [])
        print(\" \")
        return
    else if args.len >= 2 then
        fileObject = object.host_computer.File(\"/var\")
        file = findFile(fileObject, args[1])
        if file then
            object.launch(args[1], args[0]+\" deepscan\")
            return
        end if
        print(\"Jump file does not exist!\")
        return
    end if

end function

deepscan.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
delgroup = {}
delgroup.name = \"delgroup\"
delgroup.args = \"[USER] [GROUP]\"
delgroup.desc = \"Removes a user from a group.\"
delgroup.full_desc = \"This command will remove a user to a group where [USER] is the user and [GROUP] the group.\"
delgroup.handler_types = [\"start\", \"shell\", \"computer\"]
delgroup.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: groupdel

    user = args[0]
    group = args[1]

    output = object.create_group(user, group)
    if output == true then; print(\"Group \" + group + \" deleted from user \" + user); return; end if
    if output then; print(output); return; end if
    print(\"Error: the group could not be deleted.\")

end function

delgroup.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
dellib = {}
dellib.name = \"dellib\"
dellib.args = \"[INDEX]\"
dellib.desc = \"Deletes a library from the library list.\"
dellib.full_desc = \"This command will delete a library from the library list where [INDEX] is the library.\"
dellib.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
dellib.run = function(object, args)

    if not args then; self.show_help; return; end if
    for index in args
        if index.split(\"-\").len == 2 then
            for object in range(index.split(\"-\")[0].to_int, index.split(\"-\")[1].to_int)
                main_session.libList.remove(object)
            end for
            continue
        end if
        main_session.libList.remove(index.to_int)
    end for
    globals.main_session.libList = sortMap(main_session.libList)

end function

dellib.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
deltarget = {}
deltarget.name = \"deltarget\"
deltarget.args = \"[INDEX]\"
deltarget.desc = \"Deletes a target from the targets list.\"
deltarget.full_desc = \"This command will delete target from the targets list, where [INDEX] is the index of the target.\"
deltarget.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
deltarget.run = function(object, args)
    
    if not args then
        self.show_help()
        return
    end if

    if args[0].lower() == \"all\" then args = [\"0-1000\"]
    delete_target(\"objectList\", args)

end function

deltarget.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
deluser = {}
deluser.name = \"deluser\"
deluser.args = \"[USER]\"
deluser.desc = \"Deletes a user from the computer.\"
deluser.full_desc = \"This command will delete a user from the computer where [USER] is the user.\"
deluser.handler_types = [\"start\", \"shell\", \"computer\"]
deluser.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: userdel

    output = object.delete_user(args[0], 0)
    if output == true then; print(\"user \" + args[0] + \" deleted.\"); return; end if
    if output then; print(output); return; end if
    print(\"Error: user not deleted.\")

end function

deluser.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
delvar = {}
delvar.name = \"delvar\"
delvar.args = \"[KEY]\"
delvar.desc = \"Removes a variable to the list of variables.\"
delvar.full_desc = \"This command will remove a variable to the list of variabels where [KEY] is the name of the variable.\"
delvar.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
delvar.run = function(object, args)

    if not args then; self.show_help; return; end if
    main_session.vars.remove(args[0])

end function

delvar.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
echo = {}
echo.name = \"echo\"
echo.args = \"[STRING]\"
echo.desc = \"Prints text to the screen.\"
echo.full_desc = \"This command will print text to the screen.\"
echo.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
echo.run = function(object, args)

    string = \"\"
    for word in args
        string = string+word+\" \"
    end for
    print(char(10)+string+char(10))

end function

echo.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
exec = {}
exec.name = \"exec\"
exec.args = \"[PATH]\"
exec.desc = \"Executes a program.\"
exec.full_desc = \"This command will execute a program where [PATH] is the path to the program.\"
exec.handler_types = [\"start\", \"shell\"]
exec.run = function(object, args)

    if not args then; self.show_help; return; end if
    program = args[0]
    params = \"\"
    if args.len >= 2 then
        for arg in args[1:]
            if params == \"\" then
                params = arg
                continue
            end if
            params = params+\" \"+arg
        end for
    end if
    object.launch(program, params)

end function

exec.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
do_exit = {}
do_exit.name = \"exit\"
do_exit.args = \"[N/A]\"
do_exit.desc = \"Exits Viper.\"
do_exit.full_desc = \"This command will exit Viper.\"
do_exit.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
do_exit.run = function(object, args)

    interop = get_custom_object()
    interop.viper = main_session.objectList
    interop.vlibs = main_session.libList
    main_session.exit = true

end function

do_exit.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
exploit = {}
exploit.name = \"exploit\"
exploit.args = \"[IP/LIB] (PORT) [MEM] [VULN] (IP/PASS)\"
exploit.desc = \"Exploits a target library or service.\"
exploit.full_desc = \"This command will exploit a target library or service,\\n where [IP/LIB] is the IP or library to exploit,\\n where (PORT) is the port of the service (not used when exploiting a library),\\n where [MEM] is the memory address,\\n where [VULN] is the vulnerable string,\\n where (IP/PASS) is a local IP for a bounce exploit or PASS to inject a new password.\"
exploit.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
exploit.run = function(_, args)

    if not args or args.len < 3 then; show_help(self.name, self.args, self.full_desc, self.handler_types); return; end if
    usage = \"Example: [IP/Library] [port] [memAddress] [vulnString] (IP/Password)\"
    localIP = \"unknown\"

    if is_valid_ip(args[0]) and args.len > 3 then
        IP = args[0]
        PORT = args[1].to_int
        memAddress = args[2]
        vulnString = args[3]
        extra = \".\"
        if args.len >= 5 then
            extra = args[4]
        end if
        netSession = main_session.MetaxploitLib.net_use(IP, PORT)
        if not netSession then; print(\"Could not connect to port: \"+PORT); return; end if
        object = netSession.dump_lib.overflow(memAddress, vulnString, extra)
        objectType = typeof(object)
        if not object then; print(\"Exploit not found!\"); return; end if
        if objectType == \"shell\" then
            localIP = object.host_computer.local_ip
            IP = object.host_computer.public_ip
            user = userCheck(object.host_computer.File(\"/var\"))
        else if objectType == \"computer\" then
            localIP = object.local_ip
            IP = object.public_ip
            user = userCheck(object.File(\"/var\"))
        else if objectType == \"file\" then
            user = userCheck(object)
            router = get_router(IP)
            if router and not is_lan_ip(IP) then
                if PORT == 0 or PORT == 8080 then
                    localIP = router.local_ip
                    IP = router.public_ip
                else
                    for port in router.used_ports
                        if port.port_number == PORT then
                            localIP = port.get_lan_ip
                            break
                        end if
                    end for
                end if
            else if IP then
                localIP = IP
                ip = main_session.MetaxploitLibPublicIP
            else
                localIP = main_session.MetaxploitLibLocalIP
                ip = main_session.MetaxploitLibPublicIP
            end if
        end if
    else
        library = args[0]
        memAddress = args[1]
        vulnString = args[2]
        extra = \".\"
        if args.len >= 4 then
            extra = args[3]
        end if
        metalib = main_session.MetaxploitLib.load(\"/lib/\"+library)
        if not metalib then; print(\"Could not load library: \"+library); return; end if
        object = metalib.overflow(memAddress, vulnString, extra)
        objectType = typeof(object)
        if not object then; print(\"Exploit not found!\"); return; end if
        if objectType == \"shell\" then
            IP = object.host_computer.public_ip
            localIP = object.host_computer.local_ip
            user = userCheck(object.host_computer.File(\"/var\"))
        else if objectType == \"computer\" then
            IP = object.public_ip
            localIP = object.local_ip
            user = userCheck(object.File(\"/var\"))
        else if objectType == \"file\" then
            IP = main_session.MetaxploitLibPublicIP
            localIP = main_session.MetaxploitLibLocalIP
            user = userCheck(object)
        end if
    end if
    if not object then
        print(\"Object not found!\")
        return
    else if objectType == \"string\" then
        print(object)
        return
    else if objectType == \"number\" then
        return
    end if
    main_session.objectList[main_session.objectList.len] = {\"IP\":IP, \"objectType\":objectType, \"object\":object, \"localIP\":localIP, \"user\":user}

end function

exploit.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
exploitscan = {}
exploitscan.name = \"exploitscan\"
exploitscan.args = \"[LIB/IP] [PORT] (PASS/LANIP)\"
exploitscan.desc = \"This command will scan a library or IP for exploits.\"
exploitscan.full_desc = \"This command will scan a library or IP for exploits,\\n where [LIB/IP] is a library or IP,\\n where [PORT] is the port of a service to attack (this can be skipped when attacking a local library),\\n where (PASS/LANIP) is a password to inject a new password,\\n or local IP of any computer on the network for a bounce attack.\\n it is possible to add a variable called \"\"lib\"\" with a library index, which will be used to scan from.\"
exploitscan.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
exploitscan.run = function(object, args)

    exploit_scan(main_session.handlerType, args)

end function

exploitscan.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
findlib = {}
findlib.name = \"findlib\"
findlib.args = \"[LIB] [VERSION]\"
findlib.desc = \"Scans greyhack for a library.\"
findlib.full_desc = \"This command will scan greyhack for a library where [LIB] is the library,\\n and [VERSION] is the version.\"
findlib.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
findlib.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if args[0] == \"kernel_router\" then
        count = 0
        start = time
        print(\" \")
        print(do_style(\"Searching for library \"+args[0]+\" \"+args[1]+\"...\", \"text\"))
        while true
            if get_shell.host_computer.show_procs.split(\"Map\").len > 1 then
                break
            end if
            count = count+1
            ip = get_random_ip
            if not check_router(ip, args[1]) then continue
            print(\" \")
            print(do_style(\"Library found!\", \"green\", \"static\"))
            print(\"IP containing kernel_router.so \"+args[1]+\" found at ip: \"+ip)
            print(\"Tried \"+count+\" times. Spent \"+str(time - start)+\" seconds.\")
            print(\" \")
            return
            wait(0.01)
        end while
    end if

    count = 0
    start = time
    print(\" \")
    print(do_style(\"Searching for library \"+args[0]+\" \"+args[1]+\"...\", \"text\"))
    while true
        if get_shell.host_computer.show_procs.split(\"Map\").len > 1 then
            break
        end if
        count = count+1
        ip = get_random_ip
        router = get_router(ip)
        if not router then router = get_switch(ip)
        if not router then continue
        if not check_service(router, args[0], args[1]) then continue
        print(\" \")
        print(do_style(\"Library found!\", \"green\", \"static\"))
        print(\"IP containing service \"+args[0]+\" \"+args[1]+\" found at ip: \"+ip)
        print(\"Tried \"+count+\" times. Spent \"+str(time - start)+\" seconds.\")
        print(\" \")
        return
        wait(0.01)
    end while

end function

findlib.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
fs = {}
fs.name = \"fs\"
fs.args = \"[N/A]\"
fs.desc = \"Lists the whole filesystem.\"
fs.full_desc = \"This command will list the whole filesystem.\"
fs.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
fs.run = function(object, args)

    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    FileSystem = {}
    FileSystem.listFiles = function(handle)
        tld = null
        if typeof(handle) == \"file\" then
            tld = FileSystem.file_get_tld(handle)
        else
            print(\"Handle not a file\")
            return null
        end if
        FileSystem.print_contents(tld)
    end function
    FileSystem.check_permissions = function(file)
        if not file then
            print(\"File \" + file + \" does not exist\")
            return null
        end if
        return file
    end function
    FileSystem.file_get_tld = function(handle)
        tld = FileSystem.check_permissions(handle.parent)
        while tld.path != \"/\"
            tld = FileSystem.check_permissions(tld.parent)
        end while
        return tld
    end function
    FileSystem.print_contents = function(file, indent=0, newLine)
        buffer = \"\" * indent
        file_name = do_style(file.name, \"text\")
        if file.is_folder then
            file_name = do_style(file.path, \"light_blue\", \"static\")
        end if
        if file.has_permission(\"r\") and file.has_permission(\"w\") and file.has_permission(\"x\") then
            line = newLine+do_style(buffer+\"\"+file.permissions+\" \"+file.owner+\" \"+file.group+\" \"+file_name, \"green\", \"static\")
        else if file.has_permission(\"r\") or file.has_permission(\"w\") or file.has_permission(\"x\") then
            line = newLine+do_style(buffer+\"\"+file.permissions+\" \"+file.owner+\" \"+file.group+\" \"+file_name, \"yellow\", \"static\")
        else
            line = newLine+do_style(buffer+\"\"+file.permissions+\" \"+file.owner+\" \"+file.group+\" \"+file_name, \"red\", \"static\")
        end if
        print(line)
        if file.is_folder then
            for sub_file in file.get_files
                newLine = \"\"
                FileSystem.print_contents(sub_file, indent+2, newLine)
            end for
            for folder in file.get_folders
                newLine = char(10)
                FileSystem.print_contents(folder, indent+2, newLine)
            end for
        end if
    end function
    print(\" \")
    FileSystem.listFiles(object)
    print()

end function

fs.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
ftp = {}
ftp.name = \"ftp\"
ftp.args = \"[USER@PASSWORD] [IP] (PORT)\"
ftp.desc = \"Connects to a service using ftp.\"
ftp.full_desc = \"This command will connects to a server using ftp where [USER@PASSWORD] is the user and password,\\n where [IP] is the IP of ther server,\\n where (PORT) is an optional port.\"
ftp.handler_types = [\"start\", \"shell\"]
ftp.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    
    //Command: ssh
    credentials = args[0].split(\"@\")
    user = credentials[0]
    password = credentials[1]

    port = 21
    // params is a list of strings, so you have to convert it to integer, which is what connect_service accepts.
    if args.len == 3 then port = args[2].to_int
    if typeof(port) != \"number\" then; print(\"Invalid port: \" + port); return; end if
    print(\"Connecting...\")

    remoteFtp = object.connect_service(args[1], port, user, password, \"ftp\")
    if typeof(remoteFtp) == \"string\" then; print(remoteFtp); return; end if
    if remoteFtp then
        print(\"Connected!\")
        main_session.pub_ip = remoteShell.host_computer.public_ip
        main_session.handlerType = typeof(remoteShell)
        main_session.object = remoteShell
        main_session.loc_ip = remoteShell.host_computer.local_ip
        main_session.current_user = user
    else 
        print(\"connection failed\")
    end if

end function

ftp.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
shellGet = {}
shellGet.name = \"get\"
shellGet.args = \"[REMPATH] [DESTPATH]\"
shellGet.desc = \"Downloads a file.\"
shellGet.full_desc = \"This command will download a file where [REMPATH] is the path to the file or directory, and [DESTPATH] is the path to the directory to put the file.\"
shellGet.handler_types = [\"start\", \"shell\"]
shellGet.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then
        filePath = args[0]
        hostPath = args[1]
        if filePath == \"\" or hostPath == \"\" then; self.show_help; return; end if
        err = object.scp(filePath, hostPath, get_shell)
    else if typeof(object) == \"ftpshell\" then
        filePath = args[0]
        hostPath = args[1]
        err = object.put(filePath, hostPath, get_shell)
    end if

end function

shellGet.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
getlib = {}
getlib.name = \"getlib\"
getlib.args = \"[PATH] [JUMPFILE]\"
getlib.desc = \"Imports a library.\"
getlib.full_desc = \"This command will import a library where [PATH] is the path to the library,\\n and [JUMPFILE] is the path to the jumpfile.\"
getlib.handler_types = [\"start\", \"shell\"]
getlib.run = function(object, args)
    cargo = get_custom_object

    if main_session.handlerType == \"start\" then
        if not args or args.len < 1 then; self.show_help; return; end if
        newObject = include_lib(args[0])
        
        if not newObject then; print(\"Unable to load library!\"); return; end if
        
        if typeof(newObject) != \"MetaxploitLib\" and typeof(newObject) != \"cryptoLib\" and typeof(newObject) != \"aptclientLib\" then
            print(\"Library \"+typeof(newObject)+\" unable to load!\")
            return
        end if
        
        libVersion = \"unknown\"
        if main_session.MetaxploitLibLocalIP+main_session.MetaxploitLibPublicIP == object.host_computer.local_ip+object.host_computer.public_ip then libVersion = main_session.MetaxploitLib.load(args[0]).version
        if typeof(newObject) == \"MetaxploitLib\" then
            libVersion = newObject.load(args[0]).version
        else
            for library in main_session.libList
                if typeof(library[\"value\"].lib) == \"MetaxploitLib\" and library[\"value\"].publicIP == object.host_computer.public_ip and library[\"value\"].localIP == object.host_computer.local_ip then
                    libVersion = library[\"value\"].lib.load(args[0]).version
                end if 
            end for
        end if

        main_session.libList[main_session.libList.len] = {\"lib\":newObject, \"publicIP\":object.host_computer.public_ip, \"localIP\":object.host_computer.local_ip, \"version\":libVersion, \"used\":0}
        print(\"Library \"+typeof(newObject).lower.replace(\"lib\",\"\")+\" imported!\")
        return
    end if

    if not args or args.len < 2 then; self.show_help; return; end if
    fileObject = object.host_computer.File(\"/var\")
    file = findFile(fileObject, args[1])
    if file then
        clearInterface(cargo)
        object.launch(args[1], args[0])
        if hasIndex(cargo, \"glib\") then
            
            if not verifyObject(@cargo.glib) then
                print(\"AV detected injection!\")
                clearInterface(cargo)
                return
            end if

            newObject = cargo.glib
            clearInterface(cargo)
        else
            print(\"Jump file corrupted!\")
            clearInterface(cargo)
            return
        end if
        
        if not newObject then; print(\"Unable to load library!\"); return; end if
        
        if typeof(newObject) != \"MetaxploitLib\" and typeof(newObject) != \"cryptoLib\" and typeof(newObject) != \"aptclientLib\" then
            print(\"Library \"+typeof(newObject)+\" unable to load!\")
            return
        end if

        libVersion = \"unknown\"
        if main_session.MetaxploitLibLocalIP+main_session.MetaxploitLibPublicIP == object.host_computer.local_ip+object.host_computer.public_ip then libVersion = main_session.MetaxploitLib.load(args[0]).version 
        if typeof(newObject) == \"MetaxploitLib\" then
            libVersion = newObject.load(args[0]).version
        else
            for library in main_session.libList
                if typeof(library[\"value\"].lib) == \"MetaxploitLib\" and library[\"value\"].publicIP == object.host_computer.public_ip and library[\"value\"].localIP == object.host_computer.local_ip then
                    libVersion = library[\"value\"].lib.load(args[0]).version
                end if 
            end for
        end if
    
        main_session.libList[main_session.libList.len] = {\"lib\":newObject, \"publicIP\":object.host_computer.public_ip, \"localIP\":object.host_computer.local_ip, \"version\":libVersion, \"used\":0}
        print(\"Library \"+typeof(newObject).lower.replace(\"lib\",\"\")+\" imported!\")
        return
    end if
    print(\"Jump file does not exist!\")
    return

end function

getlib.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
getviper = {}
getviper.name = \"getviper\"
getviper.args = \"[PATH] (ARGS)\"
getviper.desc = \"Launches another instance of Viper.\"
getviper.full_desc = \"This command will launch another instance of Viper and will get the objects and imports from the other instance,\\n where [PATH] is the path to the new instance of Viper,\\n where (ARGS) is any optional arguments.\"
getviper.handler_types = [\"start\", \"shell\"]
getviper.run = function(object, args)

    if not args then; self.show_help; return; end if
    argument = \"\"
    if args.len >= 2 then argument = args[1]
    viperPath = object.host_computer.File(args[0])
    if not viperPath then; print(\"Viper not found!\"); return; end if
    wait(1)
    cargo = get_custom_object
    clearInterface(cargo)
    object.launch(args[0], argument)
    if hasIndex(cargo, \"viper\") then
        for index in @cargo.viper

            if not verifyObject(@index.value.object) then // first verify index.value before index.value.object, make recusrive function to check all
                print(\"AV detected injection!\")
                clearInterface(cargo)
                return
            end if
            
            main_session.objectList[main_session.objectList.len] = index.value
        end for
        print(\"Objects imported!\")
    else
        print(\"Viper currupted!\")
    end if

    if hasIndex(cargo, \"vlibs\") then
        for index in @cargo.vlibs

            if not verifyObject(@index.value.lib) then
                print(\"AV detected injection!\")
                clearInterface(cargo)
                return
            end if

            index.value[\"used\"] = 0
            main_session.libList[main_session.libList.len] = index.value
        end for
        print(\"Libraries imported!\")
    else
        print(\"Viper currupted!\")
    end if
    clearInterface(cargo)

end function

getviper.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
gpg = {}
gpg.name = \"gpg\"
gpg.args = \"[-e/-d] [KEY] [PATH/STRING]\"
gpg.desc = \"Encrypts/decrypts a string or file.\"
gpg.full_desc = \"This command will encrypt or decrypt a string or file where [-e/-d] is wether to encrypt or decrypt,\\n where [KEY] is a 16 character long string,\\n where [PATH/STRING] is the path to a file or string to encrypt/decrypt.\"
gpg.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
gpg.run = function(object, args)

    if not args or args.len < 3 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    if args[1].len != 16 then; print(\"Error: Key must be 16 characters long.\"); return; end if
    if args[0] == \"-e\" then type = \"encrypt\"
    if args[0] == \"-d\" then type = \"decrypt\"
    key = args[1]
    encString = args[2]
    file = findFile(object, args[2])

    if file != null then
        encString = file.get_content
    end if

    r = AES128(type, key, encString)

    if typeof(r) == \"null\" then r = \"Error\"
    print(\"-----BEGIN GPG MESSAGE-----\")
    print(r)
    print(\"-----END GPG MESSAGE-----\")

end function

gpg.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
grab = {}
grab.name = \"grab\"
grab.args = \"[BANK/MAIL/ALL]\"
grab.desc = \"Grabs all banks and emails.\"
grab.full_desc = \"This command will grab all banks and emails where [BANK/MAIL/ALL] is what to grab.\"
grab.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
grab.run = function(object, args)

    if not args or args.len != 1 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")

    home = findFile(object, \"/home\")

    if not home then
        print(\"/home does not exist!\")
        return
    end if

    print(\" \")
    for folder in home.get_folders
        if args[0].lower == \"bank\" or args[0].lower == \"all\" then
            for config in folder.get_folders
                for file in config.get_files
                    if file.name == \"Bank.txt\" then print(file.get_content)
                end for
            end for
        end if
        if args[0].lower == \"email\" or args[0].lower == \"mail\" or args[0].lower == \"all\" then
            for config in folder.get_folders
                for file in config.get_files
                    if file.name == \"Mail.txt\" then print(file.get_content)
                end for
            end for
        end if
        if args[0].lower != \"bank\" and args[0].lower != \"mail\" and args[0].lower != \"email\" and args[0].lower != \"all\" then
            self.show_help
            return
        end if
    end for
    print(\" \")

end function

grab.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
getGroups = {}
getGroups.name = \"groups\"
getGroups.args = \"[USER]\"
getGroups.desc = \"Shows the groups of a user.\"
getGroups.full_desc = \"This command will show all the groups a user is part of,\\n where [USER] is the user.\"
getGroups.handler_types = [\"start\", \"shell\", \"computer\"]
getGroups.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: groups
    user = args[0]
    output = object.groups(user)
    if not output then; self.show_help; return; end if
    print(output)

end function

getGroups.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
help = {}
help.name = \"help\"
help.args = \"[COMMAND]\"
help.desc = \"Displays the help page.\"
help.full_desc = \"This command will display the help pages. \\nWhere [COMMAND] is a command that you would like a detailed discription about.\"
help.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
help.run = function(object, args)

    if args and args[0] != \"\" then
        if commands.hasIndex(args[0]) then
            commands[args[0]].show_help
            return
        else
            print(\"Command: \"+args[0]+\" not found!\")
            return
        end if
    else
        string = do_style(\"COMMAND\", \"title\")+\" \"+do_style(\"ARGUMENTS\", \"title\")+\" \"+do_style(\"DESCRIPTION\", \"title\")+\"\\n\"+do_style(\"-------\", \"text\")+\" \"+do_style(\"---------\", \"text\")+\" \"+do_style(\"-----------\", \"text\")+\"\\n\"
        for command in commands
            if command.value.handler_types.indexOf(main_session.handlerType) == null then
                string = string+do_style(command.value.name, \"red\", \"static\")+\" \"+do_style(command.value.args.replace(\" \",\"|\"), \"red\", \"static\")+\" \"+do_style(command.value.desc.replace(\" \",\"|\"), \"text\")+\"\\n\"
                continue
            end if
            string = string+do_style(command.value.name, \"arg\")+\" \"+do_style(command.value.args.replace(\" \",\"|\"), \"arg\")+\" \"+do_style(command.value.desc.replace(\" \",\"|\"), \"text\")+\"\\n\"
        end for

        print(\"\\n\"+format_columns(string).replace(\"\\|\",\" \")+\"\\n\")
    end if

end function

help.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function

iwlist = {}
iwlist.name = \"iwlist\"
iwlist.args = \"[NETDEVICE]\"
iwlist.desc = \"Shows available networks.\"
iwlist.full_desc = \"This command will show all available networks, where [NETDEVICE] is the network card.\"
iwlist.handler_types = [\"start\", \"shell\", \"computer\"]
iwlist.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: iwlist
    devices = object.network_devices
    if devices == null or devices.indexOf(args[0]) == null then; print(\"iwlist: Network device not found\"); return; end if
    if args[0].indexOf(\"eth\") != null then; print(\"iwlist: ethernet cards not supported for this command\"); return; end if
    networks = object.wifi_networks(args[0])

    info = \"BSSID PWR ESSID\"
    for network in networks
        info = info + \"\\n\" + network
    end for
    print(format_columns(info))

end function

iwlist.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
jump = {}
jump.name = \"jump\"
jump.args = \"[PATH] (NAME)\"
jump.desc = \"Creates a jump file.\"
jump.full_desc = \"This command will create a jumpfile which is used in other commands.\\n[PATH] is the directory the jumpfile should be created in,\\n and (NAME) should be the name of the jumpfile.\"
jump.handler_types = [\"start\", \"shell\"]
jump.run = function(object, args)

    if not args then; self.show_help; return; end if
    jumpName = \"jumpfile\"
    if args.len >= 2 then jumpName = args[1]
    pc = object.host_computer
    file = pc.File(args[0])
    if not file or not file.is_folder or not file.has_permission(\"w\") then; print(\"Error, check if folder exists and has write perms!\"); return; end if

    maker = pc.touch(args[0], jumpName+\".src\")
    if typeof(maker) == \"string\" then; print(maker); return; end if
    file = pc.File(args[0]+\"/\"+jumpName+\".src\")
    write.run(object, [\"interop = get_custom_object()\"+char(10), \">\", file.path])
    write.run(object, [\"user = \"\"user\"\"\"+char(10), \">>\", file.path])
    write.run(object, [\"pass = \"\"pass\"\"\"+char(10), \">>\", file.path])
    write.run(object, [\"if params.len >= 2 then\"+char(10), \">>\", file.path])
    write.run(object, [\"user = params[0]\"+char(10), \">>\", file.path])
    write.run(object, [\"pass = params[1]\"+char(10), \">>\", file.path])
    write.run(object, [\"else if params.len == 1 then\"+char(10), \">>\", file.path])
    write.run(object, [\"user = params[0]\"+char(10), \">>\", file.path])
    write.run(object, [\"end if\"+char(10), \">>\", file.path])

    write.run(object, [\"ipscan = function(ip, routers)\"+char(10), \">>\", file.path])
    write.run(object, [\"router = get_router(ip)\"+char(10), \">>\", file.path])
    write.run(object, [\"for localIP in router.devices_lan_ip\"+char(10), \">>\", file.path])
    write.run(object, [\"if routers.indexOf(localIP) != null then continue\"+char(10), \">>\", file.path])
    write.run(object, [\"print(\"\"<color=#cccccc>\"\"+localIP)\"+char(10), \">>\", file.path])
    write.run(object, [\"routers.push(router.local_ip)\"+char(10), \">>\", file.path])
    write.run(object, [\"if get_router(localIP) then ipscan(localIP, routers)\"+char(10), \">>\", file.path])
    write.run(object, [\"end for\"+char(10), \">>\", file.path])
    write.run(object, [\"end function\"+char(10), \">>\", file.path])
    
    write.run(object, [\"if params.len >= 2 and pass == \"\"deepscan\"\" then\"+char(10), \">>\", file.path])
    write.run(object, [\"ip = user\"+char(10), \">>\", file.path])
    write.run(object, [\"if not is_valid_ip(ip) then; print(\"\"IP \"\"+ip+\"\" not found!\"\"); return; end if\"+char(10), \">>\", file.path])
    write.run(object, [\"print(\"\" \"\")\"+char(10), \">>\", file.path])
    write.run(object, [\"print(\"\"<color=#cccccc>\"\"+get_router(ip).local_ip)\"+char(10), \">>\", file.path])
    write.run(object, [\"ipscan(ip, [])\"+char(10), \">>\", file.path])
    write.run(object, [\"print(\"\" \"\")\"+char(10), \">>\", file.path])
    write.run(object, [\"end if\"+char(10), \">>\", file.path])


    write.run(object, [\"interop.gshell = get_shell(user, pass)\"+char(10), \">>\", file.path])
    write.run(object, [\"interop.gcurrentUser = active_user\"+char(10), \">>\", file.path])
    write.run(object, [\"interop.glib = include_lib(user)\"+char(10), \">>\", file.path])
    write.run(object, [\"interop.gcryptTools = include_lib(user)\"+char(10), \">>\", file.path])

    builder = object.build(file.path, args[0], false)
    if builder.len then; print(builder); return; end if
    //file.delete
    file.set_content(\"\")
    // object.launch(args[0]+\"/\"+jumpName)
    // return get_custom_object.gcurrentUser

    //output that needs to be added in another function
    // print(get_custom_object.gshell)
    // print(get_custom_object.gcurrentUser)
    // print(get_custom_object.gmetaxploit)
    // print(get_custom_object.gcryptTools)

end function

jump.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
kill = {}
kill.name = \"kill\"
kill.args = \"[PID/ALL]\"
kill.desc = \"Kills a process.\"
kill.full_desc = \"This command will kill a process where [PID] is the id of the process.\\nMultiple process ids can be given or all for closing all.\"
kill.handler_types = [\"start\", \"shell\", \"computer\"]
kill.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer

    if args[0].lower == \"all\" then
        for proc in object.show_procs.split(char(10))
            PID = proc.split(\" \")[1].to_int
            output = object.close_program(PID)
            if output == true then
                print(\"Process \" + PID + \" closed\")
                continue
            else if output then
                print(output)
                continue
            end if
        end for
        return
    end if

    for proc in args
        PID = proc.to_int
        if typeof(PID) != \"number\" then
            print(\"The PID must be a number\\n\" + self.show_help)
            continue
        end if

        output = object.close_program(PID)
        if output == true then
            print(\"Process \" + PID + \" closed\")
            continue
        else if output then
            print(output)
            continue
        end if
        print(\"Process \" + PID + \" not found\")
    end for

end function

kill.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
libs = {}
libs.name = \"libs\"
libs.args = \"[N/A]\"
libs.desc = \"Shows all imported libraries.\"
libs.full_desc = \"This command will show all imported libraries.\"
libs.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
libs.run = function(object, args)

    info = do_style(\"INDEX\"+\" \"+\"LIBRARY\"+\" \"+\"PUBLICIP\"+\" \"+\"LOCALIP\"+\" \"+\"VERSION\", \"title\")+\"\\n\"+do_style(\"-----\"+\" \"+\"-------\"+\" \"+\"--------\"+\" \"+\"-------\"+\" \"+\"-------\", \"text\")
    for index in main_session.libList
        line = do_style(index.key+\" \"+typeof(index[\"value\"].lib).lower.replace(\"lib\",\"\")+\" \"+index[\"value\"].publicIP+\" \"+index[\"value\"].localIP+\" \"+index[\"value\"].version, \"text\")
        if index[\"value\"].used then line = do_style(index.key+\" \"+typeof(index[\"value\"].lib).lower.replace(\"lib\",\"\")+\" \"+index[\"value\"].publicIP+\" \"+index[\"value\"].localIP+\" \"+index[\"value\"].version, \"green\", \"static\")
        info = info+\"\\n\"+line
    end for
    print(\"\\n\"+format_columns(info)+\"\\n\")

end function

libs.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
load_theme = {}
load_theme.name = \"load-theme\"
load_theme.args = \"[N/A]\"
load_theme.desc = \"Reloads theme.\"
load_theme.full_desc = \"This command will load the theme from the settings file.\"
load_theme.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
load_theme.run = function(_, _)

    loadSettings(\"theme\")
    txt = do_style(\"Theme reloaded!\", \"green\", \"static\")
    print(char(10)+txt+char(10))

end function

load_theme.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
loop = {}
loop.name = \"loop\"
loop.args = \"[IP] [PORT] [MEM] [VULN] [IP/PASS]\"
loop.desc = \"Loops over an exploit, open Map.exe to stop.\"
loop.full_desc = \"This command will loop over an exploit, where [IP] is the target IP,\\n where [PORT] is the target port,\\n where [MEM] is the memory address,\\n where [VULN] is the vulnerable string,\\n where [IP/PASS] is the IP for a bounce attack or a new password to inject.\"
loop.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
loop.run = function(object, args)

    if not args or args.len < 4 then; self.show_help; return; end if
    object = null
    IP = args[0]
    PORT = args[1].to_int
    memAddress = args[2]
    vulnString = args[3]
    extra = \".\"
    mapCheck = 1
    netSession = main_session.MetaxploitLib.net_use(IP, PORT)
    if args.len >= 5 then extra = args[4]
    while mapCheck < 2 and object == null
        mapCheck = get_shell.host_computer.show_procs.split(\"Map\").len
        if not netSession then; print(\"Could not connect to port: \"+PORT); return; end if
        object = netSession.dump_lib.overflow(memAddress, vulnString, extra)
        objectType = typeof(object)
        if objectType == \"shell\" then
            localIP = object.host_computer.local_ip
            user = userCheck(object.host_computer.File(\"/var\"))
        else if objectType == \"computer\" then
            localIP = object.local_ip
            user = userCheck(object.File(\"/var\"))
        else if objectType == \"file\" then
            user = userCheck(object)
            router = get_router(IP)
            if router and not is_lan_ip(IP) then
                if PORT == 0 or PORT == 8080 then
                    localIP = router.local_ip
                    ip = router.public_ip
                else
                    for port in router.used_ports
                        if port.port_number == PORT then
                            localIP = port.get_lan_ip
                            break
                        end if
                    end for
                end if
            else if IP then
                localIP = IP
                ip = main_session.MetaxploitLibPublicIP
            else
                localIP = main_session.MetaxploitLibLocalIP
                ip = main_session.MetaxploitLibPublicIP
            end if
        end if
        wait(0.01)
    end while
    if object == null or objectType == \"number\" then return
    main_session.objectList[main_session.objectList.len] = {\"IP\":IP, \"objectType\":objectType, \"object\":object, \"localIP\":localIP, \"user\":user}

end function

loop.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
ls = {}
ls.name = \"ls\"
ls.args = \"[PATH]\"
ls.desc = \"Lists files inside a directory.\"
ls.full_desc = \"This command will list all the files inside a directory,\\n where [PATH] is the path to the directory.\"
ls.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
ls.run = function(object, args)

    list_files(object, args)

end function

ls.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
md5_hash = {}
md5_hash.name = \"md5\"
md5_hash.args = \"[STRING]\"
md5_hash.desc = \"Hashes a string with the md5 hash algorithm.\"
md5_hash.full_desc = \"This command will hash a string with the md5 hash algorithm where [STRING] is the string to hash.\"
md5_hash.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
md5_hash.run = function(object, args)

    if not args then; self.show_help; return; end if
    print(char(10)+md5(args[0])+char(10))

end function

md5_hash.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
mkdir = {}
mkdir.name = \"mkdir\"
mkdir.args = \"[PATH]\"
mkdir.desc = \"Creates a directory.\"
mkdir.full_desc = \"This command will create a directory where [PATH] is the path of the directory.\"
mkdir.handler_types = [\"start\", \"shell\", \"computer\"]
mkdir.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: mkdir
    for pathFile in args
        computer = object
        if pathFile == \"\" then
            self.show_help()
            return
        end if

        pathParent = parent_path(pathFile)
        existFile = computer.File(pathFile)            
        if pathParent == pathFile then
            pathParent = current_path
        end if
        
        parent = computer.File(pathParent)
        if parent == null then
            print(\"mkdir: \" + pathParent + \" not found\")
        else if existFile != null then
            print(\"mkdir: \" + existFile.path + \" file exists\")
        else if not parent.has_permission(\"w\") then
            print(\"mkdir: permission denied\")
        else
            arrayPath = pathFile.split(\"/\")
            output = computer.create_folder(parent.path, arrayPath[arrayPath.len - 1])
            if output != null and output != 1 then
                print(output)
            end if 
        end if
    end for

end function

mkdir.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
msfconsole = {}
msfconsole.name = \"msfconsole\"
msfconsole.args = \"[N/A]\"
msfconsole.desc = \"Starts a listiner for incomming rshells.\"
msfconsole.full_desc = \"This command will start an rshell listiner.\"
msfconsole.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
msfconsole.run = function(object, args)

    if not main_session.MetaxploitLib then
        print(\"metaxploit.so not found!\")
        return
    end if

    getNetcatConnections()
    input = null
    while input != \"exit\"
        input = user_input(\"<u>meterpreter</u> > \")

        //main_session.netcatList
        if input.split(\" \")[0] == \"get\" or input == \"refresh\" then
            getNetcatConnections()
        else if input.split(\" \")[0] == \"list\" or input.split(\" \")[0] == \"sessions\" then
            output = \"\\n\"
            for netcatItem in main_session.netcatList
                // print(GREEN+\"<b>Shell (\"+netcatItem.key+\")</b>\")
                color = do_style(netcatItem.value[\"user\"], \"logo\", \"static\")
                if netcatItem.value[\"user\"] == \"root\" then color = do_style(netcatItem.value[\"user\"], \"logo\", \"static\")
                // print(YELLOW+\"User: \"+color+netcatItem.value[\"user\"])
                // print(YELLOW+\"Public IP: \"+LIGHT_BLUE+netcatItem.value[\"IP\"])
                // print(YELLOW+\"Local IP: \"+ORANGE+netcatItem.value[\"localIP\"])
                output = output+do_style(\"(\"+netcatItem.key+\")\", \"logo\", \"static\")+do_style(\" [*] \", \"arg\")+do_style(netcatItem.value[\"localIP\"]+\" Connected from \"+netcatItem.value[\"IP\"]+\" as \", \"logo\", \"static\")+color+\"\\n\"
            end for
            print(format_columns(output))
            print(\" \")
        else if input.split(\" \")[0] == \"use\" then
            if input.split(\" \").len() <= 1 then continue
            index = input.split(\" \")[1].to_int
            if not main_session.netcatList.hasIndex(index) then
                print(\"Index not found!\")
            else
                main_session.object = main_session.netcatList[index].object
                main_session.handlerType = typeof(main_session.netcatList[index].object)
                main_session.pub_ip = main_session.netcatList[index].IP
                main_session.loc_ip = main_session.netcatList[index].localIP
                main_session.current_user = main_session.netcatList[index].user
                break
            end if

        else if input.split(\" \")[0] == \"loop\" or input.split(\" \")[0] == \"listen\" or input.split(\" \")[0] == \"run\" or input.split(\" \")[0] == \"start\" then
            print(\"execute the map program to exit\")
            print(do_style(\"Listining for connections on \"+main_session.MetaxploitLibPublicIP+\"...\", \"arg\")+\"\\n\")
            listLen = main_session.netcatList.len
            while true
                getNetcatConnections(false)
                if main_session.netcatList.len > listLen then
                    listLen = main_session.netcatList.len
                    line = do_style(\"[*] \", \"arg\")+do_style(main_session.netcatList[main_session.netcatList.len-1].localIP+\" Connected from \"+main_session.netcatList[main_session.netcatList.len-1].IP+\" as \"+main_session.netcatList[main_session.netcatList.len-1].user, \"logo\", \"static\")
                    print(line)
                end if
                if get_shell.host_computer.show_procs.split(\"Map\").len > 1 then
                    break
                end if
            end while
        else if input.split(\" \")[0] == \"clear\" then
            clear_screen
        else if input.split(\" \")[0] == \"help\" then
            helpPage = {
                \"help\":{\"arguments\":\"N/A\", \"description\":\"Displays the help page.\"},
                \"clear\":{\"arguments\":\"N/A\", \"description\":\"Clears the screen.\"},
                \"get/refresh\":{\"arguments\":\"N/A\", \"description\":\"Updates connected shells list.\"},
                \"list/sessions\":{\"arguments\":\"N/A\", \"description\":\"Shows a list of connected shells.\"},
                \"loop/listen/run/start\":{\"arguments\":\"N/A\", \"description\":\"Loop that updates connected shells list.\"},
                \"use\":{\"arguments\":\"[INDEX]\", \"description\":\"Uses an index from the list.\"},
                \"exit\":{\"arguments\":\"N/A\", \"description\":\"Exits the msfconsole.\"},
            }
            str = do_style(\"COMMAND ARGUMENTS DESCRIPTION\", \"title\")+\"\\n\"
            str = str+do_style(\"------- --------- -----------\", \"text\")+\"\\n\"
            print(\" \")
            for line in helpPage
                str = str+do_style(line.key+\" \"+line.value[\"arguments\"]+\" \"+line.value[\"description\"].replace(\" \",\"|\"), \"text\")+\"\\n\"
            end for
            print(format_columns(str).replace(\"\\|\",\" \"))
            print(\" \")
        else if input != \"exit\" then
            print(\"Command \"+input+\" not found! Type help for help.\")
        end if
        wait(0.01)
    end while

end function

msfconsole.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
msfvenom = {}
msfvenom.name = \"msfvenom\"
msfvenom.args = \"[IP] [PORT] [PROC]\"
msfvenom.desc = \"Starts a reverse shell.\"
msfvenom.full_desc = \"This command will start a reverse shell on the target,\\n where [IP] is the IP of the rshell server,\\n where [PORT] is the port of the rshell server,\\n where [PROC] is the process's name.\"
msfvenom.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
msfvenom.run = function(object, args)

    if not args or args.len != 3 then; self.show_help; return; end if
    if not main_session.MetaxploitLib then
        print(\"metaxploit.so not found!\")
        return
    end if

    ip = args[0]
    port = args[1].to_int
    procName = args[2]
    if typeof(port) != \"number\" then; self.show_help; return; end if

    main_session.MetaxploitLib.rshell_client(ip, port, procName)
    line1 = \"\\n\"+\"rshell started at \"+main_session.MetaxploitLibPublicIP+\" on \"+main_session.MetaxploitLibLocalIP+\" as \"+procName+\"\\n\"
    print(line1)
    print(\"Connected to server \"+ip+\" on port \"+port)

end function

msfvenom.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
mv = {}
mv.name = \"mv\"
mv.args = \"[PATH] [DESTPATH]\"
mv.desc = \"Moves a file or directory.\"
mv.full_desc = \"This command will move a file or directory where [PATH] is the path of the file or directory and,\\n [DESTPATH] the path where the file or directory should be moved to.\"
mv.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
mv.run = function(object, args)

    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")   
    //command: mv
    if not args or args.len != 2 then
        self.show_help
    else
        origFile = args[0]
        destFolder = args[1]
        file = findFile(object, origFile)
        if file == null then
            print(\"mv: can't find \" + origFile)
        else
            newName = \"\"
            folder = findFile(object, destFolder)
            if folder == null then
                //Check if the user wants to put a new name.
                pathParent = parent_path(destFolder)    
                if pathParent == destFolder then			
                    newName = destFolder
                    destFolder = file.parent.path
                    file.move(destFolder, newName)
                else
                    folder = findFile(object, pathParent)
                    newName = destFolder[destFolder.len - (destFolder.len - pathParent.len):]			
                    if newName[0] == \"/\" then
                        newName = newName[1:]
                        file.move(pathParent, newName)
                    end if
                    if folder == null then				
                        print(\"mv: can't copy file. \" + destFolder + \" doesn't exist.\")
                    end if			
                end if
            else if folder != null then        
                //Check if is trying to copy the file on itself. Ignored.
                if parent_path(file.path) != parent_path(folder.path) or file.name != folder.name then
                    finalDest = folder.path
                    if(newName.len == 0) then
                        newName = file.name
                    end if
                    if not folder.is_folder then			
                        finalDest = parent_path(file.path)
                        newName = folder.name
                    end if
                    if parent_path(file.path) == parent_path(folder.path) and newName != file.name then
                        file.rename(newName)
                    else
                        file.move(finalDest, newName)
                    end if
                end if
            end if
        end if
    end if

end function

mv.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
nmap = {}
nmap.name = \"nmap\"
nmap.args = \"[IP/RANDOM]\"
nmap.desc = \"Scans a network for open ports.\"
nmap.full_desc = \"Scans a network for open ports where [IP/RANDOM] is the IP or a random IP to scan.\"
nmap.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
nmap.run = function(object, args)

    nmap_scan(args)

end function

nmap.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function

nsLookup = {}
nsLookup.name = \"nslookup\"
nsLookup.args = \"[DOMAIN]\"
nsLookup.desc = \"Returns the IP of a domain.\"
nsLookup.full_desc = \"This command will return the IP of a domain where [DOMAIN] is the domain.\"
nsLookup.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
nsLookup.run = function(object, args)

    if not args then; show_help(\"nslookup\", self.args, self.full_desc, self.handler_types); return; end if
    nslookup_info = do_style(\"IP\", \"title\")+do_style(\": \"+nslookup(args[0]), \"text\")
    print(\"\\n\"+nslookup_info+\"\\n\")

end function

nsLookup.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
passwd = {}
passwd.name = \"passwd\"
passwd.args = \"[USER] [PASSWORD]\"
passwd.desc = \"Changes the password of a user.\"
passwd.full_desc = \"This command will change the password of a user where [USER] is the user,\\n and [PASSWORD] is the new password.\"
passwd.handler_types = [\"start\", \"shell\", \"computer\"]
passwd.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: passwd

    inputMsg = \"Changing password for user \" + args[0]
    inputPass = args[1]

    print(inputMsg)
    output = object.change_password(args[0], inputPass)
    if output == true then; print(\"password modified OK\"); return; end if
    if output then; print(output); return; end if
    print(\"Error: password not modified\")

end function

passwd.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
ps = {}
ps.name = \"ps\"
ps.args = \"[N/A]\"
ps.desc = \"Shows all running processes on a computer.\"
ps.full_desc = \"This command will show all running processes on a computer.\"
ps.handler_types = [\"start\", \"shell\", \"computer\"]
ps.run = function(object, args)

    if typeof(object) == \"shell\" then object = object.host_computer
    info = \"\"
    procs = object.show_procs.split(\"\\n\")
    for proc in procs
        if proc == procs[0] then
            info=info+do_style(proc, \"title\")+char(10)+do_style(\"---- --- --- --- -------\", \"text\")+char(10)
            continue
        end if
        info=info+do_style(proc, \"text\")+char(10)
    end for
    print(char(10)+format_columns(info)+char(10))

end function

ps.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
shellPut = {}
shellPut.name = \"put\"
shellPut.args = \"[HOSTPATH] [DESPATH]\"
shellPut.desc = \"Uploads a file.\"
shellPut.full_desc = \"This command will upload a file where [HOSTPATH] is the path to the file or directory, and [DESTPATH] is the path to the directory to put the file.\"
shellPut.handler_types = [\"start\", \"shell\"]
shellPut.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then
        hostPath = args[0]
        filePath = args[1]
        if filePath == \"\" or hostPath == \"\" then; self.show_help; return; end if
        err = get_shell.scp(hostPath, filePath, object)
    else if typeof(object) == \"ftpshell\" then
        filePath = args[0]
        hostPath = args[1]
        err = get_shell.put(hostPath, filePath, object)
    end if

end function

shellPut.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
returnStart = {}
returnStart.name = \"return\"
returnStart.args = \"[N/A]\"
returnStart.desc = \"Returns to the starting point.\"
returnStart.full_desc = \"This command will return starting point.\"
returnStart.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
returnStart.run = function(object, _)

    main_session.object = get_shell
    main_session.handlerType = \"start\"
    main_session.pub_ip = get_shell.host_computer.public_ip
    main_session.loc_ip = get_shell.host_computer.local_ip
    main_session.current_user = active_user
    print(\"Back at starting point.\")

end function

returnStart.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
rm = {}
rm.name = \"rm\"
rm.args = \"[PATH]\"
rm.desc = \"Removes a file or directory.\"
rm.full_desc = \"This command will remove a file or directory where [PATH] is the path to the file or directory.\"
rm.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
rm.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    //command: rm
    isRecursive = 0
    if args[0] == \"-r\" then
        if args.len == 1 then; self.show_help; return; end if
        isRecursive = 1
        args = args[1:]
    end if
    for pathFile in args
        file = findFile(object, pathFile)
        if file == null then; print(\"rm: file not found: \"+pathFile); return; end if
        if not file.has_permission(\"w\") then; print(\"rm: permission denied\"); return; end if

        if file.is_folder == 1 and isRecursive == 0 then
            print(\"rm: \" + file.name + \" is a directory\")
        else
            output = file.delete
            if len(output) or output == null then print(output)
        end if
    end for

end function

rm.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
saveSettings = {}
saveSettings.name = \"save-settings\"
saveSettings.args = \"[N/A]\"
saveSettings.desc = \"Saves settings.\"
saveSettings.full_desc = \"This command will save all settings to the settings file.\"
saveSettings.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
saveSettings.run = function(_, _)

    configFile = get_shell.host_computer.File(\"/home/\"+active_user+\"/Config/Viper.conf\")
    if active_user() == \"root\" then configFile = get_shell.host_computer.File(\"/root/Config/Viper.conf\")
    if not configFile then return
    settings = {}
    settings.theme = user_session.theme
    settings.vars = main_session.vars
    configFile.set_content(toJSON(settings))
    txt = do_style(\"Settings saved!\", \"green\", \"static\")
    print(char(10)+txt+char(10))

end function

saveSettings.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
scanlib = {}
scanlib.name = \"scanlib\"
scanlib.args = \"[PATH]\"
scanlib.desc = \"Returns library version.\"
scanlib.full_desc = \"This command will return the version of a library,\\n where [PATH] is the path to the library.\\nIt's important to use the correct metaxploit.so.\"
scanlib.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
scanlib.run = function(object, args)

    if not args then; show_help(self.name, self.args, self.full_desc, self.handler_types); return; end if
    if not main_session.MetaxploitLib then; print(\"Metaxploit not found!\"); return; end if

    lib = main_session.MetaxploitLib.load(args[0])
    if not lib then; print(\"Unable to load library!\"); return; end if
    libName = do_style(\"Name\", \"title\")+do_style(\": \"+lib.lib_name, \"text\")
    libVersion = do_style(\"Version\", \"title\")+do_style(\": \"+lib.version, \"text\")
    print(libName)
    print(libVersion)

end function

scanlib.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
secure = {}
secure.name = \"secure\"
secure.args = \"[-home/-server]\"
secure.desc = \"Secures a pc or server.\"
secure.full_desc = \"This command will secure a pc or server where [-home/-server] is a homePC or server.\"
secure.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
secure.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")
    if userCheck(object) != \"root\" then; print(\"Root is required!\"); return; end if

    print(\"If you are running this from your homePC, please use -home\")
    if user_input(\"Continue? (y/n): \").lower != \"y\" then
        print(\"Aborted\")
        return
    end if

    if args[0] == \"-home\" then
        rootFS = findFile(object, \"/\")
        rootFS.chmod(\"o-rwx\", true)
        rootFS.chmod(\"g-rwx\", true)
        rootFS.chmod(\"u-rwx\", true)
        rootFS.set_group(\"root\", true)
        rootFS.set_owner(\"root\", true)

        whitelisted = [
            \"/bin/sudo\",
            \"/usr/bin/Terminal.exe\",
            \"/usr/bin/AdminMonitor.exe\",
            \"/usr/bin/ConfigLan.exe\",
            \"/usr/bin/Mail.exe\",
            \"/usr/bin/Browser.exe\",
            \"/usr/bin/Notepad.exe\",
            \"/usr/bin/Settings.exe\",
            \"/usr/bin/Manual.exe\",
            \"/usr/bin/Chat.exe\",
            ]

        for program in whitelisted
            file = findFile(object, program)
            if file then file.chmod(\"g+x\")
        end for
    else if args[0] == \"-server\" then
        rootFS = findFile(object, \"/\")
        rootFS.chmod(\"o-rwx\", true)
        rootFS.chmod(\"g-rwx\", true)
        rootFS.chmod(\"u-rwx\", true)
        rootFS.set_group(\"root\", true)
        rootFS.set_owner(\"root\", true)
    else
        print(\"<color=red>Invalid arguments!</color>\")
        return
    end if
    print(\"<color=green>Filesystem secured!</color>\")

end function

secure.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
sha256 = {}
sha256.name = \"sha256\"
sha256.args = \"[STRING]\"
sha256.desc = \"Hashes a string with the sha256 algorithm.\"
sha256.full_desc = \"This command will use the sha256 algorithm to has a string where [STRING] is the string.\"
sha256.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
sha256.run = function(object, args)

    if not args then; self.show_help; return; end if
    print(\" \")
    sha256_hash(args)
    print(\" \")

end function

sha256.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
shell = {}
shell.name = \"shell\"
shell.args = \"[N/A]\"
shell.desc = \"Starts a shell, Viper will quit!!\"
shell.full_desc = \"This command will start a shell, Viper will quit!!\"
shell.handler_types = [\"start\", \"shell\"]
shell.run = function(object, args)

    object.start_terminal

end function

shell.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
sniff = {}
sniff.name = \"sniffer\"
sniff.args = \"(-save)\"
sniff.desc = \"Starts a sniffer.\"
sniff.full_desc = \"This command will start a sniffer where (-save) is wether or not to save the encode.src.\"
sniff.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
sniff.run = function(object, args)

    if not main_session.MetaxploitLib then; print(\"Error: Can't find metaxploit library.\"); return; end if
    print(\"Starting listen...\\nWaiting to incoming data.\")
    save = false
    if args and args[0] == \"-save\" then save = true
    output = main_session.MetaxploitLib.sniffer(save)
    if not output then; print(\"Unknown error: can't start to listening\"); return; end if
    print(output)

end function

sniff.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
ssh = {}
ssh.name = \"ssh\"
ssh.args = \"[USER@PASSWORD] [IP] (PORT)\"
ssh.desc = \"Connects to a service using ssh.\"
ssh.full_desc = \"This command will connects to a server using ssh where [USER@PASSWORD] is the user and password,\\n where [IP] is the IP of ther server,\\n where (PORT) is an optional port.\"
ssh.handler_types = [\"start\", \"shell\"]
ssh.run = function(object, args)

    if not args or args.len < 2 then; self.show_help; return; end if
    
    //Command: ssh
    credentials = args[0].split(\"@\")
    if credentials.len < 2 then; self.show_help; return; end if
    user = credentials[0]
    password = credentials[1]

    port = 22
    // params is a list of strings, so you have to convert it to integer, which is what connect_service accepts.
    if args.len == 3 then port = args[2].to_int
    if typeof(port) != \"number\" then; print(\"Invalid port: \" + port); return; end if
    print(\"Connecting...\")

    remoteShell = object.connect_service(args[1], port, user, password, \"ssh\")
    if typeof(remoteShell) != \"shell\" then; print(\"Could not connect!\"); return; end if
    if remoteShell then
        print(\"Connected!\")
        main_session.pub_ip = remoteShell.host_computer.public_ip
        main_session.handlerType = typeof(remoteShell)
        main_session.object = remoteShell
        main_session.loc_ip = remoteShell.host_computer.local_ip
        main_session.current_user = user
        {\"IP\":remoteShell.host_computer.public_ip, \"objectType\":typeof(remoteShell), \"object\":remoteShell, \"localIP\":remoteShell.host_computer.local_ip, \"user\":user}
    else 
        print(\"connection failed\")
    end if

end function

ssh.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
sudo = {}
sudo.name = \"sudo\"
sudo.args = \"[USER] [PASS] (JUMPPATH)\"
sudo.desc = \"Changes the shell to another user.\"
sudo.full_desc = \"This command will change the shell to another user where [USER] is the user,\\n where [PASS] is the password,\\n where (JUMPPATH) is the path to the jumpfile.\"
sudo.handler_types = [\"start\", \"shell\"]
sudo.run = function(object, args)

    if not args or args.len == 1 then; self.show_help; return; end if

    if main_session.handlerType == \"start\" and args.len >= 2 then
        newObject = get_shell(args[0], args[1])
        if not newObject then return null
        main_session.pub_ip = newObject.host_computer.public_ip
        main_session.handlerType = \"start\"
        main_session.object = newObject
        main_session.loc_ip = newObject.host_computer.local_ip
        main_session.current_user = userCheck(newObject.host_computer.File(\"/var\"))
        return
    else if main_session.handlerType == \"shell\" and args.len >= 3 then
        fileObject = object.host_computer.File(\"/var\")
        file = findFile(fileObject, args[2])
        if file then

            cargo = get_custom_object
            clearInterface(cargo)
            object.launch(args[2], args[0]+\" \"+args[1])

            if not hasIndex(cargo, \"gshell\") then
                print(\"Jump file corrupted!\")
                clearInterface(cargo)
                return
            end if

            if @cargo.gshell == null then
                print(\"Wrong password!\")
                clearInterface(cargo)
                return
            end if

            if not host_computer(@cargo.gshell) then
                print(\"AV detected injection!\")
                clearInterface(cargo)
                return
            end if

            newObject = cargo.gshell
            main_session.pub_ip = newObject.host_computer.public_ip
            main_session.handlerType = typeof(newObject)
            main_session.object = newObject
            main_session.loc_ip = newObject.host_computer.local_ip
            main_session.current_user = userCheck(newObject.host_computer.File(\"/var\"))
            clearInterface(cargo)
            return
        end if
        print(\"Jump file does not exist!\")
        return
    end if
    self.show_help
    return

end function

sudo.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
targets = {}
targets.name = \"targets\"
targets.args = \"[N/A]\"
targets.desc = \"Shows all available targets.\"
targets.full_desc = \"This command will show all available targets.\"
targets.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
targets.run = function(object, args)

    show_targets()

end function

targets.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
makeFile = {}
makeFile.name = \"touch\"
makeFile.args = \"[PATH]\"
makeFile.desc = \"Creates a file.\"
makeFile.full_desc = \"This command will make a file where [PATH] is the path of the file.\\nYou can create multiple files at once.\"
makeFile.handler_types = [\"start\", \"shell\", \"computer\"]
makeFile.run = function(object, args)

    if not args then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer
    //command: touch

    for pathFile in args
        pathParent = parent_path(pathFile)
        computer = object

        if pathParent == pathFile then
            pathParent = current_path
        end if

        parent = computer.File(pathParent)

        if not parent then; print(\"touch: \" + pathParent + \" not found\"); return; end if
        if not parent.has_permission(\"w\") then; print(\"touch: permission denied\"); return; end if

        arrayPath = pathFile.split(\"/\")
        output = computer.touch(parent.path, arrayPath[arrayPath.len - 1])
        if output and output != 1 then print(output)
    end for

end function

makeFile.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
use = {}
use.name = \"use\"
use.args = \"[INDEX]\"
use.desc = \"Uses a selected target.\"
use.full_desc = \"This command will show all use a target where [INDEX] is the selected target.\"
use.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
use.run = function(object, args)

    if not args then; show_help(commands.use.args, commands.use.full_desc, commands.use.handler_types); return; end if
    index = args[0].to_int
    if not main_session.objectList.hasIndex(index) then; print(\"Index not found!\"); return; end if

    add_session({\"IP\":main_session.pub_ip, \"objectType\":main_session.handlerType, \"object\":main_session.object, \"localIP\":main_session.loc_ip, \"user\":main_session.current_user})

    info = main_session.objectList[index]
    main_session.object = info.object
    main_session.handlerType = info.objectType
    main_session.pub_ip = info.IP
    main_session.loc_ip = info.localIP
    main_session.current_user = info.user

end function

use.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
uselib = {}
uselib.name = \"uselib\"
uselib.args = \"[INDEX]\"
uselib.desc = \"Select a library.\"
uselib.full_desc = \"This command will select a library where [INDEX] is the index of the library.\"
uselib.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
uselib.run = function(object, args)

    if not args then; self.show_help; return; end if
    index = args[0].to_int
    if not main_session.libList.hasIndex(index) then; print(\"Index not found!\"); return; end if
    for libMap in main_session.libList
        if typeof(libMap[\"value\"].lib) == typeof(main_session.libList[index].lib) and libMap[\"value\"].used then main_session.libList[libMap.key].used = 0
    end for
    main_session[typeof(main_session.libList[index].lib)+\"Version\"] = main_session.libList[index].version
    main_session[typeof(main_session.libList[index].lib)+\"PublicIP\"] = main_session.libList[index].publicIP
    main_session[typeof(main_session.libList[index].lib)+\"LocalIP\"] = main_session.libList[index].localIP
    main_session[typeof(main_session.libList[index].lib)] = main_session.libList[index].lib
    main_session.libList[index].used = 1

end function

uselib.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
vars = {}
vars.name = \"vars\"
vars.args = \"[N/A]\"
vars.desc = \"Lists all the available variables.\"
vars.full_desc = \"This command will list all the variabels.\"
vars.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
vars.run = function(object, args)

    for item in main_session.vars
        print(item[\"key\"]+\": \"+item[\"value\"])
    end for

end function

vars.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
whoisLookup = {}
whoisLookup.name = \"whois\"
whoisLookup.args = \"[IP]\"
whoisLookup.desc = \"Returns whois information.\"
whoisLookup.full_desc = \"This command will show whois information about an IP address,\\n where [IP] is the IP address.\"
whoisLookup.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
whoisLookup.run = function(object, args)

    if not args then; show_help(\"nslookup\", self.args, self.full_desc, self.handler_types); return; end if
    info = \"\"
    for line in whois(args[0]).split(\"\\n\")
        info = info+do_style(line.split(\": \")[0], \"title\")+do_style(\": \"+line.split(\": \")[1], \"text\")+\"\\n\"
    end for
    print(\"\\n\"+info)

end function

whoisLookup.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
wipe = {}
wipe.name = \"wipe\"
wipe.args = \"(-y)\"
wipe.desc = \"Wipes a machine.\"
wipe.full_desc = \"This command will wipe a machine where (-y) will skip the confirmation check.\"
wipe.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
wipe.run = function(object, args)

    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")

    if not args or args[0] != \"-y\" then
        if user_input(\"Do you really want to wipe this system? (y/n): \").lower != \"y\" then
            print(\"Aborted.\")
            return
        end if
    end if

    files = [\"/etc\", \"/lib\", \"/sys\", \"/root\", \"/home\", \"/var\", \"/bin\", \"/usr\", \"/boot\"]

    wipe_folder = function(path)
        print(\"Removing \"+path+\"...\")
        file = findFile(object, path)
        if file then
            if file.has_permission(\"w\") then
                file.delete
            else
                print(\"No permission to \"+file.name+\"!\")
            end if
        else
            print(\"File \"+path+\" does not exist!\")
        end if
        wait(0.5)
    end function
    
    for filePath in files
        wipe_folder(filePath)
    end for
    print(\"<color=green>System wipe done!</color>\")

end function

wipe.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
write = {}
write.name = \"write\"
write.args = \"[CONT] [>>/>] [PATH]\"
write.desc = \"Writes to a file.\"
write.full_desc = \"This command will write to a file where [CONT] is the content you want to write to the file,\\n where [>>/>] is the operator (>>) for appending to the file, (>) for replacing the contents,\\n where [PATH] is the path of the file.\"
write.handler_types = [\"start\", \"shell\", \"computer\", \"file\"]
write.run = function(object, args)

    if not args or args.len < 3 then; self.show_help; return; end if
    if typeof(object) == \"shell\" then object = object.host_computer.File(\"/var\")
    if typeof(object) == \"computer\" then object = object.File(\"/var\")

    newContent = args[0]
    operator = args[1]
    file = findFile(object, args[2])
    if not file then; print(\"File: \"+args[2]+\" not found!\"); return; end if

    if operator == \">\" then
        file.set_content(newContent)
    else if operator == \">>\" then
        file.set_content(file.get_content+newContent)
    end if

end function

write.show_help = function()
    show_help(self.name, self.args, self.full_desc, self.handler_types)
end function
commands = {
    \"help\":help, \"clear\":clear, \"credits\":credits, \"nmap\":nmap, \"exploitscan\":exploitscan, \"exploit\":exploit, \"targets\":targets, \"use\":use, \"back\":back, \"deltarget\":deltarget, \"ls\":ls,
    \"cat\":cat, \"ps\":ps, \"corruptlogs\":corruptlogs, \"buffer\":buffer, \"nslookup\":nsLookup, \"whois\":whoisLookup, \"scanlib\":scanlib, \"scanlib\":scanlib, \"addobject\":addobject, \"fs\":fs,
    \"exec\":exec, \"kill\":kill, \"mv\":mv, \"cp\":cp, \"rm\":rm, \"touch\":makeFile, \"mkdir\":mkdir, \"write\":write,\"compile\":compile, \"chmod\":chmodFile, \"chown\":chown, \"chgrp\":chgrp, \"passwd\":passwd,
    \"adduser\":adduser, \"deluser\":deluser, \"groups\":getGroups, \"addgroup\":addgroup, \"delgroup\":delgroup, \"get\":shellGet, \"put\":shellPut, \"sniffer\":sniff, \"secure\":secure, \"wipe\":wipe,
    \"addvar\":addvar, \"delvar\":delvar, \"vars\":vars, \"gpg\":gpg, \"md5\":md5_hash, \"sha256\":sha256, \"airmon\":airmonitor,\"iwlist\":iwlist, \"aireplay\":airkick, \"aircrack\":crack_cap, \"shell\":shell,
    \"loop\":loop, \"ssh\":ssh, \"sudo\":sudo, \"jump\":jump, \"msfvenom\":msfvenom, \"msfconsole\":msfconsole, \"grab\":grab, \"findlib\":findlib, \"deepscan\":deepscan, \"apt-get\":aptget, \"libs\":libs,
    \"uselib\":uselib, \"getlib\":getlib, \"dellib\":dellib, \"crack\":crack, \"getviper\":getviper, \"exit\":do_exit, \"save-settings\":saveSettings, \"load-theme\":load_theme, \"return\":returnStart,
    \"echo\":echo,
}

main_session = {
    \"exit\":false,
    \"version\":\"2.2.1\",
    \"MetaxploitLib\":null,
    \"MetaxploitLibPublicIP\":null,
    \"MetaxploitLibLocalIP\":null,
    \"MetaxploitLibVersion\":null,
    \"cryptoLib\":null,
    \"cryptoLibPublicIP\":null,
    \"cryptoLibLocalIP\":null,
    \"cryptoLibVersion\":null,
    \"aptclientLib\":null,
    \"aptclientLibPublicIP\":null,
    \"aptclientLibLocalIP\":null,
    \"aptclientLibVersion\":null,
    \"object\":get_shell,
    \"handlerType\":\"start\",
    \"pub_ip\":get_shell.host_computer.public_ip,
    \"loc_ip\":get_shell.host_computer.local_ip,
    \"current_user\":active_user,
    \"commandBuffer\":[],
    \"objectList\":{},
    \"netcatList\":{},
    \"libList\":{},
    \"sessionList\":[],
    \"vars\":{},
}

user_session = {
    \"theme\":{
        \"title\":\"#e60000\",   // red
        \"text\":\"#404040\",    // dark-grey
        \"arg\":\"#00ff00\",     // green
        \"bool\":\"#00ace6\",    // light-blue
        \"outline\":\"#404040\", // dark-grey
        \"start_color\":\"#e60000\",
        \"handler_color\":\"#00ff00\",
    },
    \"static\":{
        \"logo\":\"#cccccc\",    // grey
        \"credits\":\"#ffffff\", // white
        \"red\":\"#e60000\",
        \"green\":\"#00ff00\",
        \"dark_grey\":\"#404040\",
        \"yellow\":\"#e6e600\",
        \"blue\":\"#000099\",
        \"light_blue\":\"#00ace6\",
    },
}

if params.indexOf(\"-a\") != null or params.indexOf(\"--anonymous\") != null then main_session.pub_ip = \"HIDDEN\"
import_libs()
update_check()
addDefaultVars()
if params.indexOf(\"--no-settings\") == null and params.indexOf(\"-ns\") == null then loadSettings()
import_code(\"/home/volk/viper.img\")
ascii_print()

injectionFlag = \"Congrats, you were able to inject Viper! Your flag code is: ^E%aW$%k#5UX=1ay3r8Eu=V87$n$+rDF\"

command_logic = function(input)
    if main_session.vars.hasIndex(input[0]) then
        input = main_session.vars[input[0]].split(\" \")+input[1:]
    end if

    command = input[0].lower
    rawArgs = input[1:]

    args = []
    for arg in rawArgs
        if arg != \"\" then args.push(arg)
    end for

    if input.len < 2 then args = false

    if command == \"\" then
        return
    else if not commands.hasIndex(command) then
        print(\"Command \"+command+\" not found, type \"\"help\"\" for help. \")
        return
    else if commands[command].handler_types.indexOf(main_session.handlerType) == null then
        txt = do_style(\"You can't use the command \"+command+\" in this handler!\", \"red\", \"static\")
        print(char(10)+txt)
        commands[command].show_help()
        return
    end if

    index=0
    noVarCommands = [\"vars\", \"addvar\", \"delvar\"]
    for argument in args
        var = argument
        arg = \"\"
        if argument.split(\"\\+\").len > 1 then
            var = argument.split(\"\\+\")[0]
            arg = argument.split(\"\\+\")[1]
        end if
        if main_session.vars.hasIndex(var) and noVarCommands.indexOf(command) == null then args[index] = main_session.vars[var]+arg
        index = index+1
    end for

    blacklist = [\"buffer\", \"back\", \"targets\", \"clear\"]
    if blacklist.indexOf(command) == null then addToBuffer(command, args)
    commands[command].run(main_session.object, args)
end function

while not main_session.exit
    
    input = user_input(TTY(main_session.object, main_session.handlerType, main_session.pub_ip, main_session.loc_ip, main_session.current_user)).split(\" \")
    
    command = input[0]
    
    args = input[1:]
    
    if command.split(\"@\").len >= 2 then
        
        macro_file = get_shell.host_computer.File(home_dir+\"/Config/Macros/\"+command.split(\"@\")[1])
        
        if active_user == \"root\" then macro_file = get_shell.host_computer.File(\"/root/Config/Macros/\"+command.split(\"@\")[1])

        if not macro_file then; print(\"Macro not found!\"); continue; end if
        
        print(\"Macro detected...\")
        
        for macro in macro_file.get_content.split(char(10))
        
            input = macro.split(\" \")
        
            command_logic(input)

        end for
        
        print(\"Macro finished!\")

        continue
        
    end if

    command_logic(input)

end while
"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction5" type="RichTextLabel" parent="TabContainer/viper/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Now, you may run viper by using command viper at the install directory or any where (if installed at [color=cyan]/bin/[/color])"
fit_content = true

[node name="5hell" type="MarginContainer" parent="TabContainer"]
visible = false
layout_mode = 2
metadata/_tab_index = 1

[node name="ScrollContainer" type="ScrollContainer" parent="TabContainer/5hell"]
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="TabContainer/5hell/ScrollContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Disclaimer" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "[color=yellow]Disclaimer:[/color] 5hell Source code can be found at [url]https://github.com/jhook777/5hell-for-Grey-Hack-the-Game[/url]. Make sure to find the latest version at there."
fit_content = true

[node name="Instruction" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Get [color=red]root[/color] privileges in your terminal"
fit_content = true

[node name="LineEdit" type="LineEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
text = "sudo -s"
editable = false

[node name="Instruction2" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Create a directory called [color=cyan][code]src[/code][/color] in the /root directory"
fit_content = true

[node name="LineEdit2" type="LineEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
text = "mkdir /root/src"
editable = false

[node name="Instruction3" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]contrib.5pk.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/root/src/contrib.5pk[/color]. Make sure to keep 'Allow import' checked."
fit_content = true

[node name="ContribCodeEdit" type="CodeEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 300)
layout_mode = 2
text = "if DEBUG then print(\"<size=75%>loading contrib.5pk for 5hell v 4.0.7...(113.385kb)</size>)\")
  // start games made by Plu70
  bat = function(s)
      // battleship by Plu70, aka ra'al, aka jhook777  2021
      // start with 10 x 10 grid
      // 24.905kb
      // valid launch params:
      //
      // -c -- all color lines are null
      // -d -- debug mode, no wait(1)'s and verbose
      // -dt - early terminate: spawn ships, print locations and end
      // -s -- self play: ai vs rng
      // -cd, -cd -s, -d -s, -c -s, also valid combinations
      //
      // order matters with launch params
      // ai is marginally better than random*
      ////////////////////////
      game_file = null  // single player for now
      DIFFICULTY = \"hard\" // lol jk, still need better ai algorithm. easy or medium available at runtime
      EARLYTERM = false
      self_play = false
      //if params.len >= 1 and (params[0] == \"-s\" or params [1] == \"-s\") then self_play = true
      //debug = globals.DEBUG
      disable_color = false
      
      /////////
      if s == \"-s\" then self_play = true
      ////////////////////////
      globals.MIN = 0 // minimum X/Y values for grid size
      globals.MAX = 9 // maximum X/Y values for grid size
      rng = range(MIN,MAX)
      rnd = range(MIN,MAX)
      rng.shuffle
      rnd.shuffle
      
      ///BEGIN GRAPHICS//////
      
      print_logo = function()
          print(colorRed+\" _           _   _   _           _     _         \"+CT)
          print(colorGreen+\"| |         | | | | | |         | |   (_)       \"+CT)
          print(colorGreen+\"| |__   __ _| |_| |_| | ___  ___| |__  _ _ __   \"+CT)
          print(colorGreen+\"| '_ \\ / _` | __| __| |/ _ \\/ __| '_ \\| | '_ \\  \"+CT)
          print(colorRed+\"| |_) | (_| | |_| |_| |  __/\\__ \\ | | | | |_) | \"+CT)
          print(colorGreen+\"|_.__/ \\__,_|\\__|\\__|_|\\___||___/_| |_|_| .__/  \"+CT)
          print(colorGreen+\"                                       | |      \"+CT)
          print(colorGreen+\"                                       |_|      \"+CT)
      
      end function
      
      display_ship_one = function()
      
          ship_one = [\"                                                                       .\",	\"                                     # #  ( )                           \",\"                                  ___#_#___|__                          \",	\"                              _  |____________|  _                      \",	\"                       _=====| | |            | | |==== _               \",	\"                 =====| |.---------------------------. | |====          \",	\"   <--------------------'   .  .  .  .  .  .  .  .   '--------------/   \",	\"     \\                                                             /    \",	colorLightBlue+\"  wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww \"+CT,	colorLightBlue+\"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\"+CT,	colorLightBlue+\"   wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww  \"+CT]
          for ln in ship_one
              print(ln)
          end for
      end function
      
      display_ship_two = function()
      
          ship_two = [\"                                                                               \",\"                                     |__                                       \",	\"                                     |\\/                                       \",	\"                                     ---                                       \",	\"                                     / | [                                     \",	\"                              !      | |||                                     \",	\"                            _/|     _/|-++'                                    \",	\"                        +  +--|    |--|--|_ |-                                 \",	\"                     { /|__|  |/\\__|  |--- |||__/                              \",	\"                    +---------------___[}-_===_.'____                 /\\       \",	\"                ____`-' ||___-{]_| _[}-  |     |_[___\\==--            \\/   _   \",	\" __..._____--==/___]_|__|_____________________________[___\\==--____,------' .7 \",	\"|                                                                     BB-61/   \",	\" \\_________________________________________________________________________|   \",	colorLightBlue+\"  Matthew Bacewwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\"+CT,	colorLightBlue+\"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\"+CT	]
          for ln in ship_two
              print(ln)
          end for
      end function
      
      display_ship_three = function()
          // stub
      end function
      
      display_long_rule = function()
          print(colorGreen+\"</b>[.0....1....2.....3....4.....5....6....7.....8....9.]</color>\")  // adjust this to fit your terminal
      end function
      /////END GRAPHICS /////////
      
      /////// SANITY CHECK /////
      check_sanity = function(sobj) // ensure ships don't overlap
          if globals.DEBUG then print(\"Checking Sanity...\")
          if globals.DEBUG then print(sobj.frigate)
          if globals.DEBUG then print(sobj.cruiser)
          if globals.DEBUG then print(sobj.battleship)
      
          bshipX = sobj.battleship.X
          bshipY = sobj.battleship.Y
          cshipX = sobj.cruiser.X
          cshipY = sobj.cruiser.Y
          fshipX = sobj.frigate.X
          fshipY = sobj.frigate.Y
      
          if globals.DEBUG then print( bshipX  )
      
          collision = 0
          static_ship = \"battleship\"
      
          for fx in fshipX
              if fx > globals.MAX then collision = \"out_of_bounds\"
              if cshipX.indexOf(fx) >= 0 then
                  for fy in fshipY
                      if cshipY.indexOf(fy) >= 0 then
                          collision = \"frigate\"
                          static_ship = \"cruiser\"
                          if fy > globals.MAX then collision = \"out_of_bounds\"
                      end if
                  end for
              end if
          end for
      
          for bx in bshipX
              if bx > globals.MAX then collision = \"out_of_bounds\"
              if globals.DEBUG then print(\"bx:\"+bx)
              if globals.DEBUG then print(\"cruiser: index of bx: \"+cshipX.indexOf(bx))
              if cshipX.indexOf(bx) >= 0 and cshipX.hasIndex(cshipX.indexOf(bx)) then
                  for by in bshipY
                      if globals.DEBUG then print(\"by:\"+by)
                      if cshipY.indexOf(by) >= 0 and cshipY.hasIndex(cshipY.indexOf(by)) then collision = \"cruiser\"
      
                  end for
              end if
      
              if fshipX.indexOf(bx) >= 0 then
                  for by in bshipY
                      if fshipY.indexOf(by) >= 0 then collision = \"frigate\"
                      if by > globals.MAX then collision = \"out_of_bounds\"
                  end for
              end if
      
          end for
          for cx in cshipX
              if cx > globals.MAX then collision = \"out_of_bounds\"
          end for
          for cy in cshipY
              if cy > globals.MAX then collision = \"out_of_bounds\"
          end for
          if globals.DEBUG then print(\"coll:\"+collision)
          if collision then
              if globals.DEBUG then print(\"Handling collision between \"+static_ship+\" and \"+collision+\"...\")
              // this tactic is known as 'do something, even if it's wrong'
              nX = sobj[collision][\"X\"]
              nY = sobj[collision][\"Y\"]
              if nX.len > nY.len then
                  if nY[0] <= 0 then nY[0] = 3
                  if nY[0] >= 9 then nY[0] = 5
                  if nY[0] == 2 or nY[0] == 4 or nY[0] == 6 then nY[0] = nY[0] + 1
                  rr = range(-1,1)
                  rr.shuffle
                  nY[0] = nY[0] + rr.pop
                  if nY[0] > globals.MAX then collision = \"out_of_bounds\"
              else
                  if nX[0] <= 0 then nX[0] = 3
                  if nX[0] >= 9 then nX[0] = 5
                  if nX[0] == 2 or nX[0] == 4 or nX[0] == 6 then nX[0] = nX[0] + 1
                  rr = range(-1,1)
                  rr.shuffle
                  nX[0] = nX[0] + rr.pop
                  if nX[0] > globals.MAX then collision = \"out_of_bounds\"
              end if
          end if
          //////
          if globals.DEBUG then print(\"Handled. Back propagating...\")
          if globals.DEBUG and not collision then print(\"Sanity check complete.\")
          return collision// true for recursion or false if no collisions and sane
      end function
      //// END SANITY CHECK //////
      
      map = {}
      map.grid = []
      map.make = function()
          map.grid = range(globals.MIN,globals.MAX)
          for e in range(globals.MIN,globals.MAX)
              map.grid[e] = range(globals.MIN,globals.MAX)
              for c in map.grid[e]
                  if globals.DEBUG then
                      map.grid[e][c] = e+\",\"+c
                  else
                      map.grid[e][c] = colorLightBlue+\"www\"+CT
                  end if
              end for
          end for
      end function
      map.get_cell = function(x,y)
          return map[\"grid\"][x][y]
      end function
      map.edit_cell = function(xy,beef,actor)
          split = xy.split(\" \")
          if split.len < 2 then
              split.push(\"0\")
              if split.len < 2 then
                  split.push(\"0\")
              end if
          end if
          x = split[0].val
          y = split[1].val
          edit = \"www\"
          if beef > 0 then // hit
              if actor == computa.label then
                  edit = colorOrange+\"***\"+CT
              else
                  edit = colorRed+\"***\"+CT
              end if
          else
              if beef == 0 then // miss
                  if actor == computa.label then
                      edit = colorLightBlue+\"###\"+CT
                  else
                      edit = colorWhite+\"###\"+CT
                      if map[\"grid\"][x][y] == colorLightBlue+\"###\"+CT then edit = (colorWhite+\"#\"+CT+colorLightBlue+\"#\"+CT+colorWhite+\"#\"+CT)
                  end if
              end if
          end if
          if globals.DEBUG then print(\"X:\"+x+\" Y:\"+y+\" edit:\"+edit)
          if map[\"grid\"][x][y] == (colorRed+\"***\"+CT) then
              if beef then
                  edit = colorRed+\"*\"+CT+colorOrange+\"*\"+CT+colorRed+\"*\"+CT
              else
                  return beef
              end if
          end if
          if beef and map[\"grid\"][x][y] == colorOrange+\"***\"+CT then edit = colorRed+\"*\"+CT+colorOrange+\"*\"+CT+colorRed+\"*\"+CT
          if not beef and map[\"grid\"][x][y] == colorOrange+\"***\"+CT then edit = (colorWhite+\"#\"+CT+colorOrange+\"#\"+CT+colorWhite+\"#\"+CT)
          if not beef and map[\"grid\"][x][y] == (colorWhite+\"###\"+CT) then edit = (colorWhite+\"#\"+CT+colorLightBlue+\"#\"+CT+colorWhite+\"#\"+CT)
          map[\"grid\"][x][y] = edit
          return beef
      end function
      map.display_grid = function()
          buf = \"\"
          y = globals.MAX
          while y >= globals.MIN
              for x in range(globals.MIN,globals.MAX)
                  buf = buf + \".\" + map.get_cell(x,y) + \".\"
              end for
              buf = buf + colorGreen+\"</b>.[\"+y+\"]</color>\"+ char(10)
              y = y - 1
          end while
          print(buf)
          display_long_rule
      end function
      map.make
      
      
      
      player = {}
      player.label = \"\"
      player.opponent = \"\"
      player.BUFFER = {}
      player.position = {}
      player.display_ship_coordinates = function()
          for c in self.position
              print(\">\"+c.value.label+\":\")
              print(\"[X: \"+c.value.X+\" Y:\"+c.value.Y+\"]\")
          end for
      end function
      player.fire = function(coords)
          aim = coords.split(\" \")
          print(colorOrange+self.label + \" fires at \" + aim[0] + \", \" + aim[1] + \" and... \"+CT)
          wait(1)
          count = 0
          for ship_obj in self.opponent.position
              if globals.DEBUG then print(ship_obj)
              shipX = ship_obj.value.X
              shipY = ship_obj.value.Y
              count = count + 1
              for sx in shipX
                  if aim[0].val == sx then
                      for sy in shipY
                          if aim[1].val == sy then
                              print(colorRed+\"<b>HITS!</b>\"+CT+char(10))
                              summary.accuracy.update(self.label, \"hit\", coords)
                              return count
                          end if
                      end for
                  end if
              end for
          end for
          print(\"<b>MISSES!</b>\"+char(10))
          summary.accuracy.update(self.label, \"miss\", coords)
          return 0
      end function
      player.spawn_ship = function(ship)
          top_edge = false
          bottom_edge = false
          left_edge = false
          right_edge = false
          i = 0
          if ship.hasIndex(\"frigate\") then i = ship.frigate
          if ship.hasIndex(\"cruiser\") then i = ship.cruiser
          if ship.hasIndex(\"battleship\") then i = ship.battleship
          if globals.DEBUG then print(\"[\"+colorWhite+ship.label+CT+\"]\")
      
          transmform = function(sob)
              if sob.X[0] == globals.MIN then left_edge = true
              if sob.X[-1] == globals.MAX then right_edge = true
              if sob.Y[0] == globals.MIN then bottom_edge = true
              if sob.Y[-1] == globals.MAX then top_edge = true
              if sob.X.len > 1 then
                  top_edge = true
                  bottom_edge = true
              end if
              if sob.Y.len > 1 then
                  left_edge = true
                  right_edge = true
              end if
              vote_down = 1
              vote_up = 1
              vote_left = 1
              vote_right = 1
              if top_edge then vote_up = 0
              if bottom_edge then vote_down = 0
              if left_edge then vote_left = 0
              if right_edge then vote_right = 0
              rn = range(1,10) // do not set globals.MIN to zero
              rn.shuffle
              vote_up = (vote_up * rn.pop)
              if globals.DEBUG then print(vote_up+\":up\")
              rn.shuffle
              vote_down = (vote_down * rn.pop)
              if globals.DEBUG then print(vote_down+\":down\")
              rn.shuffle
              vote_right = (vote_right * rn.pop)
              if globals.DEBUG then print(vote_right+\":right\")
              rn.shuffle
              vote_left = (vote_left * rn.pop)
              if globals.DEBUG then print(vote_left+\":left\")
              tally = [vote_up,vote_down,vote_left,vote_right]
              tally.sort
              tally.reverse
              winner = tally[0]
              if globals.DEBUG then print(winner)
              if winner == 0 then return
              if winner == vote_up then //up
                  sob.Y.push(sob.Y[-1]+1)
                  sob.Y.sort
                  return
              end if
              if winner == vote_down then //down
                  sob.Y.push(sob.Y[0]-1)
                  sob.Y.sort
                  return
              end if
              if winner == vote_left then // left
                  sob.X.push(sob.X[0]-1)
                  sob.X.sort
                  return
              end if
              if winner == vote_right then //right
                  sob.X.push(sob.X[-1]+1)
                  sob.X.sort
                  return
              end if
          end function
      
          while i > 0
              transmform(ship)
              i = i - 1
          end while
      end function
      
      player1 = new player
      player1.label = \"Player\"
      player1.BUFFER = {}
      player1.position = {}
      player1.position.frigate = {\"X\":[0], \"Y\":[0], \"frigate\":1, \"label\":\"frigate\"}
      player1.position.cruiser = {\"X\":[0], \"Y\":[0], \"cruiser\":2, \"label\":\"cruiser\"}
      player1.position.battleship = {\"X\":[0], \"Y\":[0], \"battleship\":4, \"label\":\"battleship\"}  // position ship then spawn_ship
      player1.setup = function(x,y)
          self.position.frigate.X[0] = x[0]
          self.position.frigate.Y[0] = y[0]
          x.shuffle
          y.shuffle
          self.position.cruiser.X[0] = x[0]
          self.position.cruiser.Y[0] = y[0]
          x.shuffle
          y.shuffle
          self.position.battleship.X[0] = x[0]
          self.position.battleship.Y[0] = y[0]
          self.spawn_ship(self.position.frigate)
          self.spawn_ship(self.position.cruiser)
          self.spawn_ship(self.position.battleship)  // position ship then spawn_ship
          while check_sanity(self.position)
          end while
      end function
      player1.confirm = function(cmd)
          // cmd is user_input so respond only to correct input and drop all else
          if cmd == \"\" then cmd = \"0 0\"
          aim = cmd.split(\" \")
          if aim.len < 2 then
              aim.push(\"0\")
              if aim.len < 2 then
                  aim.push(\"0\")
              end if
          end if
          aim[0] = aim[0].val
          aim[1] = aim[1].val
          cmd = aim.join(\" \")
          if player1.BUFFER.hasIndex(cmd) then
              print(colorOrange+\"That would be a waste of ammunition!\"+CT)
              return 0 // command denied
          else
              player1.BUFFER.push(cmd)
          end if
          aim = cmd.split(\" \")
          if aim[0].val > globals.MAX or aim[1].val > globals.MAX or aim[0].val < globals.MIN or aim[1].val < globals.MIN then
              print(colorOrange+\"</b>Target designation is out of bounds!</color>\")
              return 0
          end if
          return cmd // confirmed command
      end function
      
      
      /// BEGIN Computa
      computa = new player
      computa.label = \"Computa\"
      computa.BUFFER = {}
      computa.position = {}
      computa.position.frigate = {\"X\":[0], \"Y\":[0], \"frigate\":1, \"label\":\"frigate\"} // x_array, y_array, label:# of transorms in spawn_ship
      computa.position.cruiser = {\"X\":[0], \"Y\":[0], \"cruiser\":2, \"label\":\"cruiser\"} // adjust check_score when adding new ship classes!
      computa.position.battleship = {\"X\":[0], \"Y\":[0], \"battleship\":4, \"label\":\"battleship\"} // position ship then spawn_ship
      computa.AI = {}
      computa.AI.ghost_ship = {}
      computa.AI.ghost_ship.frigate = {\"X\":[1], \"Y\":[1], \"frigate\":1, \"label\":\"ghost_frigate\"}
      computa.AI.ghost_ship.cruiser = {\"X\":[8], \"Y\":[8], \"cruiser\":2, \"label\":\"ghost_cruiser\"}
      computa.AI.ghost_ship.battleship = {\"X\":[5], \"Y\":[5], \"battleship\":4, \"label\":\"ghost_battleship\"}
      computa.AI.c_list = []
      computa.wake_AI = function()
          self.spawn_ship(self.AI.ghost_ship.battleship)
          self.spawn_ship(self.AI.ghost_ship.frigate)
          self.spawn_ship(self.AI.ghost_ship.cruiser)
          t_x = []
          t_y = []
          t_cmd = \"\"
          for s in self.AI.ghost_ship
              t_x = s.value.X
              t_y = s.value.Y
              t_cmd = t_x[0]+\" \"+t_y[0]
              self.AI.c_list.push(t_cmd)
          end for
      end function
      computa.setup = function(x,y)
          self.position.frigate.X[0] = x[0]
          self.position.frigate.Y[0] = y[0]
          x.shuffle
          y.shuffle
          self.position.cruiser.X[0] = x[0]
          self.position.cruiser.Y[0] = y[0]
          x.shuffle
          y.shuffle
          self.position.battleship.X[0] = x[0]
          self.position.battleship.Y[0] = y[0]
          self.spawn_ship(self.position.frigate)
          self.spawn_ship(self.position.cruiser)
          self.spawn_ship(self.position.battleship)  // position ship then spawn_ship
          while check_sanity(self.position)
          end while
      end function
      computa.AI.update_ghosts = function(new_X, new_Y, new_T)
          self.ghost_ship.frigate.X = new_X
          self.ghost_ship.frigate.Y = new_Y
          self.ghost_ship.cruiser.X = new_X
          self.ghost_ship.cruiser.Y = new_Y
          self.ghost_ship.battleship.X = new_X
          self.ghost_ship.battleship.Y = new_Y
          self.ghost_ship.frigate.frigate = new_T
          self.ghost_ship.cruiser.cruiser = new_T
          self.ghost_ship.battleship.battleship = new_T
          computa.spawn_ship(self.ghost_ship.frigate)
          computa.spawn_ship(self.ghost_ship.cruiser)
          computa.spawn_ship(self.ghost_ship.battleship)
      end function
      computa.AI.alpha = function()
          last_shot = summary.accuracy.Computa.hist[-2]
          if globals.DEBUG then print(\"last shot: \"+last_shot)
          last_action = summary.accuracy.Computa.hist[-1]
          if self.c_list.len < 1  or last_action == \"hit\" then //c_list_empty = true
              new_C = last_shot.split(\" \")
              if globals.DEBUG then print(new_C)
              new_x = [new_C[0].val]
              new_y = [new_C[1].val]
              new_t = 0
              if last_action == \"miss\" then
                  new_t = 6
              else
                  new_t = 2
              end if
              self.purge_ghosts
              self.update_ghosts(new_x,new_y, new_t)
              t_x = []
              t_y = []
              t_cmd = \"\"
              for s in self.ghost_ship
                  t_x = s.value.X
                  t_y = s.value.Y
                  t_y.shuffle
                  t_x.shuffle
                  t_cmd = t_x[0]+\" \"+t_y[0]
                  if globals.DEBUG then print(\"Pushing \"+t_cmd+\" to c_list...\")
                  if not self.c_list.hasIndex(t_cmd) then self.c_list.push(t_cmd)
              end for
          end if
          if self.c_list.len < 1 then // panic
              rng.shuffle
              rnd.shuffle
              t_cmd = [rng[0], rnd[0]]
              t_cmd = t_cmd.join(\" \")
              self.c_list.push(t_cmd)
          end if
          self.c_list.shuffle
          return  self.c_list.pop // string of type \"X Y\" where X and Y are within outer.MIN, MAX
      end function
      computa.AI.panic_level = 4
      computa.AI.purge_ghosts = function()
          self.ghost_ship.frigate.X = []
          self.ghost_ship.frigate.Y = []
          self.ghost_ship.cruiser.X = []
          self.ghost_ship.cruiser.Y = []
          self.ghost_ship.battleship.X = []
          self.ghost_ship.battleship.Y = []
      end function
      computa.AI.omega = function() // when computa has found all three of Payer1's ships
          last_shot = summary.accuracy.Computa.hist[-2]
          hl = summary.accuracy.Computa.hit_list
          if globals.DEBUG then print(\"hit_list: \"+hl)
          last_action = summary.accuracy.Computa.hist[-1]
          if self.c_list.len < 1  or last_action == \"hit\" then
              hl.shuffle
              new_C = hl[0].split(\" \")
              if globals.DEBUG then print(new_C)
              new_x = [new_C[0].val]
              new_y = [new_C[1].val]
              new_t = 0
              if last_action == \"miss\" then
                  new_t = 2
              else
                  new_t = 1
              end if
              self.purge_ghosts
              self.update_ghosts(new_x,new_y, new_t)
              t_x = []
              t_y = []
              t_cmd = \"\"
              for s in self.ghost_ship
                  t_x = s.value.X
                  t_y = s.value.Y
                  t_y.shuffle
                  t_x.shuffle
                  t_cmd = t_x[0]+\" \"+t_y[0]
                  if globals.DEBUG then print(\"Pushing \"+t_cmd+\" to c_list...\")
                  if not self.c_list.hasIndex(t_cmd) then self.c_list.push(t_cmd)
              end for
          end if
          if self.c_list.len < 1 then // panic
              rng.shuffle
              rnd.shuffle
              t_cmd = [rng[0], rnd[0]]
              t_cmd = t_cmd.join(\" \")
              self.c_list.push(t_cmd)
          end if
          self.c_list.shuffle
          return  self.c_list.pop // string of type \"X Y\" where X and Y are within outer.MIN, MAX
      end function
      computa.get_command = function() // obvious stub needs obvious improvement
          ccommand = \"\"
          if DIFFICULTY == \"easy\" then
              ccommand = [rng[0], rnd[0]]
              ccommand = ccommand.join(\" \")
          else
              if computa.score[0] > 0 and computa.score[1] > 0  and computa.score[2] > 0 then
                  // all ships found, prepare for gg
                  ccommand = self.AI.omega
              else
                  //if computa.score[0] > 0 or computa.score[1] > 0  or computa.score[2] > 0 then
                      //ccommand = [rng[0], rnd[0]]
                      //ccommand = ccommand.join(\" \")
              //	else
                      ccommand = self.AI.alpha
                  //end if
              end if
          end if
          if globals.DEBUG then print(\"sending: \"+ccommand)
          rng.shuffle
          rnd.shuffle
          if self.BUFFER.hasIndex(ccommand) then
              if globals.DEBUG then print(\"!!Repeat detected!!\")
              self.AI.panic_level = 8
              ccommand = false
              //return ccommand
          else
              self.BUFFER.push(ccommand)
              self.AI.panic_level = 4
              //return ccommand
          end if
          return ccommand
      end function
      //// END Computa
      
      
      if globals.DEBUG then print(\"Initializing players...\")
      rng = range(MIN,MAX)
      rnd = range(MIN,MAX)
      
      rng.shuffle
      rnd.shuffle
      
      computa.setup(rng,rnd)
      computa.wake_AI
      
      rnd.shuffle
      rng.shuffle
      
      if globals.DEBUG then print(\"...readying player1...\")
      player1.setup(rng,rnd)
      
      player1.opponent = computa
      computa.opponent = player1
      
      player1.score = [0,0,0] // [frigate,cruiser,battleship]
      computa.score = [0,0,0] // [2_tokill,3 tokill,5 tokill] (transorms + 1 to kill)
      check_score = function(bit,act)
          if globals.DEBUG then print(\"Scoring...\")
          if globals.DEBUG then print(act+\":\"+bit)
          if act == player1.label then
              if not bit then return 1
              player1.score[bit-1] = player1.score[bit-1] + 1
              if player1.score.sum == 10 then return 0 // command BUFFER restricts repeat shots
              return 1
          else
              if not bit then return 1
              computa.score[bit-1] = computa.score[bit-1] + 1
              if computa.score.sum == 10 then return 0
              return 1
          end if
      end function
      
      DATASET = {}
      DATASET.accuracy = {}
      DATASET.accuracy.Computa = {}
      DATASET.accuracy.Player = {}
      summary = new DATASET
      summary.purge = function()
          if globals.DEBUG then print(\"purging...\")
          self.accuracy.Computa.hist = []
          self.accuracy.Player.hist = []
      end function
      summary.accuracy.update = function(lbl, event, crds)
          //summary.purge
          if globals.DEBUG then print(\"updating...\"+lbl)
          if lbl == self.Player.label and globals.DEBUG then print(\"player found!\")
          summary[\"accuracy\"][lbl][\"hist\"].push(crds)
          if globals.DEBUG then print(crds)
          if event == \"hit\" then // hit
              summary[\"accuracy\"][lbl][\"Hits\"] = summary[\"accuracy\"][lbl][\"Hits\"] + 1
              if globals.DEBUG then print(\"pushing \"+crds+\" to hit_list...\")
              summary[\"accuracy\"][lbl][\"hit_list\"].push(crds)
          else // miss
              summary[\"accuracy\"][lbl][\"Misses\"] = summary[\"accuracy\"][lbl][\"Misses\"] + 1
          end if
          summary[\"accuracy\"][lbl][\"hist\"].push(event)
      end function
      summary.accuracy.report = function()
          if globals.DEBUG then print(\"reporting...\")
          last_computer_shot = self.Computa.hist
          last_player_shot = self.Player.hist
          if last_computer_shot[-1] == \"hit\" then
              revent = (colorRed+\"<b>HIT!</b>\"+CT)
          else
              revent = \"<b>MISSED!</b>\"
          end if
          print(colorOrange+self.Computa.label+\" fired at \"+last_computer_shot[-2]+\" and \"+revent)
          if last_player_shot[-1] == \"miss\" then
              revent = \"<b>MISSED!</b>\"
          else
              revent = (colorRed+\"<b>HIT!</b>\"+CT)
          end if
          print(colorOrange+self.Player.label+\" fired at \"+last_player_shot[-2]+\" and \"+revent)
      end function
      summary.widget = function()
          l = self.accuracy.Player.label
          h = self.accuracy.Player.Hits
          m = self.accuracy.Player.Misses
          s = m+h
          print(colorWhite+\"|\"+l+\" accuracy: \"+ h +colorGreen+\"/\"+colorWhite+s+\"|\"+CT)
      end function
      summary.accuracy.init = function()
          self.Computa = {\"label\":\"Computa\", \"Hits\":0, \"Misses\":0, \"hist\":[\"nothing\",0], \"hit_list\":[]}
          self.Player = {\"label\":\"Player\", \"Hits\":0, \"Misses\":0, \"hist\":[\"nothing\",0], \"hit_list\":[]}
      end function
      summary.accuracy.init
      
      
      if globals.DEBUG then print(\"...init complete. Starting main...\")
      ////// BEGIN MAIN /////////
      battleship = function()
          playing = true
          first_run = true
          if EARLYTERM then playing = false
          if globals.DEBUG and EARLYTERM then player1.display_ship_coordinates
          if globals.DEBUG and EARLYTERM then computa.display_ship_coordinates
          if user_input(\"Select a difficulty level:\"+char(10)+\"[EASY] - Commander Rander\"+char(10)+\"[MEDIUM] - Captain Chao \"+char(10)+[\"||: \"]).lower != \"EASY\" then
              print(\"MEDIUM difficulty selected. Good luck!\")
              DIFFICULTY = \"medium\"
          else
              print(\"EASY difficulty selected. Good luck!\")
              DIFFICULTY = \"easy\"
          end if
          ///// game starts here
          while playing
              if not globals.DEBUG then clear_screen
              if not first_run then print_logo
      
              player1.display_ship_coordinates
              if globals.DEBUG then computa.display_ship_coordinates
              if not first_run then summary.accuracy.report
              if globals.DEBUG then print(player1.score)
              if globals.DEBUG then print(computa.score)
              print(colorGreen+\"</b>//////////////////////////////////////////////////////</color>\")
      
              map.display_grid
              if not first_run then summary.widget
      
              first_run = false
              command = 0
              if self_play then
                  rng.shuffle
                  rnd.shuffle
                  command = [rng[0], rnd[0]]
                  command = command.join(\" \")
                  if not globals.DEBUG then wait(1)
              else
                  print(\"q=quit\")
                  command = user_input(\"Enter coordinates [0-9] as [x y]: \")
                  if command.lower == \"q\" then return \"abandoning ship...\"
              end if
              command = player1.confirm(command)
              if command == 0 then continue // belay that order!
              if not globals.DEBUG then clear_screen
              display_ship_one
              playing = check_score(map.edit_cell(command, player1.fire(command), player1.label), player1.label)
      
              if not playing then return(\"<b>You sunk all of computa's battleships! You Win!</b>\")
      
              rng.shuffle // vestigial shuffle
              rnd.shuffle // vestigial shuffle
              wait(1)
              if not globals.DEBUG then clear_screen
      
              display_ship_two
              ai_turn = true
              while ai_turn
                  command = computa.get_command
                  if globals.DEBUG then print(\"...recieved: \"+command)
                  if command == false then continue
                  playing = check_score(map.edit_cell(command, computa.fire(command), computa.label), computa.label)
                  if not playing then return(\"<b>Computa sunk all of your battleships! You lose!</b>\")
                  ai_turn = false
                  wait(1)
                  if not globals.DEBUG then clear_screen
              end while
          end while
      end function
      
      print_logo
      return battleship
  end function
  ////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////
  ///////////////////////////BLACKJACK/////////////////////////////
  ////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////
  g2 = function()
      // Jokers Wild Blackjack by Plu70 (aka raal, aka jhook777)
      // feel free to use the deck in your own games!
      //localhost = get_shell
      //localmachine = localhost.host_computer
  
    // START 3nigma DECK /////////////////////////////////
    RC = \"<color=red>\"
    BC = \"<color=#606060>\"
    GC = \"<color=green><b>\"
    OC = \"<color=#FF8400FF>\"
    CW = \"<color=white>\"
    CLB = \"<color=#2382FFFF><b>\"
    CC = \"</color>\"
    SU = [\"V\",\"^\",\"+\",\"&\"] // ace: heart, spade, diamond, club; index: 1, 14, 27, 40
    //cards = params[0].split(\",\")
    //cards.pull
    //num_cards = cards.len - 1
    Deck = {}
    i = 1
    C = null
    Deck[0] = RC+\" _____ \"+CC+\"::\"+RC+\"|@  .^|\"+CC+\"::\"+BC+\"| @ {)|\"+CC+\"::\"+RC+\"|   $$|\"+CC+\"::\"+BC+\"|  *__|\"+CC+\"::\"+RC+\"|__JJ[|\"+CC
    for S in SU
      if S == \"V\" or S == \"+\" then C = RC
      if S == \"^\" or S == \"&\" then C = BC
      for N in range(1,13)
        if N == 1 and S == \"V\" then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|A_ _ |\"+CC+\"::\"+C+\"|( v )|\"+CC+\"::\"+C+\"| \\ / |\"+CC+\"::\"+C+\"|  .  |\"+CC+\"::\"+C+\"|____V|\"+CC
        if N == 1 and S == \"^\" then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|A .  |\"+CC+\"::\"+C+\"| /.\\ |\"+CC+\"::\"+C+\"|(_._)|\"+CC+\"::\"+C+\"|  |  |\"+CC+\"::\"+C+\"|____V|\"+CC
        if N == 1 and S == \"+\" then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|A ^  |\"+CC+\"::\"+C+\"| / \\ |\"+CC+\"::\"+C+\"| \\ / |\"+CC+\"::\"+C+\"|  .  |\"+CC+\"::\"+C+\"|____V|\"+CC
        if N == 1 and S == \"&\" then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|A _  |\"+CC+\"::\"+C+\"| ( ) |\"+CC+\"::\"+C+\"|(_'_)|\"+CC+\"::\"+C+\"|  |  |\"+CC+\"::\"+C+\"|____V|\"+CC
        if N == 2 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|2    |\"+CC+\"::\"+C+\"|  \"+S+\"  |\"+CC+\"::\"+C+\"|     |\"+CC+\"::\"+C+\"|  \"+S+\"  |\"+CC+\"::\"+C+\"|____Z|\"+CC
        if N == 3 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|3    |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|     |\"+CC+\"::\"+C+\"|  \"+S+\"  |\"+CC+\"::\"+C+\"|____E|\"+CC
        if N == 4 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|4    |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|     |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|____h|\"+CC
        if N == 5 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|5    |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|  \"+S+\"  |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|____S|\"+CC
        if N == 6 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|6    |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|____9|\"+CC
        if N == 7 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|7    |\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|____L|\"+CC
        if N == 8 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|8    |\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"| \"+S+\" \"+S+\" |\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|____8|\"+CC
        if N == 9 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|9    |\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|____6|\"+CC
        if N == 10 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|10 \"+S+\" |\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|\"+S+\" \"+S+\" \"+S+\"|\"+CC+\"::\"+C+\"|___0I|\"+CC
        if N == 11 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|J  ww|\"+CC+\"::\"+C+\"| \"+S+\" {)|\"+CC+\"::\"+C+\"|   % |\"+CC+\"::\"+C+\"|   % |\"+CC+\"::\"+C+\"|__%%[|\"+CC
        if N == 12 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|Q  ww|\"+CC+\"::\"+C+\"| \"+S+\" {(|\"+CC+\"::\"+C+\"|   %%|\"+CC+\"::\"+C+\"|  %%%|\"+CC+\"::\"+C+\"|_%%%O|\"+CC
        if N == 13 then Deck[i] = C+\" _____ \"+CC+\"::\"+C+\"|K  WW|\"+CC+\"::\"+C+\"| \"+S+\" {)|\"+CC+\"::\"+C+\"|   %%|\"+CC+\"::\"+C+\"|  %%%|\"+CC+\"::\"+C+\"|_%%%>|\"+CC
        i = i+1
      end for
    end for
    // END 3nigma DECK  ////////////////
  
    // START display ///
    send_display = function(cards)
      cards = cards.split(\",\")
      cards.pull
      line = range(0,5)
      display = range(0,5)
      for e in line
        for card in cards
          //if card == \"0\" then continue
          cardf = Deck[card.val].split(\"::\")
          if display[e] == e then
            display[e] = cardf[e]
          else
            display[e] = display[e] + \" \" + cardf[e]
          end if
        end for
      end for
      for l in display
        print(l)
      end for
    end function
    // END display ////
  
    // END client services ///  split here!
  
    // START server ///
    // START DECK ////////////////////////
    deck = {}
    suits = [\"hearts\",\"spades\",\"diamonds\",\"clubs\"]
    trumps = [\"jack\",\"queen\",\"king\"]
    deck[0] = {\"joker\":\"joker\"}
    i = 1
    for s in suits
      if i == 1 or i == 14 or i == 27 or i == 40 then
        deck[i] = {\"ace\":s}
        i =  i + 1
      end if
      for r in range(2,10)
        deck[i] = {r:s}
        i = i + 1
      end for
      for t in trumps
        deck[i] = {t:s}
        i = i + 1
      end for
    end for
    //END DECK ////////////////////////
  
  
    //for c in deck
    //	print(c.value)
    //end for
    print(\"Shuffling...\")
    deck.shuffle
    //for c in deck
    //	print(c.value)
    //end for
    print(\"Shuffling...\")
    deck.shuffle
    //for c in deck
    //	print(c.value)
    //end for
  
    player = {}
    player.balance = 100
    player.bet = 0
    player.hand = []
    player.total = 0
    player.has_ace = 0
  
    player.purge = function ()
      flush = self.hand.len
      for c in range(0, flush)
        self.hand.pop
      end for
      self.has_ace = 0
      self.total = 0
    end function
  
    player.calculate = function()
      //print(dealer.hand)
      total = 0
      player.has_ace = 0
      hand = player.hand
      for card in hand
        card = card.indexes
        card = card.pull
        //print(card)
        if card == \"joker\" then
          //player.hand.pull
          //player.hand.pull
          return 21
        end if
        if card == \"ace\" then
          total = total + 11
          player.has_ace = player.has_ace + 1
        else
          if card == \"jack\" or card == \"queen\" or card == \"king\" then
            total = total + 10
          else
            total = total + card
          end if
          //print(total)
        end if
      end for
      //print(total)
      if total < 1 then return(\"Stack error!\")
      return total
    end function
  
    player.hit = function()
      if player.total == 21 then return false
      if player.total > 21 then
        if player.has_ace then
          while player.has_ace
            player.total = player.total - 10
            player.has_ace = player.has_ace - 1
          end while
          print(\"total: \" + player.total + \" (ace used)\")
        else
          print(CLB+\"player busts at: \"+C+player.total)
          return false
        end if
      end if
      if player.total >= 21 then return false
      hit = user_input(\"[hit/stay/double]:> \")
      if hit == \"hit\" then
        return true
      end if
      if hit == \"stay\" or hit == \"0\" then
        print(CLB+\"player stays at: \"+C+player.total)
        wait(.5)
        return false
      end if
      if hit == \"double\" then
        player.bet = player.bet + player.bet
        return 2
      end if
      return true
    end function
  
    player.show_hand = function()
      hnd = player.hand
      c2 = \"0\"
      for c in hnd
        v = c.indexes
        v = v.pull
        s = c.values
        s = s.pull
        if v == \"ace\" then v = 1
        if v == \"jack\" then v = 11
        if v == \"queen\" then v = 12
        if v == \"king\" then v = 13
        if v > 0 then v = v
        //print(s)
        if s == \"hearts\" then s = 0
        if s == \"spades\" then s = 13
        if s == \"diamonds\" then s = 26
        if s == \"clubs\" then s = 39
        //print(\"v:\"+v+\" s:\"+s)
        c1 = v + s
        c2 = c2 +\",\"+ c1
      end for
  
      //print(\"debug: \"+c2)
      //localhost.launch(localmachine.current_path+\"/3deck\", c2)
      send_display(c2)
      //player.hand.pull
      //player.hand.pull
    end function
  
    dealer = {}
    dealer.hand = []
    dealer.total = 0
    dealer.has_ace = 0
  
    dealer.purge = function ()
      flush = self.hand.len
      for c in range(0, flush)
        self.hand.pop
      end for
      self.has_ace = 0
      self.total = 0
    end function
  
    dealer.calculate = function()
      //print(dealer.hand)
      total = 0
      dealer.has_ace = 0
      hand = dealer.hand
      for card in hand
        card = card.indexes
        card = card.pull
        //print(card)
        if card == \"joker\" then
          //dealer.hand.pull
          //dealer.hand.pull
          return 21
        end if
        if card == \"ace\" then
          total = total + 11
          dealer.has_ace = dealer.has_ace + 1
        else
          if card == \"jack\" or card == \"queen\" or card == \"king\" then
            total = total + 10
          else
            total = total + card
          end if
          //print(total)
        end if
      end for
      //dealer.hand.pull
      //dealer.hand.pull
      //print(total)
      if total < 1 then return(\"Stack error!\")
      return total
    end function
  
    dealer.hit = function()
      if dealer.total == 21 then return false
    //	if dealer.total > 21 then
    //		while dealer.has_ace
    //			dealer.total = dealer.total - 10
    //			dealer.has_ace = dealer.has_ace - 1
    //		end while
    //	end if
      if dealer.total >= 16 then
        while (dealer.has_ace and dealer.total >= 16)
          dealer.total = dealer.total - 10
          dealer.has_ace = dealer.has_ace - 1
        end while
        if dealer.total >= 16 then return false
      end if
      return true
    end function
  
    dealer.show_hand = function()
      hnd = dealer.hand
      c2 = \"0\"
      for c in hnd
        v = c.indexes
        v = v.pull
        s = c.values
        s = s.pull
        if v == \"ace\" then v = 1
        if v == \"jack\" then v = 11
        if v == \"queen\" then v = 12
        if v == \"king\" then v = 13
        if v > 0 then v = v
        //print(s)
        if s == \"hearts\" then s = 0
        if s == \"spades\" then s = 13
        if s == \"diamonds\" then s = 26
        if s == \"clubs\" then s = 39
        //print(\"v:\"+v+\" s:\"+s)
        c1 = v + s
        c2 = c2 +\",\"+ c1
      end for
  
        //print(\"debug: \"+c2)
      //localhost.launch(localmachine.current_path+\"/3deck\", c2)
      send_display(c2)
    end function
  
  
    deal = function(pass_deck)
      i=1
      pd = pass_deck
      print(\"Shuffling...\")
      pd.shuffle
      print(\"Dealing...\")
      wait(.5)
      clear_screen
      dealer.hand.push(pd[i])
      dealer.hand.push(pd[i+1])
      dealer.show_hand
      dealer.total = dealer.calculate
      print(CW+\"dealer: \" +C+ dealer.total + \" \" + pd[i] + \" | \" + pd[i+1])
      i = i + 2
      print(GC+\"-------------------------------------------\"+C)
      player.hand.push(pd[i])
      player.hand.push(pd[i+1])
      player.total = player.calculate
      print(CLB+\"player: \" +C+ player.total + \" \" + pd[i] + \" | \" + pd[i+1])
      player.show_hand
      i = i + 2
      print
      if player.total == 21 then return 3
      hitting = true
      while hitting
        hitting = player.hit
        if hitting then
          if hitting == 2 then
            hitting = false
            print(CLB+\"player doubles: \"+C)
            wait(.5)
          else
            print(CLB+\"player hits: \"+C)
            wait(.5)
          end if
          player.hand.push(pd[i])
          player.total = player.calculate
          clear_screen
          dealer.show_hand
          print(CW+\"dealer: \" +C+ dealer.total)
          print(GC+\"-------------------------------------------\"+C)
          print(CLB+\"player: \" +C+ player.total)
          player.show_hand
          i = i + 1
        end if
      end while
  
      if player.total > 21 then return false
      print(GC+\"-------------------------------------------\"+C)
      hitting = true
      while hitting
        hitting = dealer.hit
        if hitting then
          dealer.hand.push(pd[i])
          dealer.total = dealer.calculate
          clear_screen
          print(CW+\"dealer hits: \"+C)
          dealer.show_hand
          print(CW+\"dealer: \" +C+ dealer.total)
          print(GC+\"-------------------------------------------\"+C)
          print(CLB+\"player: \" +C+ player.total)
          player.show_hand
  
          wait(.5)
          i = i + 1
        else
          print(char(10)+CW+\"dealer stays at: \" +C+ dealer.total)
          wait(.5)
        end if
      end while
  
      if dealer.total > 21 then
        print(\"dealer<b> busts</b>.\")
        return true
      end if
      outcome = null
      if dealer.total > player.total then
        outcome = false
      else
        if dealer.total ==  player.total then
          outcome = 2
        else
          outcome = true
        end if
      end if
      return(outcome)
    end function
  
    blackjack = function(game_deck)
      d = game_deck
      playing = true  // this never gets set to false
      while playing
        d.shuffle
        if player.balance < 0 then
          print(\"Oh No! You owe the mob money! Run for your life!\")
          wait(2)
          return(\"You didn't get away! Your legs are broken, encased in cement and you are tossed in the river.\\nGame over!\")
        end if
        if player.balance < 1 then return(\"You're broke! You have no more bucks to give.\\nGame over!\")  // exit condition 1
        print
        bet = user_input(\"Place yer bet! [balance: <b>\" + player.balance + \"</b>]\\n  \")
        if bet == \"q\" or bet == \"Q\" or bet == \"quit\" or bet == \"exit\" then break  // exit condition 2
        if bet.val > 0 and bet.val <= player.balance then
          print(\"Bet of <b>\"+bet.val+\"</b> bucks placed.\")
          player.bet = bet.val
          result = deal(d)
          dealer.purge
          player.purge
          if result then
            if result == 2 then
              print(\"<b>Push!</b>\\n [balance unchanged]\")
            else
              if result == 3 then
                print(\"Blackjack! Paying time-and-a-half. [<b>\" + floor(player.bet * 1.5) + \" </b>bucks credited to balance]\")
                player.balance = player.balance + floor(player.bet * 1.5)
              else
                print(\"<b>You win!</b>\\n [<b>\" + player.bet + \" </b>bucks credited to balance]\")
                player.balance = player.balance + player.bet
              end if
            end if
          else
            print(\"<b>You lose!</b>\\n [<b>\" + player.bet + \" </b>bucks debited from balance]\")
            player.balance = player.balance - player.bet
          end if
        else
          print(\"Bet must be between 1 and \"+player.balance+\" or [q]uit.\")
        end if
      end while
    end function
  
    return blackjack(deck)
  end function
  ///////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////
  ///////////////////////////////////////DRUGWARS//////////////
  ////////////////////////////////////////////////////////////
  g3 = function()
      // drug wars v 0.2 by Plu70
      //
      //
      //
  
      // game time constants
      globals.TIMELIMIT = 31
      globals.GAMETIME  =  0
      globals.GOAL = \"1337331\"
      
      // class player
      PLAYER = {} 
      PLAYER.location=\"\"
      PLAYER.inventory_size=100
      //PLAYER.inventory_contents=[]
      PLAYER.heat=0
      PLAYER.event_status=\"\"
      
      //////////////// GRAPHICS /////////////////
      
      colorCyan = \"<color=#00FFFF><b>\"
      CT = \"</b></color>\"
      
      logo = [\"D\",\"R\",\"U\",\"G\",\"W\",\"A\",\"R\",\"S\"]
      
      officerHardassSprite = \"
                            _______________
                            \\      __      /         __
                             \\_____()_____/         /  )
                             '============`        /  /
                              #---\\  /---#        /  /
                             (# @\\| |/@  #)      /  /
                              \\   (_)   /       /  /
                              |\\ '---` /|      /  /
                      _______/ \\\\_____// \\____/ o_|
                     /       \\  /     \\  /   / o_|
                    /|           o|        / o_| \\
                   / |  _____     |       / /   \\ \\
                  /  |  |===|    o|      / /\\    \\ \\
                 |   |   \\@/      |     / /  \\    \\ \\
                 |   |___________o|__/----)   \\    \\/
                 |   '              ||  --)    \\     |
                 |__________________||  --)     \\    /
                     |           o|   ''''   |   \\__/
                     |            |          |
                       \"\"Officer Hardass\"\" Img by Rosebud\"
      
      
                                              
      deaSprite = \"
         Art by Joan G. Stark
                 _.---._
              .-' ((O)) '-.
               \\ _.\\_/._ /
                /..___..\\
                ;-.___.-;
               (| e ) e |)     .;.
                \\  /_   /      ||||
                _\\__-__/_    (\\|'-|
              /` / \\V/ \\ `\\   \\ )/
             /   \\  Y  /   \\  /=/
            /  |  \\ | / {}  \\/ /
           /  /|   `|'   |\\   /
           \\  \\|    |.   | \\_/
            \\ /\\    |.   |
             \\_/\\   |.   |
             /)_/   |    |
            // ',__.'.__,'
           //   |   |   |
          //    |   |   |
         (/     |   |   |
                |   |   |
                | _ | _ |
                |   |   |
                |   |   |
                |   |   |
          jgs   |___|___|
                /  J L  \\
               (__/   \\__)\"
      
      
                      fbiSprite = \"
                      FBI
                              _ _.-'`-._ _
                              ;.'________'.;
                  _________n.[____________].n_________
                  |''_''_''_''||==||==||==||''_''_''_'']
                  |'''''''''''||..||..||..||'''''''''''|
                  |LI LI LI LI||LI||LI||LI||LI LI LI LI|
                  |.. .. .. ..||..||..||..||.. .. .. ..|
                  |LI LI LI LI||LI||LI||LI||LI LI LI LI|
              ,,;;,;;;,;;;,;;;,;;;,;;;,;;;,;;,;;;,;;;,;;,,
              ;;jgs;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      \"
      
      
      
                      elGuapoSprite = \"
                      .------\\ /------.
                      |       -       |
                      |               |
                      |               |
                      |               |
                   _______________________
                   ===========.===========
                     / ~~~~~     ~~~~~ \\
                    /|     |     |\\
                    W   ---  / \\  ---   W
                    \\.      |o o|      ./
                     |                 |
                     \\    #########    /
                      \\  ## ----- ##  /
                       \\##         ##/
                        \\_____v_____/\"
      
      
              rabbitSprite = \"
                       ____...                                  
                .-'--''''.__    `.                                
               |            `    |                                
      (         `._....------.._.:          
      )         .()''        ``().                                
      '          () .=='  `===  `-.         
      . )       (         g)                                
      )         )     /        J          
      (          |.   /      . (                                  
      $$         (.  (_'.   , )|`                                 
      ||         |\\`-....--'/  ' \\                                
      /||.         \\\\ | | | /  /   \\.                              
      //||(\\         \\`-===-'  '     \\o.                            
      .//7' |)         `. --   / (     OObaaaad888b.                 
      (<<. / |     .a888b`.__.'d\\     OO888888888888a.               
      \\  Y' |    .8888888aaaa88POOOOOO888888888888888.              
      \\  \\ |   .888888888888888888888888888888888888b              
      |   |  .d88888P88888888888888888888888b8888888.             
      b.--d .d88888P8888888888888888a:f888888|888888b             
      88888b 888888|8888888888888888888888888\\8888888\"
      
      
      
      downTownSprite = \"
              __   __                     ___      _
             |  | |  |      /|           |   |   _/ \\_
             |  | |  |  _  | |__         |   |_-/     \\-_     _
           __|  | |  |_| | | |  |/\\_     |   |  \\     /  |___|
          |  |  | |  | | __| |  |   |_   |   |   |___|   |   |
          |  |  |^|  | ||  | |  |   | |__|   |   |   |   |   |
          |  |  |||  | ||  | |  |   | /\\ |   |   |   |   |   |
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~/  \\~~~~~~~~~~~~~~~~~~~~~~~
         ~ ~~  ~ ~~ ~~~ ~ ~ ~~ ~~ ~~ \\   \\__   ~  ~  ~~~~ ~~~ ~~
       ~~ ~ ~ ~~~ ~~  ~~ ~~~~~~~~~~ ~ \\   \\o\\  ~~ ~ ~~~~ ~ ~ ~~~
         ~ ~~~~~~~~ ~ ~ ~~ ~ ~ ~ ~ ~~~ \\   \\o\\=   ~~ ~~  ~~ ~ ~~
      ~ ~ ~ ~~~~~~~ ~  ~~ ~~ ~ ~~ ~ ~ ~~ ~ ~ ~~ ~~~ ~ ~ ~ ~ ~~~~\"
      
      
      villaSprite = \"
                             X_x
                            / \\\\\\
                            |n| |
                          )(|_|-'X
                         /  \\\\Y// \\
                         |A | | |A|
                         |  | | |_|
                  )(__X,,|__|MEB;;;-,)(,
                 /  \\\\\\;;;;;;;;;;;;/    \\
                 |A | |            | U  |
               )_|  | |____)-----( |    |
              ///|__|-'////       \\|___)=(__X
             /////////////         \\///   \\/ \\
             |           |  U    U |//     \\u|
             |   )_,-,___|_)=(     | |  U  |_|_X
             |  ///   \\\\|//   \\    | |  __ |/// \\
           )_')(//     \\Y/     >---)=( /  \\|  | |-----------------..,
          //// ,\\ u   u |   u /////   \\|  ||__|A|----------------.., \\,
         |  | .. |      |    ///// ,-, \\__||--------------------.., \\, \\,
      ---'--'_::_|______'----| u | | | |-----------------------.., \\, \\, \\,
                             |___|_|_|_|----------------------.., \\, \\, \\, \\,
      -------------------------------------------------------.., \\, \\, \\, \\, \\
                                                                        \\Valkyrie\"
      
      
      gcccSprite = \"
                                                                |>>>
                         _                      _                |
          ____________ .' '.    _____/----/-\\ .' './========\\   / \\
         //// ////// /V_.-._\\  |.-.-.|===| _ |-----| u    u |  /___\\
        // /// // ///==\\ u |.  || | ||===||||| |T| |   ||   | .| u |_ _ _ _ _ _
       ///////-\\////====\\==|:::::::::::::::::::::::::::::::::::|u u| U U U U U
       |----/\\u |--|++++|..|'''''''''''::::::::::::::''''''''''|+++|+-+-+-+-+-+
       |u u|u | |u ||||||..|              '::::::::'           |===|>=== _ _ ==
       |===|  |u|==|++++|==|              .::::::::.           | T |....| V |..
       |u u|u | |u ||HH||         \\|/    .::::::::::.
       |===|_.|u|_.|+HH+|_              .::::::::::::.              _
                      __(_)___         .::::::::::::::.         ___(_)__
      ---------------/  / \\  /|       .:::::;;;:::;;:::.       |\\  / \\  \\-------
      ______________/_______/ |      .::::::;;:::::;;:::.      | \\_______\\________
      |       |     [===  =] /|     .:::::;;;::::::;;;:::.     |\\ [==  = ]   |
      |_______|_____[ = == ]/ |    .:::::;;;:::::::;;;::::.    | \\[ ===  ]___|____
           |       |[  === ] /|   .:::::;;;::::::::;;;:::::.   |\\ [=  ===] |
      _____|_______|[== = =]/ |  .:::::;;;::::::::::;;;:::::.  | \\[ ==  =]_|______
       |       |    [ == = ] /| .::::::;;:::::::::::;;;::::::. |\\ [== == ]      |
      _|_______|____[=  == ]/ |.::::::;;:::::::::::::;;;::::::.| \\[  === ]______|_
         |       |  [ === =] /.::::::;;::::::::::::::;;;:::::::.\\ [===  =]   |
      ___|_______|__[ == ==]/.::::::;;;:::::::::::::::;;;:::::::.\\[=  == ]___|_____\"
      
      shabbyTownSprite = \"
                    )
                   (      _[]_         (
           __[]___[]___[]/____\\_[]_    )
          /______________|[][]|____\\  (
          |[][]|[][]|[][]|[][]|[][]|__[]_
          |  /\\|/\\  |  /\\|  /\\|/\\  |_____\\
          |[]|||||[]|[]|||[]|||||[]|[_]|||
        ===================================
        -  -  -  -  -  -  -  -  -  -  -  -  -
      =========================================   Tom Harvey\"
      
      districtSprite = \"
                        \\  |  /         ___________
         ____________  \\ \\_# /         |  ___      |       _________
        |            |  \\  #/          | |   |     |      | = = = = |
        | |   |   |  |   \\\\#           | |`v'|     |      |         |
        |            |    \\#  //       |  --- ___  |      | |  || | |
        | |   |   |  |     #_//        |     |   | |      |         |
        |            |  \\\\ #_/_______  |     |   | |      | |  || | |
        | |   |   |  |   \\\\# /_____/ \\ |      ---  |      |         |
        |            |    \\# |+ ++|  | |  |~~~~~~| |      | |  || | |
        |            |    \\# |+ ++|  | |  |~~~~~~| |      | |  || | |
      ~~|    (~~~~~) |~~~~~#~| H  |_ |~|  | |||| | |~~~~~~|         |
        |    ( ||| ) |     # ~~~~~~    |  | |||| | |      | ||||||| |
        ~~~~~~~~~~~~~________/  /_____ |  | |||| | |      | ||||||| |
                                       ~~~~~~~~~~~~~      | ||||||| |\"
      
      
      shadyAcresSprite = \"
        ~         ~~          __
             _T      .,,.    ~--~ ^^
       ^^   // \\                    ~
            ][O]    ^^      ,-~ ~
         /''-I_I         _II____
      __/_  /   \\ ______/ ''   /'\\_,__
        | II--'''' \\,--:--..,_/,.-{ },
      ; '/__\\,.--';|   |[] .-.| O{ _ }
      :' |  | []  -|   ''--:.;[,.'\\,/
      '  |[]|,.--'' '',   ''-,.    |
        ..    ..-''    ;       ''. '  Steven Maddison\"
      
      lasGreygasSprite = \"
                                       .''.
             .''.             *''*    :_\\/_:     . 
            :_\\/_:   .    .:.*_\\/_*   : /\\ :  .'.:.'.
        .''.: /\\ : _\\(/_  ':'* /\\ *  : '..'.  -=:o:=-
       :_\\/_:'.:::. /)\\*''*  .|.* '.\\'/.'_\\(/_'.':'.'
       : /\\ : :::::  '*_\\/_* | |  -= o =- /)\\    '  *
        '..'  ':::'   * /\\ * |'|  .'/.\\'.  '._____
            *        __*..* |  |     :      |.   |' .---'|
             _*   .-'   '-. |  |     .--'|  ||   | _|    |
          .-'|  _.|  |    ||   '-__  |   |  |    ||      |
          |' | |.    |    ||       | |   |  |    ||      |
       ___|  '-'     '    ''      '-'   '-.'    '`      |____
      jgs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      \"
      capitolSprite = \"
                                   ^
                      _______     ^^^
                     |xxxxxxx|  _^^^^^_
                     |xxxxxxx| | [][]  |
                  ______xxxxx| |[][][] |
                 |++++++|xxxx| | [][][]|      
                 |++++++|xxxx| |[][][] |
                 |++++++|_________ [][]|
                 |++++++|=|=|=|=|=| [] |
                 |++++++|=|=|=|=|=|[][]|
      ___________|++HH++|  _HHHH__|   _________   _________  _________
               _______________   ______________      ______________
      __________________  ___________    __________________    ____________\"
      
      
      
      
      /////////////////////////////////////////////
      
      ////// DRUGS /////////
      drug = {}
      drug.price=0
      drug.size=0
      drug.event_status=\"\"
      drug.availability=1
      drug.held=0
      drug.buy = function(amount)  // handles moving inventory. does not handle payment. takes player object, integer
          if typeof(amount) != \"number\" or amount < 1 or amount > self.availability then return 0
          if player.cash < self.cost * amount then return 0
          if self.size * amount <= player.inventory_size then self.held = self.held + amount else return 0
          player.debit( (self.cost * amount) )
          player.update_inventory( \"in\", (self.size * amount) )
          self.availability = self.availability - amount
          return 1
      end function 
      drug.sell = function(amount) // handles moving inventroy. does not handle payment. takes player object, integer
          if typeof(amount) != \"number\" or amount < 1 then return 0
          if self.held >= amount then self.held = self.held - amount else return 0
          player.credit( (self.cost * amount) )
          player.update_inventory(\"out\", self.size * amount)
          self.availability = self.availability + amount
          return 1
      end function
      
      //
      
      cannabis = new drug
      cannabis.name = \"cannabis\"
      cannabis.price = 100
      cannabis.size = 4
      cannabis.cost = 100
      cannabis.icon = \"<color=green><b>_\\||/_</b></color>\"
      
      mushrooms = new drug
      mushrooms.name = \"mushrooms\"
      mushrooms.price = 50
      mushrooms.size = 2
      mushrooms.cost = 50
      mushrooms.icon = \"<color=white><b>.<color=red>`<color=white>||</color>`</color>.</b></color>\"
      
      molly = new drug
      molly.name = \"molly\"
      molly.price = 20
      molly.size = 1
      molly.cost = 20
      molly.icon = \"<color=orange><b>..(o).</b></color>\"
      
      cocaine = new drug
      cocaine.name = \"cocaine\"
      cocaine.price = 500
      cocaine.size = 10
      cocaine.cost = 500
      cocaine.icon = \"<color=white><b>.[==].</b></color>\"
      
      heroin = new drug
      heroin.name = \"heroin\"
      heroin.price = 1000
      heroin.size = 20
      heroin.cost = 1000
      heroin.icon = \"<color=#272626ff><b>.====.</b></color>\"
      
      lean = new drug
      lean.name = \"lean\"
      lean.price = 300
      lean.size = 4
      lean.cost = 300
      lean.icon = \"<color=purple><b>.<u>|~~|</u>.</b></color>\"
      
      crack = new drug
      crack.name = \"crack\"
      crack.price = 200
      crack.size = 5
      crack.cost = 200
      crack.icon = \"<b><color=white>.<*<*></b></color>\"
      
      acid = new drug
      acid.name = \"acid\"
      acid.price = 400
      acid.size = 3
      acid.cost = 400
      acid.icon = \"<b><color=blue>.{#}..</b></color>\"
      _drogas = [cannabis,mushrooms,molly,cocaine,heroin,lean,crack,acid]
      
      //////// END DRUGS /////////
      
      //////// NEIGHBORHOODS /////////
      
      neighborhood = {}
      neighborhood.name=\"\"
      neighborhood.wealth=\"\"
      neighborhood.population=\"\"
      neighborhood.drug_modifiers=\"\"
      neighborhood.event_status=\"\"
      
      downtown = new neighborhood
      downtown.name = \"Downtown\"
      downtown.wealth = 10000
      downtown.population = 1000
      downtown.drug_modifiers =    {\"cannabis\":\"medium\",\"mushrooms\":\"medium\",\"molly\":\"medium\",\"cocaine\":\"high\",\"heroin\":\"high\",\"lean\":\"medium\",\"crack\":\"medium\",\"acid\":\"medium\"}
      downtown.sprite = downTownSprite
      
      villa = new neighborhood
      villa.name = \"Greyton's Villa\"
      villa.wealth = 50000
      villa.population = 100
      villa.drug_modifiers =      {\"cannabis\":\"low\",\"mushrooms\":\"low\",\"molly\":\"low\",\"cocaine\":\"high\",\"heroin\":\"high\",\"lean\":\"medium\",\"crack\":\"low\",\"acid\":\"medium\"}
      villa.sprite = villaSprite
      
      gccc = new neighborhood
      gccc.name = \"Grey County Community College\"
      gccc.wealth = 5000
      gccc.population = 3000
      gccc.drug_modifiers =       {\"cannabis\":\"high\",\"mushrooms\":\"high\",\"molly\":\"medium\",\"cocaine\":\"medium\",\"heroin\":\"medium\",\"lean\":\"medium\",\"crack\":\"medium\",\"acid\":\"low\"}
      gccc.sprite = gcccSprite
      
      shabbytown = new neighborhood
      shabbytown.name = \"Shabbytown\"
      shabbytown.wealth = 2000
      shabbytown.population = 1000
      shabbytown.drug_modifiers = {\"cannabis\":\"medium\",\"mushrooms\":\"medium\",\"molly\":\"medium\",\"cocaine\":\"low\",\"heroin\":\"medium\",\"lean\":\"high\",\"crack\":\"high\",\"acid\":\"medium\"}
      shabbytown.sprite = shabbyTownSprite
      
      district = new neighborhood
      district.name = \"District 108\"
      district.wealth = 3500
      district.population = 500
      district.drug_modifiers =  {\"cannabis\":\"low\",\"mushrooms\":\"medium\",\"molly\":\"low\",\"cocaine\":\"medium\",\"heroin\":\"high\",\"lean\":\"high\",\"crack\":\"high\",\"acid\":\"medium\"}
      district.sprite = districtSprite
      
      shady = new neighborhood
      shady.name = \"Shady Acres\"
      shady.wealth = 8000
      shady.population = 750
      shady.drug_modifiers =    {\"cannabis\":\"high\",\"mushrooms\":\"low\",\"molly\":\"high\",\"cocaine\":\"medium\",\"heroin\":\"low\",\"lean\":\"medium\",\"crack\":\"medium\",\"acid\":\"medium\"}
      shady.sprite = shadyAcresSprite
      
      greygas = new neighborhood
      greygas.name = \"Las Greygas\"
      greygas.wealth = 10000
      greygas.population = 3000
      greygas.drug_modifiers =  {\"cannabis\":\"low\",\"mushrooms\":\"high\",\"molly\":\"high\",\"cocaine\":\"high\",\"heroin\":\"low\",\"lean\":\"low\",\"crack\":\"medium\",\"acid\":\"high\"}
      greygas.sprite = lasGreygasSprite
      
      capitol = new neighborhood
      capitol.name = \"Capitol Heights\"
      capitol.wealth = 10000
      capitol.population = 1500
      capitol.drug_modifiers =  {\"cannabis\":\"medium\",\"mushrooms\":\"medium\",\"molly\":\"medium\",\"cocaine\":\"high\",\"heroin\":\"medium\",\"lean\":\"low\",\"crack\":\"medium\",\"acid\":\"low\"}
      capitol.sprite = capitolSprite
      
      _hoods = [ downtown, villa, gccc, shabbytown, district, shady, greygas, capitol ]
      if DEBUG then
          for h in _hoods
              print h.name // debug
          end for
      end if
      /////// END NEIGHBORHOODS ///////
      
      /////// EVENTS ///////////////
      event = {}
      event.names=[\"Officer_Hardass\",\"The_DEA\",\"The_FBI\",\"El_Guapo\",\"Rabbit\"]
      //event.affects = [\"player\", \"drug\", \"neighborhood\"]
      //event.effect = [\"price\", \"availability\", \"heat\",\"shop\"]
      event.Rabbit = function()
          print
          print rabbitSprite
          print
          print \"A shadow fellow pulls you into an alley and offers you a deal.\"
          print \"<color=yellow>Wanna buy a trenchcoat for an extra 20 inventory? $1000 cash, bub.\"
          print
          choice = user_input(\"[1] or Yes (anything else for no):> \")
          if choice == \"1\" or choice.lower == \"yes\" then 
              if player.cash >= 1000 then 
                  print
                  print \"<color=yellow>Here you go. Hmm, looks good on you.\"
                  player.cash = player.cash - 1000
                  player.inventory_size = player.inventory_size + 20
                  player.event_status = \"none\"
              else 
                  print
                  print \"<color=yellow>You don't have the cash, bub!\"
              end if
          else 
              print
              print \"<color=yellow>A'ight, cool. I know someone else that wants it.\"
          end if
          return null
      end function 
      event.El_Guapo = function()
          print 
          print elGuapoSprite
          print
          print \"El Guapo's narco sub has made berth. \"
          print \"The market has been flooded with cheap drugs!\"
          print \"Deals like these won't last long!\"
          player.event_status = \"none\"
          return user_input(\"press <<b>enter</b>> to continue\"+char(10))
      end function 
      event.The_FBI = function()
          print 
          print fbiSprite
          print
          print \"The FBI opened an investigation into you! \"
          print \"They are demanding $\"+ceil(player.cash / 10)+\" in bribes to avoid jail time!\"
          print \"You fill a duffel bag with the money and head to the FBI field office.\"
          print \"When you arrive you dump the cash on their doorstep.\"
          print \"You decide to keep the duffelbag. \"
          print \"Your inventory space has increased by 10!\"
          player.cash = ceil(player.cash / 10)
          player.inventory_size = player.inventory_size + 10
          player.event_status = \"none\"
          return user_input(\"press <<b>enter</b>> to continue\"+char(10))
      end function 
      event.The_DEA = function()
          print 
          print deaSprite
          print
          print \"The DEA made a major bust! \\nDrug availability has temporarily gone down! \\nPrices have permanently gone up!\"
          player.event_status = \"none\"
      
          return user_input(\"press <<b>enter</b>> to continue\"+char(10))
      end function 
      event.Officer_Hardass = function()
      
          print 
          print officerHardassSprite
          print
          print \"Officer Hardass caught you slinging dope and beat your ass! \"+char(10)+\"He took all your drugs and you had to bribe him with $\"+ceil(player.cash / 10)+\" to avoid jail time.\"
          print \"Barely able to stand, you wonder if you will survive another day.\"
          player.cash = player.cash - ceil(player.cash / 10)
          for d in _drogas 
              a = d.held
              d.sell(a)
              player.debit(d.cost * a)
          end for
          player.event_status = \"none\"
          return user_input(\"press <<b>enter</b>> to continue\"+char(10))
      end function 
      ////// END EVENTS //////////
      
      // win condition
      _score = function()
          if player.cash >= GOAL.to_int then return(\"You win! :]\") else return(\"You lose. :[\")
          return null
      end function
      
      // each time the player moves we tick the clock up one.
      _game_time_update = function()
          globals.GAMETIME = GAMETIME + 1
          status = null
          if GAMETIME >= TIMELIMIT then status = (_score)
          if DEBUG then print \"debug: tick\"
          if DEBUG then print \"debug: gametime: \"+GAMETIME
          player.event_status = \"none\"
          if event.names.len > 0 then
              ev = range(0,9)
              ev.shuffle 
              e = ev.pop 
              event.names.shuffle   
              if DEBUG then 
                  player.event_status = event.names.pop 
              else 
                  if e > 7 then player.event_status = event.names.pop // 20% chance
              end if
              if player.event_status == \"Rabbit\" then event.names.push(\"Rabbit\") // make sure there's always a chance to up capacity
          end if 
          return status
      end function 
      
      // drug price and availability based on popularity and population
      _update_drug_prices = function(locale)
          price = {}
          price.low = [1,1.5,2,2.5,3]
          price.medium = [3.5,4,5,6,4]
          price.high = [6.5,7,8,9,2]
      
          for d in _drogas 
              // modify prices
              r = [0,1,2,3,4]
              r.shuffle 
              if DEBUG then print \"debug: \"+d.name+char(10)+\"debug: \"+locale.name
              mod = price[locale.drug_modifiers[d.name]][r[0]]
              d.cost = d.price * mod
              d.availability = ceil(locale.population / mod)
              if player.event_status == \"El_Guapo\" then 
                  d.availability = d.availability * 2
                  d.cost = ceil(d.cost / 1.5)
              end if
              if player.event_status == \"The_DEA\" then 
                  d.price = d.price + (d.price / 10)
                  d.availability = ceil(d.availability / 2)
                  d.cost = ceil(d.cost * 1.5)
              end if 
              if DEBUG then print \"debug: cost: \"+ d.cost
              if DEBUG then print \"debug: avail: \"+ d.availability
          end for 
      end function
      
      ///////////////////////////////////////
      //////// PLAYER ONE /////////
      
      player = new PLAYER 
      player.location = downtown // player starts here
      player.inventory_size=100
      //player.inventory_contents=[]
      player.heat=0
      player.event_status=\"none\"
      player.cash = 100
      //
      player.update_location = function(moveto) // expects neighborhood object
          if DEBUG then print \"debug: moveto: \"+moveto.name // debug
          if self.location != moveto then self.location = moveto else return 0
          stat = _game_time_update
          _update_drug_prices(self.location)
          if player.event_status != \"none\" then event[player.event_status]
          return 1
      end function
      //
      player.debit = function( amount )
          if typeof(amount) != \"number\" or amount > player.cash or amount < 1 then return 0
          self.cash = self.cash - amount 
          return 1
      end function 
      player.credit = function( amount )
          if typeof(amount) != \"number\" or amount < 1 then return 0
          self.cash = self.cash + amount 
          return 1
      end function
      //
      player.update_inventory = function( direction, amount )
          if direction == \"in\" then self.inventory_size = self.inventory_size - amount
          if direction == \"out\" then self.inventory_size = self.inventory_size + amount 
          return null
      end function
      //player.property = [\"none\"]
      //player.net worth = 100
      //////////////////////////////////////
      
      move_menu = function(pr)
          print \"current location: \"+pr.location.name
          for h in _hoods
              //print h
              print \"[<b>\"+_hoods.indexOf(h)+\"</b>] - \"+h.name
          end for 
          choice = user_input(\"Move to :> \").to_int// int
          if choice == \"\" then return pr.location
          if DEBUG then print \"debug: choice: \"+choice
          if typeof(choice) == \"number\" and choice >= 0 and choice < _hoods.len then return _hoods[choice] else return pr.location // if we didn't move, return current location
      end function 
      
      drug_menu = function()
          print // something
          buf = []
          for d in _drogas
              buf.push(\"[<b>\"+_drogas.indexOf(d)+\"</b>] - \"+d.name+\" $\"+d.cost+\" \"+d.availability+\" units available, \"+d.held+\"/\"+ ( floor( player.inventory_size / d.size ) + d.held ) + \" units held \"+d.icon )
          end for 
          print format_columns(buf.join(char(10)))
          choice = user_input(\":> \")
          if choice == \"\" then return 
          if typeof(choice.to_int) == \"number\" and choice.to_int >= 0 and choice.to_int < _drogas.len and _drogas.hasIndex(choice.to_int) then return _drogas[choice.to_int] else print \"Invalid selection.\"
          return 0
      end function 
      
      
      playing = true
      
      // game loop
      while playing == true
          if not DEBUG then clear_screen
          print    
          print player.location.sprite
          print
          // show location
          print \"<u><color=#40865bff>Location: <b>\"+player.location.name+\"</b></u> <u>Days Left: <b>\"+ (31 - GAMETIME)
          // show inventory
          print \"<u><color=#40865bff>Inventory: <b>\"+player.inventory_size+\"</b> pocket space available.\"
          d_b = []
          print \"- - - - - - - - - - - - - - - - - - - -\"
          for d in _drogas
              d_b.push(  \"<u><color=#40865bff>\"+d.name.upper+\" |\"+colorCyan+d.held+CT+\"|</u> <color=red>\"+logo.pull+\"</color> [\"+d.icon+\"]\" )
          end for
          print format_columns(d_b.join(char(10)))
      
          // show cash
          print 
          print \"<color=#40865bff>Cash: <color=yellow><b>$\"+player.cash+\"</color> Goal: >= <color=yellow>\"+GOAL
          print
      
          // show prompt
          if player.event_status != \"none\" then print \"[<color=yellow>E</color>] - \"+player.event_status
          print \"[<color=white>1</color>] - Buy [<color=white>2</color>] - Sell [<color=white>3</color>] - Move [<color=white>q</color>] - quit\"
      
          // handle choices
          choice = user_input(\":> \")
      
          // quit
          if choice == \"q\" then return \"goodbye\"
      
          // handle [rabbit] event
          if choice.lower == \"e\" and player.event_status != \"none\" then 
              event[player.event_status]
              user_input(\"press <<b>enter</b>> to continue\")
              continue
          end if
      
          // -- buy drugs
          if choice == \"1\" then 
              drug_to_buy = drug_menu
              if drug_to_buy then print \"Buying \"+drug_to_buy.name else continue
              if drug_to_buy.buy(user_input(\"Amount :> \").to_int) then print \"Success.\" else print \"Failed.\"
              user_input(\"press <<b>enter</b>> to continue\")
              continue
          end if
      
          // -- sell drugs
          if choice == \"2\" then 
              drug_to_sell = drug_menu
              if drug_to_sell then print \"Selling \"+drug_to_sell.name else continue
              if drug_to_sell.sell(user_input(\"Amount :> \").to_int) then print \"Success.\" else print \"Failed.\"
              user_input(\"press <<b>enter</b>> to continue\")
              continue
          end if
      
          // -- move location // update prices, availability and location
          if choice == \"3\" then
              move = player.update_location(move_menu(player))
              if move == 1 then print \"Travelling...\" 
              if move == 0 then print \"Staying put.\"
              if typeof(move) == \"string\" then return move // game over win/lose
              user_input(\"press <<b>enter</b>> to continue\")
              continue
          end if
      
          // repeat until timelimit
          // exit with score
      end while
  end function
  
  ///////////////////////////////////////contrubutions start here///////////////////////////////////////////
  /// this is stuff that was not made by Plu70
  /// most of this will contain additions or adjustments by Plu70
  //// cotributed commands ////////////////////
  
  // glosure by rocketorbit
  command.glosure = function(arg1, arg2=0, arg3=0, arg4=0)
    Error = function(msg) //This is up to implementation to decide.
      return print(\"<color=red><noparse>\" + @msg + \"</noparse></color>\") //reference implementation simply panics. 
    end function
    tree = function(anyObject, depth = 5) //basically str() with custom depth limit, this walk the tree with recursion until everything is consumed.
      if depth == 0 then return \"...\"
      if @anyObject isa map then
        if hasIndex(anyObject, \"classID\") then return @anyObject.classID //doesnt unfold Grey Hack object anymore
        ret = []
        for pair in anyObject
          ret.push(tree(@pair.key, depth - 1) + \": \" + tree(@pair.value, depth - 1))
        end for
        return \"{\" + ret.join(\", \") + \"}\"
      else
        if @anyObject isa funcRef or anyObject isa number then return \"\" + @anyObject
        if anyObject isa string then return \"\"\"\" + anyObject + \"\"\"\"
        if anyObject isa list then
          ret = []
          for item in anyObject
            ret.push(tree(@item, depth - 1))
          end for
          return \"[\" + ret.join(\", \") + \"]\"
        end if
        if anyObject == null then return \"null\"
        return \"\" + anyObject 
      end if
    end function
    reader = function(codeStr) //code string to s-expression
      codeStr = values(codeStr)
      stack = [[]]
      while len(codeStr)
        token = []
        c = codeStr.pull
        if (\", \" + char(9) + char(10) + char(13)).indexOf(c) != null then //ignore whitespace
          continue
        else if c == \"(\" then //parse a new list
          stack.push([])
        else if c == \")\" then //end a list
          if len(stack) < 2 then return Error(\"Glosure: Error: Unbalanced parenthesis.\")
          curr = stack.pop
          stack[-1].push(curr)
        else if indexOf(\"0123456789.\", c) != null then //tokenize number
          token.push(c)
          while len(codeStr) and indexOf(\"0123456789.\", codeStr[0]) != null
            token.push(codeStr.pull)
          end while
          stack[-1].push(val(token.join(\"\")))
        else if c == \"'\" then //tokenize string
          token.push(c)
          while len(codeStr) and codeStr[0] != \"'\"
            c = codeStr.pull
            if c == \"\\\" then //\"
              if codeStr[0] == \"t\" then
                token.push(char(9))
                codeStr.pull
              else if codeStr[0] == \"n\" then
                token.push(char(10))
                codeStr.pull
              else if codeStr[0] == \"r\" then
                token.push(char(13))
                codeStr.pull
              else
                token.push(codeStr.pull)
              end if
            else
              token.push(c)
            end if
          end while
          codeStr.pull
          stack[-1].push(token.join(\"\"))
        else if c == \";\" then //ignore comment
          while len(codeStr) and codeStr[0] != char(10)
            codeStr.pull
          end while
        else //tokenize symbol
          token.push(c)
          while len(codeStr) and (\" .'();\" + char(9) + char(10) + char(13)).indexOf(codeStr[0]) == null
            token.push(codeStr.pull)
          end while
          stack[-1].push(token.join(\"\"))
        end if
      end while
      if len(stack) != 1 then return Error(\"Glosure: Error: Unbalanced parenthesis.\")
      return [\"begin\"] + stack[0]
    end function
    Env = function(__outer) //environment for Glosure, only build new environment when calling lambda.
      Error = @Error
      env = {}
      env.classID = \"env\"
      env.__outer = __outer
      env.__local = {}
      env.get = function(symbol)
        if hasIndex(self.__local, @symbol) then return @self.__local[@symbol]
        if self.__outer then return @self.__outer.get(symbol)
        return Error(\"Glosure: Runtime Error: Unknown symbol '\" + symbol + \"'.\")
      end function
      env.set = function(symbol, value)
        self.__local[@symbol] = @value
        return @value
      end function
      return env
    end function
    eval = function(expr, env) //evaluate Glosure s-expression
      if not @expr isa list then
        if not @expr isa string then return @expr
        if expr[0] == \"'\" then return expr[1:] else return env.get(expr)
      end if
      if not len(expr) then return null
      first = @expr[0]
      if @first == \"def\" then //bind value to symbol
        if len(@expr) < 3 then return Error(\"Glosure: Runtime Error: def keyword requires 2 arguments.\")
        return env.set(@expr[1], eval(@expr[2], env))
      else if @first == \"if\" then //if statement
        if len(@expr) < 3 then return Error(\"Glosure: Runtime Error: if keyword requires 2 or 3 arguments.\")
        if eval(@expr[1], env) then return eval(@expr[2], env)
        if len(@expr) > 3 then return eval(@expr[3], env) else return null
      else if @first == \"while\" then //while loop, with no break keyword.
        if len(@expr) != 3 then return Error(\"Glosure: Runtime Error: while keyword requires 2 arguments.\")
        result = null
        while eval(@expr[1], env)
          result = eval(@expr[2], env)
        end while
        return @result
      else if @first == \"lambda\" then //lambda statement
        if len(@expr) < 3 then return Error(\"Glosure: Runtime Error: lambda keyword requires 2 or more arguments.\")
        if not @expr[1] isa list then return Error(\"Glosure: Runtime Error: lambda requires a list as params.\")
        return {
          \"classID\": \"lambda\",
          \"params\": @expr[1],
          \"body\": expr[2:],
          \"env\": @env,
        }
      else if @first == \"begin\" then //evaluate each argument and return the last one.
        result = null
        for stmt in expr[1:]
          result = eval(@stmt, env)
        end for
        return @result
      else if @first == \"exec\" then //interpret a string as Glosure code.
        if len(@expr) != 2 then return Error(\"Glosure: Runtime Error: exec keyword requires 1 argument.\")
        return execute(eval(@expr[1], env), env)
      else if @first == \"eval\" then //evaluate a list as Glosure code.
        if len(@expr) != 2 then return Error(\"Glosure: Runtime Error: eval keyword requires 1 argument.\")
        return eval(eval(@expr[1], env), env)
      else if @first == \"glosure\" then //build a \"glosure\"(host function), advanced feature, extremely dangerous
        if len(@expr) < 3 then return Error(\"Glosure: Runtime Error: glosure keyword requires 2 or more arguments.\")
        if not @expr[1] isa list then return Error(\"Glosure: Runtime Error: glosure requires a list as params.\")
        if len(@expr[1]) > 5 then return Error(\"Glosure: Runtime Error: glosure can only take 5 or less params.\")
        lambda = {
          \"classID\": \"lambda\",
          \"params\": @expr[1],
          \"body\": expr[2:],
          \"env\": @env,
        }
        __eval = @eval
        __env = @env
        buildGlosure = function
          __eval = @outer.__eval
          __env = @outer.__env
          lambda = @outer.lambda
          glosure0 = function()
            return __eval([lambda], __env)
          end function
          glosure1 = function(arg0)
            return __eval([lambda, @arg0], __env)
          end function
          glosure2 = function(arg0, arg1)
            return __eval([lambda, @arg0, @arg1], __env)
          end function
          glosure3 = function(arg0, arg1, arg2)
            return __eval([lambda, @arg0, @arg1, @arg2], __env)
          end function
          glosure4 = function(arg0, arg1, arg2, arg3)
            return __eval([lambda, @arg0, @arg1, @arg2, @arg3], __env)
          end function
          glosure5 = function(arg0, arg1, arg2, arg3, arg4)
            return __eval([lambda, @arg0, @arg1, @arg2, @arg3, @arg4], __env)
          end function
          if len(lambda.params) == 0 then return @glosure0
          if len(lambda.params) == 1 then return @glosure1
          if len(lambda.params) == 2 then return @glosure2
          if len(lambda.params) == 3 then return @glosure3
          if len(lambda.params) == 4 then return @glosure4
          return @glosure5
        end function
        return buildGlosure
      else if @first == \"dot\" then //invoke host method. Warning: more arguments than a method can take will result in crash and the Glosure interpreter cannot catch this error!
        length = []
        temp = function(object, method, args)
          method = @object[@method]
          return method(@object)
        end function
        length.push(@temp)
        temp = function(object, method, args)
          method = @object[@method]
          return method(@object, @args[0])
        end function
        length.push(@temp)
        temp = function(object, method, args)
          method = @object[@method]
          return method(@object, @args[0], @args[1])
        end function
        length.push(@temp)
        temp = function(object, method, args)
          method = @object[@method]
          return method(@object, @args[0], @args[1], @args[2])
        end function
        length.push(@temp)
        temp = function(object, method, args)
          method = @object[@method]
          return method(@object, @args[0], @args[1], @args[2], @args[3])
        end function
        length.push(@temp)
        temp = function(object, method, args)
          method = @object[@method]
          return method(@object, @args[0], @args[1], @args[2], @args[3], @args[4])
        end function
        length.push(@temp)
        if len(expr) < 3 then return Error(\"Glosure: Runtime Error: dot keyword requires at least 2 arguments.\")
        if len(expr) > len(length) then return Error(\"Glosure: Runtime Error: dot keyword take at most \" + (len(length) - 1) + \" params but received \" + (len(expr) - 1) + \" arguments.\")
        args = []
        for arg in expr[1:]
          args.push(eval(@arg, env))
        end for
        object = @args[0]
        method = @args[1]
        args = args[2:]
        run = @length[len(args)]
        return run(@object, @method, args)
      else if @first == \"list\" then
        args = []
        for arg in expr[1:]
          args.push(eval(@arg, env))
        end for
        return args
      else if @first == \"map\" then
        args = []
        for arg in expr[1:]
          args.push(eval(@arg, env))
        end for
        if len(args) % 2 != 0 then args.push(null) //append a null if the last one does not have a pair.
        ret = {}
        for i in range(0, len(args) - 1, 2)
          ret[@args[i]] = @args[i + 1]
        end for
        return @ret
      else if @first == \"context\" then
        return env.__local
      else
        func = eval(@first, env)
        args = expr[1:]
        evaluatedArgs = []
        if @func isa map and hasIndex(func, \"classID\") and func.classID == \"lambda\" then
          if len(args) > len(func.params) then return Error(\"Glosure: Runtime Error: calling a lambda takes at most \" + len(func.params) + \" params but received \" + len(args) + \" arguments.\")
          for arg in args
            evaluatedArgs.push(eval(@arg, env))
          end for
          while len(evaluatedArgs) < len(func.params)
            evaluatedArgs.push(null) //append null for not enough arguments
          end while
          newEnv = Env(func.env)
          for i in indexes(func.params)
            newEnv.set(@func.params[i], @evaluatedArgs[i])
          end for
          result = null
          for bodyExpr in func.body
            result = eval(@bodyExpr, newEnv)
          end for
          return @result
        else if @func isa funcRef then
          for arg in args
            evaluatedArgs.push(eval(@arg, env))
          end for
          length = []
          temp = function(args, func)
            return func()
          end function
          length.push(@temp)
          temp = function(args, func)
            return func(@args[0])
          end function
          length.push(@temp)
          temp = function(args, func)
            return func(@args[0], @args[1])
          end function
          length.push(@temp)
          temp = function(args, func)
            return func(@args[0], @args[1], @args[2])
          end function
          length.push(@temp)
          temp = function(args, func)
            return func(@args[0], @args[1], @args[2], @args[3])
          end function
          length.push(@temp)
          temp = function(args, func)
            return func(@args[0], @args[1], @args[2], @args[3], @args[4])
          end function
          length.push(@temp)
          if len(evaluatedArgs) > len(length) - 1 then return Error(\"Glosure: Runtime Error: glosure takes at most \" + (len(length) - 1) + \" params but received \" + len(evaluatedArgs) + \" arguments.\")
          run = @length[len(evaluatedArgs)]
          return run(evaluatedArgs, @func)
        end if
      end if
    end function
    GlobalEnv = function
      globalEnv = Env(null) //global and general methods do not have access to environment. those are for keywords.
      globalEnv.__local[\"&\"] = function(a, b)
        return @a and @b
      end function
      globalEnv.__local[\"|\"] = function(a, b)
        return @a or @b
      end function
      globalEnv.__local[\"!\"] = function(a)
        return not @a
      end function
      globalEnv.__local[\"==\"] = function(a, b)
        return @a == @b
      end function
      globalEnv.__local[\"!=\"] = function(a, b)
        return @a != @b
      end function
      globalEnv.__local[\">=\"] = function(a, b)
        return @a >= @b
      end function
      globalEnv.__local[\"<=\"] = function(a, b)
        return @a <= @b
      end function
      globalEnv.__local[\">\"] = function(a, b)
        return @a > @b
      end function
      globalEnv.__local[\"<\"] = function(a, b)
        return @a < @b
      end function
      globalEnv.__local[\"+\"] = function(a, b)
        return @a + @b
      end function
      globalEnv.__local[\"-\"] = function(a, b)
        return @a - @b
      end function
      globalEnv.__local[\"*\"] = function(a, b)
        return @a * @b
      end function
      globalEnv.__local[\"/\"] = function(a, b)
        return @a / @b
      end function
      globalEnv.__local[\"^\"] = function(a, b)
        return @a ^ (@b)
      end function
      globalEnv.__local[\"%\"] = function(a, b)
        return @a % @b
      end function
      globalEnv.__local.at = function(a, b)
        return @a[@b]
      end function
      globalEnv.__local.set = function(a, b, c)
        (@a)[@b] = @c
        return @c
      end function
      general = {\"active_user\": @active_user, \"bitwise\": @bitwise, \"clear_screen\": @clear_screen, \"command_info\": @command_info, \"current_date\": @current_date, \"current_path\": @current_path, \"exit\": @exit, \"format_columns\": @format_columns, \"get_ctf\": @get_ctf, \"get_custom_object\": @get_custom_object, \"get_router\": @get_router, \"get_shell\": @get_shell, \"get_switch\": @get_switch, \"home_dir\": @home_dir, \"include_lib\": @include_lib, \"is_lan_ip\": @is_lan_ip, \"is_valid_ip\": @is_valid_ip, \"launch_path\": @launch_path, \"mail_login\": @mail_login, \"nslookup\": @nslookup, \"parent_path\": @parent_path, \"print\": @print, \"program_path\": @program_path, \"reset_ctf_password\": @reset_ctf_password, \"typeof\": @typeof, \"user_bank_number\": @user_bank_number, \"user_input\": @user_input, \"user_mail_address\": @user_mail_address, \"wait\": @wait, \"whois\": @whois, \"to_int\": @to_int, \"time\": @time, \"abs\": @abs, \"acos\": @acos, \"asin\": @asin, \"atan\": @atan, \"ceil\": @ceil, \"char\": @char, \"cos\": @cos, \"floor\": @floor, \"log\": @log, \"pi\": @pi, \"range\": @range, \"round\": @round, \"rnd\": @rnd, \"sign\": @sign, \"sin\": @sin, \"sqrt\": @sqrt, \"str\": @str, \"tan\": @tan, \"yield\": @yield, \"slice\": @slice, \"params\": @params, \"globals\": @globals, \"true\": true, \"false\": false, \"null\": null}
      for method in general + string + list + map
        globalEnv.__local[@method.key] = @method.value
      end for
      return globalEnv
    end function
  
    execute = function(codeStr, env)
      return eval(reader(codeStr), env)
    end function
    repl = function(env)
      while true
        codeStr = user_input(\"</> \")
        if codeStr == \";quit\" then break
        result = eval(reader(codeStr), env)
        if @result isa string then print(result) else print(tree(@result))
      end while
    end function
  
    prepareCode = \"(def BUFFER (at globals 'BUFFER'))\" //This one is hardcoded code you can run at start up.
    if not hasIndex(globals, \"glosureEnv\") then
      globals.glosureEnv = Env(GlobalEnv)
      execute(prepareCode, glosureEnv)
      env = Env(glosureEnv)
      execute(prepareCode, env)
    end if
  
    helpMsg = \"Usage: glosure -- invoke Glosure REPL, type ;quit to quit.
  Usage: glosure [-e|exec] \"\"code\"\"  -- execute Glosure code.
  Glosure interpreter version: b14abb5. For a more detailed guide read https://github.com/rocketorbit/Glosure/blob/main/Tutorial.md
  <b>Warning: This command is a programming language! Your error may result in crash!</b>
  
  Short reference:
  (function arg1 arg2 argn) essentially behaves like function(arg1, arg2, argn) in miniscript
  This language has 7 datatypes, string number list map null are the same as GreyScript string number list map null, glosure means GreyScript function, lambda means a Glosure \"\"anonymous function\"\"
  Use 'hi' to repersent a string \"\"hi\"\"
  Use 42 to repersent a number 42, true is a predefined variable with a value 1, false is a predefined variable with a value 0.
  null is a predefined variable with a value null.
  Use (list 1 2 'a') to repersent a list [1, 2, \"\"a\"\"]
  Use (map 'a' 1 'b' 2) to repersent a map {\"\"a\"\": 1, \"\"b\"\": 2}, globals is a predefined map which references the GreyScript globals map.
  Use (def name 'value') to define a variable name with a value \"\"value\"\"
  Use (lambda (arguments) (body)) to define an anonymous lambda expression(aka function), you can bind it to a variable name with syntax like (def square (lambda (x) (* x x))). This is the only native datatype and you should NEVER pass this through API.
  Use (glosure (arguments) (body)) to define an anonymous glosure(aka GreyScript function), you can bind it to a variable name with syntax like (def square (glosure (x) (* x x))). This is only used for GreyScript interop and you should not use this when you can use lambda instead.
  Use (while expression statement) to loop without recursion.
  Use (if expression statement optional_else_statement) to use if or if-else statement.
  Use (function_name argument_1 argument_2 argument_N) to call a binded lambda or a binded glosure.
  Use (dot object method_name argument_1 argument_2 argument_N) to access a method under a grey hack object. This is dangerous and can cause crash if used incorrectly, read Manual.exe while using it.
  (at name index) essentially works like name[index], you can use it on any container.
  (set name index value) essentially works like name[index] = value, you can use it on any container. It can also used to assign any glosure to host env with globals<b>Warning: Advanced feature are not for people who dont know what they are doing! Your error will very likely result in crash!</b>
  \"
    if arg1 == \"help\" or arg1 == \"-h\" then return helpMsg
    if arg1 == \"-e\" or arg1 == \"exec\" then return execute(arg2, glosureEnv)
    return repl(glosureEnv)
  end function
  //
  // htop by redit0
  command.htop = function(arg1=0, arg2=0,arg3=0,arg4=0)
    colorize = function(num, v, perc = 0)
      p = \"\"
      if perc then p = \"%\"
      if num > 94 then return \"<color=#c30000><b>\" + v + p + \"</b></color>\"
          if num > 89 then return \"<color=#ffa500><b>\" + v + p + \"</b></color>\"
          if num > 79 then return \"<color=#dbd700><b>\" + v + p + \"</b></color>\"
      return \"<color=#85b8ff><b>\" + v + p + \"</b></color>\"
    end function
    if @arg1 != 0 then
      if [\"string\",\"number\",\"shell\",\"computer\"].indexOf(typeof(@arg1)) == null then return \"Invalid argument: \"+typeof(@arg1)+\": \"+@arg1
      top_usage = \"htop || actually htop\"+char(10)+
      \"<b>Usage: \"+colorGold+\"htop</color> -- show processes running on the active host_computer\"+char(10)+
      \"-- to end the running process, use the command:<b> purge -d [opt:name]\"+char(10)+
      \"---- or note the daemon name printed on the screen and \"+char(10)+
      \"---- remove the corresponding line from <b>/root/5hell.d</b>\"+char(10)+
      \"---- or delete the file entirely\"+char(10)+
      \"-- if the file cannot be created, then the process must be exited with <b>ctrl+c\"+char(10)+
      \"-- when glasspool is active:\"+char(10)+
      \"-- the active shell/computer is the active host_computer\"+char(10)+
      \"<b>Usage: htop -- show processes running on active host_computer\"+char(10)+
      \"--eg: htop\"+char(10)+
      \"<b>Usage: htop [#] -- show processes running on the buffer object at the specified index.\"+char(10)+
      \"--eg: htop 1\"+char(10)+
      \"<b>Usage: htop [shell|computer] -- show processes running on the piped object.\"+char(10)+
      \"--eg: clipa @B 1 | htop\"+char(10)+
      \"--eg: rsi 1 7 | htop\"
      if arg1 == \"help\" or arg1 == \"-h\" then return top_usage
      if typeof(arg1) == \"number\" then arg1 = str(arg1)
      if typeof(arg1) == \"shell\" then
        locals.top_comp = arg1.host_computer
      else if typeof(arg1) == \"computer\" then
        locals.top_comp = arg1
      else if typeof(arg1.to_int) == \"number\" then
        idx = arg1.to_int
        if idx >= 0 and idx < globals.BUFFER.len then temp_comp = globals.BUFFER[idx] else return \"BUFFER: invalid selection.\"
        if typeof(temp_comp) == \"shell\" then
          locals.top_comp = temp_comp.host_computer
        else if typeof(temp_comp) == \"computer\" then
          locals.top_comp = temp_comp
        else
          return \"BUFFER: invalid object type: \" + typeof(temp_comp)
        end if
      else
        return \"Invalid argument: \"+typeof(arg1)+\": \"+arg1
      end if
    else
      locals.top_comp = globals.localmachine
    end if
    hostname = locals.top_comp.get_name
    manager = new DaemonManager
    daemon = manager.Start(\"htop\", hostname + \" - \" + locals.top_comp.public_ip + \"::\" + locals.top_comp.local_ip)
    while (daemon and manager.Check(daemon)) or not manager.__initialized
          lines = locals.top_comp.show_procs.split(\"\\n\")[1:]
          procs = []
          users = []
          memory = 0
          cpu = 0
          admin = 0
          for line in lines
              parts = line.split(\" \")
              process = {\"user\":parts[0], \"pid\":parts[1], \"cpu\":parts[2][:-1].val, \"memory\":parts[3][:-1].val, \"command\":parts[4].replace(\"5hell\",colorRed+\"5\"+colorWhite+\"hell\")}
              procs.push(process)
          end for
          for proc in procs
              if proc.user == \"root\" and proc.command == \"dsession\" then admin = 1
              if (proc.command == \"dsession\" or proc.command == \"Xorg\") and users.indexOf(proc.user) == null then users.push(proc.user)
              memory = memory+proc.memory
              cpu = cpu+proc.cpu
          end for
          cpu_squares = ceil(20*(cpu/100))
          cpu_blanks = 20-cpu_squares
          cpu_bar = colorize(cpu,\"#\"*cpu_squares) + \"<color=#ffffff00>\" + \"#\"*cpu_blanks + \"</color>\"
          memory_squares = ceil(20*(memory/100))
          memory_blanks = 20-memory_squares
          memory_bar = colorize(memory,\"#\"*memory_squares) + \"<color=#ffffff00>\" + \"#\"*memory_blanks + \"</color>\"
          output = \"<color=#eeeeee><b><size=110%>Monitoring: \"+hostname+\"</size><size=90%>\"+char(10)+
      \"[\" + locals.top_comp.public_ip + \"] [\" + locals.top_comp.local_ip + \"]\"+char(10)+
      \"Daemon: \"+daemon+\"</size></b></color>\" + char(10)*2 +
          \"Running Processes: \" + procs.len + char(10) +
          \"Users Online: \" + users.len + char(10) +
          \"CPU Utilization: [\" + cpu_bar + \"]==[ \"+colorize(cpu,cpu,1)+\" ]\" + char(10) +
          \"RAM Utilization: [\" + memory_bar + \"]==[ \"+colorize(memory,memory,1)+\" ]\" + char(10)*2
          if admin then output = output + \"<size=140%><mark=c3000099>\" + \" \"*12 + \"<b>ADMIN ONLINE</b>\" + \" \"*12 + \"</mark></size><color=#ffffff00>|</color>\" + char(10)*2
          procList = \"<color=#666666><b><voffset=0.5em>USER<pos=130>PID<pos=210>CPU<pos=290>RAM<pos=370>COMMAND</voffset></b></color>\" + char(10)
          for proc in procs
              if proc.user == \"root\" then
                  procList = procList+colorize(99,\"root\")
              else if proc.user == \"guest\" then
                  procList = procList+\"<color=#666666><b>guest</b></color>\"
              else
                  procList = procList+colorize(1,proc.user)
              end if
              procList = procList + \"<pos=130><color=#77aa33><b>\" + proc.pid + \"</b></color><pos=210>\"+colorize(proc.cpu,proc.cpu,1)
              procList = procList + \"<pos=290>\"+colorize(proc.memory,proc.memory,1)
              procList = procList + \"<pos=370><color=#00709d><b>\" + proc.command + \"</b></color>\" + char(10)
          end for
          output = output + procList
          print(output, 1)
          wait 0.5
    end while
  end function
  
  
  
  //////// contributed shared functions ///////////////
  
  // regex engine for greyscript
  // transcribed from C code provided by Princeton U.
  // useage: re.match( String: regex pattern, Char Array (list): text to parse )
  // returns 1 if match and 0 if no match
  re = {}
  re.match = function(regexp, text) 
    if DEBUG then print(\"<b> in globals.re(gex)\")
    if regexp[0] == \"^\" then
      regexp.pull
      return re.match_here(regexp,text)
    end if
    while text.len > 0
      if re.match_here(regexp, text) then return 1
      text.pull
    end while
    return 0
  end function
  re.match_here = function(regexp, text)
    if not regexp then return 1
    if regexp.len > 1 and regexp[1] == \"#\" then 
      return self.match_star(regexp[0], regexp[2:], text)
    end if
    if regexp[0] == \"$\" and not regexp.hasIndex(1) then
      if text.hasIndex(1) then return 0 else return 1
    end if
    if text.len > 0 and (regexp[0] == \"*\" or regexp[0] == text[0]) then 
      return self.match_here(regexp[1:], text[1:])
    end if
    return 0
  end function
  re.match_star = function(c, regexp, text)
    while text.len and (text[0] == c or c == \"*\") 
      if re.match_here( regexp, text) then return 1
      text = text[1:]
    end while
    return 0
  end function
  if DEBUG then print(\"<size=75%>loaded regex engine...</size>\")
  // end regex engine //
  //
  // checkUser function by Corvus, additions by Plu70
  checkUser = function(result)
    if DEBUG then print(\"checkUser: \"+@result)
    if typeof(@result) == \"function\" then return \"function\"
    user = \"\"
    rfile = null
    file = null
    if result == null then return \"null\"
    if typeof(result) != \"shell\" and typeof(result) != \"ftpshell\" and typeof(result) != \"file\" and typeof(result) != \"computer\" then return \"???\"
    if typeof(result) == \"computer\" then
      file = result.File(\"/home\")
      rfile = result.File(\"/root\")
    else if typeof(result) == \"shell\" or typeof(result) == \"ftpshell\" then
      file = result.host_computer.File(\"/home\")
      rfile = result.host_computer.File(\"/\")
    end if
    if rfile and rfile.has_permission(\"w\") then
      user = \"root\"
    else if rfile and file then
      for folder in file.get_folders
        if folder.has_permission(\"w\") and folder.name != \"guest\" then user = folder.name
      end for
    end if
    if typeof(result) == \"file\" then
      if DEBUG then print \"check_user: found file\"
      if not p_validate(result,\"name\") then return \"null\"
      file = result
      if file.name != \"/\" then
        file = file.parent
        while file.name != \"/\"
          file = file.parent
        end while
      end if
      if not file then return \"???\"
      if file.has_permission(\"w\") then user = \"root\"
      for folder in file.get_folders
        if folder.name == \"root\" then
          if folder.has_permission(\"w\") then user = \"root\"
        end if
        if folder.name == \"home\" and user != \"root\" then
          for sub in folder.get_folders
            if sub.has_permission(\"w\") and sub.name != \"guest\" then user = sub.name
          end for
        end if
      end for
    end if
    if user == \"\" then user = \"guest\"
    return user // by Corvus
  end function
  // end check user //
  
  // DAEMON manager, by redi0
  //
  DaemonManager = {
    \"__comp\": globals.localmachine,
    \"__file\": null,
    \"__filePath\": \"/root/5hell.d\",
    \"__initialized\": 0,
    \"__type\": {
      \"hashim\": \"hashim\",
      \"htop\": \"htop\",
      \"outmon\": \"outmon\",
      \"rsi\": \"rsi\"}}// greyscript doesn't like these closing braces on their own line for whatever reason
  
  DaemonManager.__getNext = function(type)
    if not self.__initialized then return null
    max = 0
    lines = self.__file.get_content.split(char(10))
    for line in lines
      if line == \"\" then continue
      if line.indexOf(self.__type[type]) != null then
        identifier = line.split(\" \")[0]
        if identifier.indexOf(\"_\") == null then continue
        parts = identifier.split(\"_\")
        if parts.len != 2 then continue
        if typeof(parts[1].to_int) != \"number\" then continue
        test = parts[1].to_int
        if test > max then max = test
      end if
    end for
    return max + 1
  end function
  
  DaemonManager.Check = function(daemon)
    if typeof(@daemon) != \"string\" then return
    if not self.__initialized then return 0
    content = self.__file.get_content
    if not content then return 0
    lines = content.split(char(10))
    for line in lines
      parts = @line.split(\" \")
      if parts[0] == daemon then return 1
    end for
    return 0
  end function
  
  DaemonManager.Init = function
    file = self.__comp.File(self.__filePath)
    if not file then
      self.__comp.touch(\"/root\", \"5hell.d\")
      file = self.__comp.File(self.__filePath)
      if not file then
        print(\"Error: could not create 5hell.d.\" )
        return
      end if
    end if
    self.__file = file
    self.__initialized = 1
  end function
  
  DaemonManager.Start = function(type, note = \"\")
    if not self.__type.hasIndex(@type) then
      print(\"Error: invalid type: \" + @type)
      return
    end if
    if not self.__initialized then self.Init
    if typeof(@note) != \"string\" then note = \"\"
    if note.len > 0 then note = \" \"+note
    next = \"0\" + self.__getNext(type)
    daemon = self.__type[type]+\"_\"+next[-2:]
    content = self.__file.get_content
    if content.len > 0 then lines = content.split(char(10)) else lines = []
    lines.push(daemon+note)
    lines.sort
    result = self.__file.set_content(lines.join(char(10)))
    if result == 1 then return daemon
    if result == 0 then
      print(\"Error: could not write to 5hell.d.\")
    else if typeof(result) == \"string\" then
      print(\"Error: \" + result)
    end if
    self.__initialized = 0
  end function
  
  DaemonManager.Stop = function(daemon)
    del = function(file)
      result = file.delete
      if result == \"\" then
        return 1
      else
        print \"Error: \" + result
        return 0
      end if
    end function
    if typeof(@daemon) != \"string\" then return
    if not self.__initialized then self.Init
    content = self.__file.get_content
    if content == \"\" then
      if del(self.__file) then return 1
    end if
    lines = content.split(char(10))
    for idx in range(0,lines.len - 1)
      line = lines[idx]
      parts = @line.split(\" \")
      if parts[0] == daemon then
        print(\"stopping \" + parts[0])
        lines.remove(idx)
        if lines.len == 0 then
          if del(self.__file) then return 1
        end if
        break
      end if
    end for
    result = self.__file.set_content(lines.join(char(10)))
    if result == 1 then return 1
    if result == 0 then
      print(\"Error: could not write to 5hell.d.\")
    else if typeof(result) == \"string\" then
      print(\"Error: \" + result)
    end if
    return 0
  end function
  ////// end daemon manager /////////////"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction4" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]kore.5pk.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/root/src/kore.5pk[/color]. Make sure to keep 'Allow import' checked."
fit_content = true

[node name="KoreCodeEdit" type="CodeEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 300)
layout_mode = 2
text = "if DEBUG then print(\"<size=75%>loading kore.5pk v 4.0.7...(147.886)</size>\")
command.kore = function(arg1,arg2,arg3,arg4)
    time_s = time
    kore_usage_info = \"<u>\"+colorGold+\"KORE 3.0 || automation || helper || Goddess of the DEAD and GRAIN || rkit || security\"+char(10)+char(10)+
    \"Usage: <b>kore [-r|--rkit]</b> -- automatic rkit generation\"+char(10)+
	\"-- create rkit folder if it doesn't exist\"+char(10)+
    \"-- copy metaxploit.so, crypto.so, and 5hell to home_dir/rkit\"+char(10)+
	\"-- create database.csv within rkit if it doesn't exist \"+char(10)+
    \"Usage: <b>kore [-s|--secure]</b> -- automatic secure system:\"+char(10)+
    \"-- runs:<u> usr -r root / | grp -r root / | rm /etc/passwd\"+char(10)+
    \"----    <u> grep -f Bank | rm |  | grep -f Mail | rm | lock\"+char(10)+
	\"NOTE: kore -s will remove <b>all</b> copies of Bank.txt and Mail.txt\"+char(10)+
	\"-- please rename these files if you wish to keep them\"+char(10)+char(10)+
	\"Usage: <b>kore [-S],/b> -- paranoid secure; works as above plus:\"+char(10)+
	\"-- removes /bin, /usr, and /home\"+char(10)+
    \"Usage: <b>kore [--hdd]</b> -- prompts for hdd size in bytes\"+char(10)+
    \"-- writes size to /virt/hdd.io\"+char(10)+
    \"-- bios uses this to report remaining hdd space\"+char(10)+char(10)+
	\"NOTE: kore once had more functionality and will once again soon\"
    if arg1 == \"help\" or arg1 == \"-h\" then return kore_usage_info
    
    make_rkit = function()
		
		if globals.instance then pro_path = globals.instance.path else return \"kore: 5hell instance deleted. Unable to automate rkit construction.\"+char(10)+
		\"kore: run 5hell from the latest version to build rkit\"+char(10)+
		\"kore: please do not delete the binary until kore -r is complete\"
		print(\"Validating \"+home_dir+\"/rkit...\")
		print(command.mkdir(home_dir+\"/rkit\"))
		if not globals.get_file(home_dir+\"/rkit\") then return \"<size=75%>kore: failed to create rkit: permission denied\"
		print(\"kore: copying: \"+colorCyan+pro_path+CT+\" to \"+home_dir+\"/rkit/5hell\")
		print(command.cp(pro_path, home_dir+\"/rkit/5hell\" ))
		if not globals.get_file(home_dir+\"/rkit/\"+globals.instance.name) then print \"<size=75%>kore: failed to copy 5hell: permission denied\"
		mpath = null
		mpath = command.tree(\"/\",\"metaxploit.so\",\"1\",\"N\")
		if mpath and mpath.parent.name == \"rkit\" then
			mpath.move(mpath.parent.path,mpath.name+\".bku\")
			m_path_2 = command.tree(\"/\",\"metaxploit.so\",\"1\",\"N\")
			if m_path_2 then 
				mpath.delete	
				mpath = m_path_2
			else 	
				mpath.move(mpath.parent.path,mpath.name.remove(\".bku\"))
			end if
		end if
		if typeof(mpath) != \"file\" then 
			print \"<size=75%>kore: metaxploit.so not found\"
		else 
			print(\"<size=75%>kore: copying: \"+mpath.path+\" to \"+home_dir+\"/rkit\")
			print \"<size=75%>kore: if this is not the correct .so then\"+char(10)+
			\"<size=75%>-- please move the correct .so higher in the file tree\"+char(10)+
			\"<size=75%>-- such as in /lib\"
			command.cp(mpath.path, home_dir+\"/rkit\")
			if not globals.get_file(home_dir+\"/rkit/\"+mpath.name) then print \"<size=75%>kore: failed to copy metaxploit.so: permission denied\"
		end if
		cpath = null				
		cpath = command.tree(\"/\",\"crypto.so\",\"1\",\"N\")
		if cpath and cpath.parent.name == \"rkit\" then
			cpath.move(cpath.parent.path,cpath.name+\".bku\")
			c_path_2 = command.tree(\"/\",\"crypto.so\",\"1\",\"N\")
			if c_path_2 then 
			cpath.delete	
			cpath = c_path_2
			else 
				cpath.move(cpath.parent.path,cpath.name.remove(\".bku\"))
			end if
		end if
		if typeof(cpath) != \"file\" then 
			print \"<size=75%>kore: crypto.so not found\"
		else 
			print(\"kore: copying: \"+cpath.path+\" to \"+home_dir+\"/rkit/\"+cpath.name)
			command.cp(cpath.path, home_dir+\"/rkit\")
			if not globals.get_file(home_dir+\"/rkit/\"+cpath.name) then print \"<size=75%>kore: failed to copy crypto.so: permission denied\"
		end if 
		print \"kore: ensuring \"+colorWhite+home_dir+\"/rkit/database.csv\"+CT+\" exists...\"
		print command.poke(home_dir+\"/rkit/database.csv\")
		print \"kore: ensuring \"+colorWhite+home_dir+\"/rkit/tables\"+CT+\" exits...\"
		t = command.grep(\"-f\",\"^tables$\",\"/\")
		if typeof(t) != \"file\" then 
			print \"<size=75%>kore: failed to locate tables\"+char(10)+\"<size=75%>-- run pwgen | pwgen hash to create? [N/y]\"
			if user_input(\"||: \"+colorRed).lower == \"y\" then print command.shell(\"pwgen | pwgen hash\") else print \"kore: skipping tables...\"
		else 
			if t.parent.name != \"rkit\" then print command.cp(t.path,home_dir+\"/rkit\") else print \"<size=75%>kore: tables folder already exists\"
		end if
		return 0
	end function

    secure_it = function()
        print colorGold+\"<size=75%>kore: \"+colorGreen+\"running secure protocol...\"
        print colorGold+\"<size=75%>kore: \"+colorGreen+\"</b>changing ownership of all files to root...\"
		c = null
        c = command.usr(\"-r\",\"root\",\"/\")
		if c then print \"<size=75%>\"+c
        print colorGold+\"<size=75%>kore: \"+colorGreen+\"</b>changing group setting of all files to root...\"
        c = null
		c = command.grp(\"-r\",\"root\",\"/\")
		if c then print \"<size=75%>\"+c
		print \"<size=75%>kore: removing /etc/passwd...\" 
		print \"<size=75%>\"+ command.rm(\"/etc/passwd\")
		print \"<size=75%>kore: removing *Bank.txt...\"
		bank_files = command.grep(\"-a\",\"^Bank.txt$\",\"/\")
		for f in bank_files 
			if DEBUG and typeof(f) == \"file\" then print \"debug: filename: \"+f.name
			if typeof(f) == \"file\" then print \"<size=75%>\" + command.rm(f)
		end for
		print \"<size=75%>kore: removing *Mail.txt...\"
		mail_files = command.grep(\"-a\",\"^Mail.txt$\",\"/\")
		for f in mail_files 
			if DEBUG and typeof(f) == \"file\" then print \"debug: filename: \"+f.name
			if typeof(f) == \"file\" then print \"<size=75%>\" + command.rm(f) 
		end for
		if outer.arg1 == \"-S\" then 
			print colorRed+\"<size=75%></b>kore</color>: removing home folder... \"
			print \"<size=75%>\"+command.rm(\"-r\",\"/home\")
			print colorRed+\"<size=75%></b>kore</color>: removing bin folder...\"
			print \"<size=75%>\"+command.rm(\"-r\",\"/bin\")
			print colorRed+\"<size=75%></b>kore:</color> removing usr folder...\"
			print \"<size=75%>\"+command.rm(\"-r\",\"/usr\")
		else 
			print \"<size=75%>kore: removing guest folder...\"
			print \"<size=75%>\"+command.rm(\"-r\",\"/home/guest\")
			print \"<size=75%>-- consider manually deleting /home if it is not in use\"
		end if
		print \"<size=75%>kore: running silentclean...\"
		print command.rclean(globals.localmachine)
		print \"<size=75%>kore: locking system...\"
        print \"<size=75%>\" + command.perms(\"lock\",\"all\")
        return 0
    end function

    report_hdd = function()
        print \"kore: setting up /virt/hdd.io...\"
        size_of_disk = user_input(colorGold+\"kore: \"+CT+\"please enter your HDD size in bytes:\"+char(10)+colorGold+\":> </color>\").val
        if typeof(size_of_disk) != \"number\" or size_of_disk < 1 then return \"kore: expects size as a positive integer\"
        print command.mkdir(\"/virt\")
        print command.poke(\"/virt/hdd.io\", \"dev_sda:\"+size_of_disk)
        return 0
    end function
     
    error = function()
        print \"kore: invalid input\"
        return 0
    end function
    switch(arg1)
        case(\"-r\",@make_rkit)
        case(\"--rkit\",@make_rkit)
        case(\"-s\",@secure_it)
        case(\"--secure\",@secure_it)
        case(\"--hdd\",@report_hdd)
    default(@error)
    time_f = time - time_s
    return \"kore: task complete in \"+time_f+\" seconds.\"
end function
command.target = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"Target || Target IP || Target Port\"+char(10)+\"Usage: target -- return current target ip and port\"+char(10)+\"Usage: target ip -- returns current target ip\"+char(10)+\"Usage: target pt -- return current target port\"+char(10)+\"Usage: target [ip] -- set target ip address (ip must be a valid ip)\"+char(10)+\"Usage: target -p [port] -- set target port (returns target port if not supplied)\"+char(10)+\"Usage: target [ip] [port] -- set targt ip and port in a single command\"+char(10)+char(10)+\"Note: target ip and port are used by 5phinx, transmit, meta, db, probe, and others.\"
	print char(10)+colorCyan+\"</b><u><size=75%>\"+CT+colorWhite+\"</b>target: processing targetIP and targetPort...\"
	if not arg1 then  
		print \"<size=75%>target: returning targetIP and targetPort:\"
		return globals.targetIP+\" \"+globals.targetPort
	end if
	if arg1 == \"ip\" or arg1 == \"-i\" then 
		if not arg2 or (typeof(arg2) != \"string\" and typeof(arg2) != \"number\") then 
			print \"<size=75%>target: returning targetIP:\"	
			return globals.targetIP
		end if
		if is_valid_ip(arg2) then 
			globals.targetIP = arg2 
			print \"<size=75%>target: targetIP set to: \"
			return targetIP
		else 
			return \"target: invalid target ip\"
		end if
	end if
	if arg1 == \"-p\" or arg1 == \"port\" or arg1 == \"pt\" then 
		if arg2 and arg2.to_int >= 0 then 	
			if arg2 then globals.targetPort = arg2.to_int
		else 
			if arg2 == \"*\" then 
				globals.targetPort = \"*\" 
			else 
				print \"<size=75%>target: returning targetPort:\"
				return globals.targetPort
			end if
		end if
		print \"<size=75%>target: set targetPort to:\"
		return globals.targetPort
	end if
	if is_valid_ip(arg1) then globals.targetIP = arg1 else return \"target: invalid ip\"
	if arg2 and arg2.to_int >= 0 then 
		globals.targetPort = arg2.to_int 
	else 
		if arg2 == \"*\" then
			globals.targetPort = \"*\"
		else
			globals.targetPort = \"router\"
		end if 
	end if
	print \"<size=75%>target: returning targetIP and targetPort:\"
	return globals.targetIP+\" \"+globals.targetPort
end function
command.transmit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"<b>Transmit</b> -- t_buf transmission protocol\"+char(10)+\"Usage: transmit [opt: 1|0] --  transmit @t_buf to your @home server. \"+char(10)+\"-- set @home credentials in 5hell.src before building 5hell\"+char(10)+\"-- options: 1 == wait for reply, 0 (or blank) == don't wait for reply\"+char(10)+\"-- use with hashim running on the @home server\"
	return globals.transmit(arg1)
end function
command.outmon = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"monitor || file monitor || output monitor\"+char(10)+
	\"Outmon is a not very useful daemon that will monitor a given file for a change.\"+char(10)+
	\"When a change is detected, it will print the file contents, then resume monitoring.\"+char(10)+char(10)+
	\"<b>Usage: outmon [path] [opt:interval]\"+char(10)+
	\"-- path is the path to the file to monitor; default /virt/out.spc\"+char(10)+
	\"-- interval is the refresh rate; default 2 seconds, range(.1, 300)\"+char(10)+
	\"-- prints changes to a text file every [interval] seconds\"+char(10)+char(10)+
	\"-- to end the running process, use the command:<b> purge -d [opt:name]\"+char(10)+
   	\"---- or note the daemon name printed on the screen and \"+char(10)+
    \"---- remove the corresponding line from <b>/root/5hell.d</b>\"+char(10)+
    \"---- or delete the file entirely\"+char(10)+
    \"-- if the file cannot be created, then the process must be exited by with <b>ctrl+c\"+char(10)
	out_space = localmachine.File(\"/virt/out.spc\")
	if arg1 then out_space = globals.get_file(arg1)
	if not out_space then return \"outmon: \"+ arg1 + \": file not found.\"
	last_read = \"-EMPTY-\" // out_space.get_content
	interval = arg2 // refresh interval, may be float in range .1, 300
	if interval and typeof(interval) == \"string\" then interval = interval.val
	if typeof(interval) != \"number\" or interval < .1 or interval > 300 then interval = 2
	manager = new DaemonManager
	daemon = manager.Start(\"outmon\", out_space.path)
	while (daemon and manager.Check(daemon)) or not manager.__initialized
	  if last_read == out_space.get_content then
	    //skip
	  else
	    last_read = out_space.get_content
		print(colorWhite+\"daemon: \"+daemon+CT)
	    print(colorGreen+\"///////////////////////////////////////\"+CT)
	    print(last_read)
	    print(colorGreen+\"///////////////////////////////////////\"+CT)
	    print(colorWhite+\"Listening on :\"+out_space.path+\" for connections...\"+CT)
	  end if
	  wait(interval)
	end while
	return 0
end function
command.glasspool = function(arg1,arg2,arg3,arg4)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return colorLightBlue+\"<u>Glasspool sshfs shell/computer mirroring || GP || glassp\"+char(10)+
	\"Switches scope of commands to a supplied object\"+char(10)+
	\"Usage: glasspool [object: shell|computer] -- switch scope to piped object\"+char(10)+
	\"Usage: glasspool [#] -- switch scope to the shell or computer at BUFFER index #\"+char(10)+
	\"Usage: glasspool -r [#] -- switch scope to reverse shell at rsi index #\"+char(10)+
	\"-- n.b. rshell index starts at 1 not 0 !!\"+char(10)+
	\"Usage: glasspool [-m|menu] -- display BUFFER and RSI menu and switch scope to selection\"+char(10)+
	\"Usage: <b>gp</b> [option] -- abreviation for glasspool, for qol\"+char(10)+
	\"N.B. -- glasspool is the glassp option in rsi and malp\"+char(10)+
	\"N.B. -- commands that are local only will not translate through glasspool\"+char(10)+
	\"N.B. -- the term 'glass puddle' refers to glasspool in computer object mode\"+char(10)+
	\"Usage: glasspool [-d] [command_string] [index|object]\"+char(10)+
	\"-- execute a command or string of commands upon initialization\"+char(10)+
	\"--eg: gp -d \"\" echo cleaning up | rclean @B 1 | return \"\" @B 1 \"+char(10)+
	\"Usage: glasspool [-d] [command_string] [-r|-m] [index]\"+char(10)+ 
	\"-- execute commands on initialization with -r|-m options\"+char(10)+
	\"--eg: gp -d \"\" do 1 -f this.bat \"\" -r 1\"+char(10)+
	\"--eg: macro -s bob \"\"echo burger \"\" |  | gp -d bob -m\"
	gp_do = false // do we need to initiate a do script when we start galsspool?
	obj = arg1 
	if arg1 == \"-d\" then
		if arg2 then gp_do = arg2 else return \"glasspool: -d expects string\"
		obj = arg3
		arg2 = arg4
	end if
	// handle switches
	// -m display menu
	if typeof(obj) == \"string\" and typeof(obj.to_int) == \"number\" then 
		index = obj.to_int 
		if index >= 0 and index < globals.BUFFER.len then obj = globals.BUFFER[index] else return \"glassp: index out of range\"
	end if 
	if obj == \"-m\" then 
		temp_buf = []
		for b in globals.BUFFER
			if typeof(b) == \"shell\" or typeof(b) == \"ftpshell\" or typeof(b) == \"computer\" then temp_buf.push(b)
		end for
		r_index = temp_buf.len
		if metaxploit then
			r_buf = metaxploit.rshell_server
			if typeof(r_buf) != \"string\" then temp_buf = temp_buf + r_buf
		end if
		print(colorLightBlue+\"<size=85%><mark=blue>======================================================================</mark></size>\"+CT)
		print(\"<u>BUFFER contains: \"+temp_buf.len+\" glass objects. [\"+colorWhite+\"0\"+CT+\"] == localhost \"+colorCyan+\"*\"+CT+\" == \"+colorCyan+\"active shell\"+CT+\"</u>\"+char(10)+\"<size=75%><u>\"+colorLightBlue+\" rshells \"+CT+\"are listed after\"+colorOrange+\" BUFFER \"+CT+\"shells. rshells in BUFFER will be listed twice.</size></u>\")
		ti = 0
		color_shelle = colorOrange
		she_buf = []
		active_icon = \"<b> - </b>\"
		for tb in temp_buf
			if ti >= r_index then color_shelle = colorLightBlue // color rshells blue
			if typeof(tb) == \"shell\" or typeof(tb) == \"ftpshell\" then
				if tb.host_computer.public_ip == globals.shell.host_computer.public_ip and tb.host_computer.local_ip == globals.shell.host_computer.local_ip then active_icon = colorCyan+\" * \"+CT
				p_ip = tb.host_computer.public_ip
				l_ip = tb.host_computer.local_ip
			else 
				p_ip = tb.public_ip
				l_ip = tb.local_ip
			end if
			she_buf.push(\"[\"+colorWhite+ti+CT+\"]\"+active_icon+\"\"+color_shelle+\"[\"+checkUser(tb)+\":\"+typeof(tb)+\"] \"+CT+l_ip+\" @ <b>\"+p_ip+\"</b>\") 
			active_icon = \"<b> - </b>\" // reset active icon
			ti = ti + 1
		end for
		print(she_buf.join(char(10)))
		slect = user_input(\"select a <b>target</b> shell (q=quit): \").to_int
		if typeof(slect) != \"number\" then return \"aborting...\"
		if slect >= 0 and slect < temp_buf.len then
			obj = temp_buf[slect]
		else
			return \"aborting...\"
		end if
	end if
	// -r use rshell
	if obj == \"-r\" then 
		if metaxploit then
			r_buf = metaxploit.rshell_server
			if typeof(r_buf) == \"string\" then return r_buf 
			if r_buf.len < 1 then return \"rsi: rshell buffer empty\"
			if not arg2 or typeof(arg2.to_int) != \"number\" then return \"glassp: -r expects a number index\"
			if arg2.to_int > r_buf.len or arg2.to_int < 1 then return \"glassp: index [\"+arg2+\"] out of range\"
			obj = r_buf[arg2.to_int - 1]
		end if
	end if
	// check result. file objects are not supported at this time
	if typeof(obj) != \"shell\" and typeof(obj) != \"computer\" then return \"glassp: expects shell or computer\"
	print(colorLightBlue+\"<size=75%>Initializing sshfs glasspool protocol...\"+CT)

	// -- handle shell
	if typeof(obj) == \"shell\" then
		// save current state
		hold_shell = globals.shell
		globals.shell = obj
		globals.localmachine = shell.host_computer
		if globals.localmachine and globals.shell then
			globals.GLASSPOOL = globals.GLASSPOOL + 1
			// display info/warning
			print colorLightBlue+\"<size=75%>glasspoool:\"+CT+colorWhite+\" initialization successful. \"+char(10)+
			colorOrange+\"<size=75%>Type <u>return</u></b> to deactivate glasspool or exit / quit to exit 5hell completely\"+char(10)+
			colorOrange+\"<size=75%>glasspool: shell mirroring:\"+char(10)+
			\"<size=75%>-- <color=yellow>shell</color>, <color=yellow>computer</color>, and <color=yellow>file</color> commands\"+char(10)+
			\"<size=75%>---- will execute on the machine attached to the shell object\"+char(10)+
			\"<size=75%>-- <b>local/general</b> category commands will execute on the local machine\"
			if typeof(globals.shell) == \"ftpshell\" then print colorOrange+\"<size=75%>Warning: ftp shells have limited functionality\"
			// print(\"Type: <b><u>return</u></b> to deactivate and return. Exit to quit completely.\")
			// switch scope
			uu = checkUser(globals.shell)
			if uu == \"root\" then 
				globals.currentPath = \"/root\"
			else
				if uu == \"guest\" then 
					globals.currentPath = \"/home/guest\"
				else 
					globals.currentPath = \"/home/\"+uu
				end if
			end if
			command.shell(gp_do)
			// restore previous state
			globals.shell = hold_shell
			globals.localmachine = globals.shell.host_computer
			globals.GLASSPOOL = globals.GLASSPOOL - 1
			// update path
			globals.update_path
			print(colorLightBlue+\"<size=75%>glasspool: \"+colorOrange+\" deactivating...\"+CT)
		else
			globals.shell = hold_shell
			globals.localmachine = globals.shell.host_computer
			print(colorOrange+\"<size=75%>glasspool: error: failed to initialize.\"+CT)
		end if
	end if

	// -- handle computer
	if typeof(obj) == \"computer\" then
		// display info/warning.

		print(colorLightBlue+\"<size=75%>glasspool: initializing glass puddle computer handler...\")+CT
		// save current state
		tem_c = globals.localmachine
		globals.localmachine = obj
		if globals.localmachine and globals.shell then
			globals.GLASSPOOL = globals.GLASSPOOL + 1
			print colorLightBlue+\"<size=75%>glasspoool:\"+CT+colorWhite+\" initialization successful \"+char(10)+
			colorOrange+\"<size=75%>Type <u>return</u></b> to deactivate glasspool or exit / quit to exit 5hell completely\"+char(10)+
			colorOrange+\"<size=75%>glasspool: computer mirroring:\"+char(10)+
			\"<size=75%>-- <color=yellow>computer</color>, and <color=yellow>file</color> commands\"+char(10)+
			\"<size=75%>---- will execute on the machine connected to the computer object\"+char(10)+
			\"<size=75%>-- <color=yellow>shell</color> and <b>local/general commands</b> will execute on the local machine\"+char(10)
			// switch scope
			uu = checkUser(globals.localmachine)
			if DEBUG then print \"debug: uu: \"+uu
			if uu == \"root\" then 
				globals.currentPath = \"/root\"
			else
				if uu == \"guest\" then 
					globals.currentPath = \"/home/guest\"
				else 
					globals.currentPath = \"/home/\"+uu
				end if
			end if
			command.shell
			// restore previous state
			globals.localmachine = tem_c
			// update path
			globals.update_path
			globals.GLASSPOOL = globals.GLASSPOOL - 1
			print(colorLightBlue+\"GLASS_PUDDLE: \"+colorOrange+\" deactivating...\"+CT)
		else 
			globals.localmachine = tem_c
			print(colorOrange+\"glasspool: error: failed to initialize.\"+CT)
		end if
	end if
	return 0
end function
command.rsi = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<b><u>Reverse Shell Interface || RSI Daemon || Install rshell server\"+char(10)+
	\"Usage: rsi [opt: -d|-i|install|start|stop] [opt: -r|# ] [opt: #]\"+char(10)+
	colorLightBlue+\"</b>Usage: <b>rsi</b> -- open rshell_interface: listen for connections on port 1222\"+char(10)+
	\"-- Runs once then exits\"+char(10)+
	\"Usage: rsi [<b>-d</b>] -- daemon mode, continues to listen for connections until an rshell connects.\"+char(10)+
	colorCyan+\"Usage: rsi [<b>-r</b>] [#] -- return the shell object at rshell index #\"+char(10)+
	\"-- eg: rsi [<b>-r</b>] #  -- returns the rshell at index # as an object\"+char(10)+
	\"-- eg: rsi [<b>-d</b>] [-r</b>] [1</b>] -- wait in daemon mode on an empty rshell buffer and return the first connection as an object\"+char(10)+
	\"Usage: rsi [<b>#</b>]  -- auto-selects the rshell at index [#] and opens the context menu\"+char(10)+
	\"Usage: rsi [<b>#1</b>] [<b>#2</b>] -- access the rshell at index #1 and auto select option [#2]\"+char(10)+
	\"-- please note, rshell indexes start at 1 not 0\"+char(10)+
	\"-- eg: rsi 1 7 | gp\"+char(10)+
	\"Usage: rsi [<b>-p</b>] [opt:y] -- purge all rshells; supplying 'y' will skip confirmation\"+char(10)+
	\"Usage: rsi [<b>-s|-S</b>] -- scrub logs of all rshells (if possible)\"+char(10)+
	\"-- [-s] -- uses silentclean\"+char(10)+
	\"-- [-S] -- uses rclean\"+char(10)+
	\"Usage: rsi [<b>-n|-N</b>] -- nuke all rshells\"+char(10)+
	\"-- [-n] -- uses silentclean -n\"+char(10)+
	\"-- [-N] -- uses rclean -n\"+char(10)+
	\"Usage: rsi [<b>-i</b>|install] -- installs the reverse shell server if librshell.so is in /lib\"+char(10)+
	\"Usage: rsi [<b>start</b>|<b>stop</b>] -- start or stop the installed rshell server\"+char(10)

	if not metaxploit then return \"Error: Can't find metaxploit library in the /lib path or the current folder\"
	if not localmachine.is_network_active then return \"nsl: no network connection.\"
	if arg1 == \"-p\" then return command.purge(\"-r\",arg2,arg3,arg4)
	if arg1 == \"stop\" then 
		rserver = null
		rserver = include_lib(\"/lib/librshell.so\")
		if rserver then rc = rserver.stop_service else return colorRed+\"rsi: /lib/librshell.so not found\"+CT
		if rc then return colorGreen + \"rsi: service stopped\" +CT else return colorOrange + \"rsi: service is not running\" + CT
	end if
	if arg1 == \"start\" then 
		rserver = null
		rserver = include_lib(\"/lib/librshell.so\")
		if rserver then rc = rserver.start_service else return colorRed+\"rsi: /lib/librshell.so not found\"+CT
		if rc then return colorGreen + \"rsi: service started\" +CT else return colorOrange + \"rsi: service is already running\" + CT
	end if
	if arg1 == \"-i\" or arg1 == \"install\" then 
		rserver = null
		
        lbrs = command.tree(\"/\",\"librshell.so\",1,\"N\")
        if not lbrs then return colorRed+\"rsi: librshell.so not found on machine.\"+CT
		rc = null
        lib = localmachine.File(\"/lib\")
        if not lib then return \"rsi: error, /lib missing\"
        if lib.has_permission(\"w\") and lbrs.has_permission(\"r\") then lbrs.copy(\"/lib\",lbrs.name)
        rserver = include_lib(\"/lib/librshell.so\")
        if not rserver then print(\"rsi: librshell.so not installed in /lib.\")
        rc = rserver.install_service
		if rc then return colorGreen+\"rsi: service installed\"+CT else return colorRed + \"rsi: failed to install service\" + CT
	end if
	print(colorLightBlue+\"Listening for upcoming connections...\")
	locals.rshells = []
	one_loop = true
	while rshells.len == 0
		wait(.01)
		rshells = metaxploit.rshell_server
		if typeof(rshells) == \"string\" then return rshells
		if rshells.len == 0 and arg1 != \"-d\" then 
			if one_loop == false then return colorOrange+\"</b>rsi: no reverse shells connected\\n-- use<b> rsi -d </b> to run in daemon mode.\"+CT else one_loop = false
		else 
			one_loop = false
		end if
	end while
	if arg1 == \"-d\" then 
		arg1 = arg2
		arg2 = arg3 
	end if
	return_it = false
	if arg1 == \"-r\" then 
		return_it = true
		ret = 0
		if arg2 then 
			ret = arg2.to_int
			if typeof(ret) != \"number\" or ret > rshells.len or ret < 1 then return \"rsi: invalid index. Note rshell indexes start at 1 not 0.\"
			print \"rsi: returning rshell [\"+colorWhite+ret+CT+\"]\" 
			return rshells[ret - 1]
		end if
		arg1 = arg2
	end if
	if arg1 == \"-s\" or arg1 == \"-n\" then 
		football = 0
		time_s = time
		if arg1 == \"-n\" then football = \"-n\"
		for rs in rshells 
			hold = globals.shell 
			globals.shell = rs 
			print command.silentclean(football)
			globals.shell = hold 
		end for
		return \"<size=75%>rsi: task complete in: \"+colorOrange+time-time_s+\"</color></b> seconds\"
	end if
	if arg1 == \"-S\" or arg1 == \"-N\" then 
		time_s = time
		for rs in rshells 
			if arg1 == \"-S\" then print command.rclean(rs) else print command.rclean(\"-n\",rs)
		end for
		return \"<size=75%>rsi: task complete in: \"+colorOrange+time-time_s+\"</color></b> seconds\"
	end if 
	if arg1 then arg1 = arg1.to_int
	if not arg1 then option = \"0\" else option = arg1
	st = arg2
	rs_buf = []
	while typeof(option) != \"number\" or option > rshells.len or option < 0
		print(colorLightBlue + rshells.len + \"</b> shell(s) connected:\"+char(10)+\"- if your expected shell isn't listed yet\"+char(10)+\"- press <<b>enter</b>> to refresh the page\"+char(10)+\"<b>Select a shell to access:\"+CT)
		if rshells.len < 1 then return \"rsi:\"+colorRed+\"</b> there are no reverse shells connected\"
		rs_buf = []
		for i in range(0, rshells.len - 1)
			rs_buf.push(colorLightBlue+\"-----------\"+CT+char(10) +colorLightBlue+\"Shell (\" +colorWhite+ (i + 1) +CT+ \")\" +CT+char(10)+ \"Public IP: \" + rshells[i].host_computer.public_ip + char(10) + \"Local  IP: \" + rshells[i].host_computer.local_ip + char(10) + colorWhite + command.ps(rshells[i]) )
		end for
		print(rs_buf.join(char(10)).trim)
		print(colorLightBlue+\"-----------\"+CT)
		option = user_input(\"Select shell ([0|q] to abort) :> \").to_int
		if option == 0 or option == \"q\" then return 0
		//wait(.01)
		rshells = metaxploit.rshell_server
	end while
	if option == 0 or option == \"q\" then return 0
	print(\"Accessing shell [\" + option + \"]...\")
	ts = rshells[option - 1]
	if return_it == true then 
		print \"rsi: returning rshell [\"+colorWhite+(option)+CT+\"]\" 
		return ts
	end if
	print
	print(colorLightBlue+\"-----------\"+CT+char(10) +colorLightBlue+\"Shell (\" +colorWhite+ option +CT+ \")\" +CT+char(10)+ \"Public IP: \" + rshells[option - 1].host_computer.public_ip + char(10) + \"Local IP: \" + rshells[option - 1].host_computer.local_ip + char(10))// + colorWhite + command.ps(rshells[option - 1]))
	print command.ps(rshells[option - 1])
	print colorWhite+\"<u>\"+colorLightBlue+\" = = = = = = = = = = = = = </color>\"+CT
	print \"[1] glasspool [2] start_terminal [3] scp \"+char(10)+
	      \"[4] buffer_it [5] rclean [6] run [K] kill\"+char(10)+
		  \"[7] return_object [8] fetch_binaries [0|q] abort \"
	if not st then st = user_input(\"||: \",0,1)
	if st == \"0\" or st.lower == \"q\" then return 0
	if st.lower == \"k\" then print(ts.host_computer.close_program(user_input(\"kill pid:> \").to_int ) )
	if st == \"1\" then
		return command.glasspool(ts)
	end if
	if st == \"2\" then 
		get_custom_object.return_value = \"#!#CASCADE#!#\"
		exit ts.start_terminal
		exit colorWhite+\"Starting terminal...\"
	end if
	if st == \"3\" then
		if GLASSPOOL then
			print(colorLightBlue+\"GLASSPOOL: \"+colorOrange+\"active\"+colorLightBlue+\" on: \"+CT)
			print(colorWhite+globals.shell.host_computer.local_ip+\"@\"+globals.shell.host_computer.public_ip+CT)
			print(\"Upload from / Download to the linked filesystem:\")
		end if
		return globals.secure_copy(ts)
	end if
	if st == \"4\" then
		BUFFER.push(ts)
		return \"Shell sent to \"+colorOrange+\"BUFFER\"
	end if
	if st == \"5\" then return globals.rclean(ts)
	if st == \"6\" then
		cpath = user_input(\"command_path:> \",0,0)
		if cpath == \"\" then return \"rsi: aborting...\"
		para = user_input(\"params:> \",0,0)
		globals.stack_pool(\"up\")
		print(ts.launch( cpath,para ))
		_cascade // exit if cascade
		globals.stack_pool(\"down\")
	end if
	if st == \"7\" then  
		print \"rsi: returning shell object\"
		return ts
	end if
	if st == \"8\" then 
		destiny = user_input(colorWhite+\"destination folder [q=quit]:> </b><u>\")
		if destiny.lower != \"q\" then 
			fldr = globals.get_file(destiny)
			if fldr and typeof(fldr) == \"file\" and fldr.is_folder and fldr.has_permission(\"w\") then return globals.get_binaries(ts, fldr) else return \"rsi: invalid destination: check path and/or permissions\"
		end if
	end if
	return \"rsi: exiting...\"
end function
command.scpm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"SCPM: 5hell.SCP Menu\"+char(10)+\"Usage: scpm -- from menu select target shell (active shell is shown with an '*'). \"+char(10)+\"-- input source path and then destination path at prompts.\"+char(10)+\"-- select upload or download. Note the printed trajectories.\"+char(10)+\"-- (these can change when glasspool is involved).\"+char(10)+\"-- if uploading indicate if editing permissions\"+char(10)+\"-- if editing permissions press <b>enter</b> for defaults\"+char(10)+\"-- default is <b>o+rwx</b> before uploading and then o-rwx after uploading.\"+char(10)+\"Always mind permissions! Type lock constantly to feel secure.\"+char(10)+\"Advanced: scpm [string_path|piped_file] -- open scpm menu with path or file.path tagged for scp\"+char(10)+\"Advanced: scpm [piped_shell] -- skip menu and scp to/from piped shell\"+char(10)+\"E.G. - clipb @B 1 | scpm -- use the shell object from buffer[1] with .scp\"+char(10)+char(10)+\"<b>New: scpm [opt:-u|-d] [opt:copy_from|file_object_from] [opt:copy_to|file_object_to] [opt:shell_object]\"+char(10)+\"-- -u will force upload and skip permissions prompt\"+char(10)+\"-- -d will force download\"+char(10)+\"-- supplying path_from will skip copy_from prompt\"+char(10)+\"-- supplying path_to (must be after path_from) will skip destination prompt\"+char(10)+\"-- supply a shell will skip shell prompt\"+char(10)+\"-- supplying all will skip all prompts\"+char(10)+\"-- parameters may be in any order except path_from must precede path_to\"+char(10)+\"---- eg: clipb @B 1 | scpm /root/rkit /home/guest | run /home/guest/rkit/5hell \"+char(10)+\"---- eg: clipb @B 1 |  | scpm /root/rkit @b\"+char(10)+\"---- eg: zap [mem] [vuln] | scpm -d /var/system.log /root\"
	target_shell = null
	target_path = null
	direction = -1 
	skip = 0
	paths = []
	if DEBUG then print \"debug: in scpm top\"+char(10)+\"debug: tagged4scp: \"+ globals.tagged_for_scp
	while arg1 
		if arg1 == \"-d\" then 
			direction = 1 // force download, skip confirmation
			if DEBUG then print \"debug: setting direction to: \"+direction
		else 
			if arg1 == \"-u\" then 
				skip = 1
				direction = 0
				if DEBUG then print \"debug: setting skip to: \"+skip
			else
				if typeof(arg1) == \"string\" then paths.push(arg1)
			end if
		end if
		if typeof(arg1) == \"file\" then paths.push(arg1.path)
		if typeof(arg1) == \"computer\" then return \"scpm: computer object is an invalid input.\"+char(10)+\"  valid inputs: string_path, shell, file\"
		if typeof(arg1) == \"shell\" or typeof(arg1) == \"pshell\" then 
			if p_validate(arg1,\"scp\") then target_shell = arg1 else return \"scpm: error, scp function not found in (p)shell object.\"
		end if
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
		arg4 = 0
	end while 
	if paths != [] then 
		paths.push(0)
		globals.tagged_for_scp = paths[0]
		target_path = paths[1]
	end if
	if DEBUG then print \"debug: in scpm middle\"+char(10)+\"debug: tagged4scp: \"+ globals.tagged_for_scp
	if DEBUG then print \"debug: dir: \"+direction+ \" skip: \"+skip
	if direction == 1 and skip == 1 then return \"scpm: invalid inputs cannot mix -d and -u\"
		// the pick a shell menu
	if not target_shell then
		temp_buf = []
		for b in BUFFER
			if typeof(b) == \"shell\" or typeof(b) == \"ftpshell\" or (typeof(b) == \"pshell\" and p_validate(b,\"scp\")) then temp_buf.push(b)
		end for
		r_index = temp_buf.len
		if metaxploit then
			r_buf = metaxploit.rshell_server
			if typeof(r_buf) != \"string\" then temp_buf = temp_buf + r_buf
		end if
		ti = 0
		print(colorLightBlue+\"<size=85%><mark=blue>======================================================================</mark></size>\"+CT)
		active_icon = \"<b> - </b>\"
		print(\"<u>BUFFER contains: \"+temp_buf.len+\" (r)shell(s) [\"+colorWhite+\"0\"+CT+\"] == localhost \"+colorCyan+\"*\"+CT+\" == \"+colorCyan+\"active shell\"+CT+\"</u>\"+char(10)+\"<size=75%><u>\"+colorLightBlue+\" rshells \"+CT+\"are listed after\"+colorOrange+\" BUFFER \"+CT+\"shells. rshells in BUFFER will be listed twice.</size></u>\")
		color_shelle = colorOrange
		she_buf = []
		for tb in temp_buf
            if typeof(tb) == \"pshell\" then 
                she_buf.push(\"[\"+colorWhite+ti+CT+\"]\"+active_icon+\"\"+color_shelle+\"[\"+checkUser(tb)+\":\"+typeof(tb)+\"]\")
                active_icon = \"<b> - </b>\"
			    ti = ti + 1
                continue
            end if
			if tb.host_computer.public_ip == globals.shell.host_computer.public_ip and tb.host_computer.local_ip == globals.shell.host_computer.local_ip then active_icon = colorCyan+\" * \"+CT
			if ti >= r_index then color_shelle = colorLightBlue
			she_buf.push(\"[\"+colorWhite+ti+CT+\"]\"+active_icon+\"\"+color_shelle+\"[\"+checkUser(tb)+\":\"+typeof(tb)+\"] \"+CT+tb.host_computer.local_ip+\" @ <b>\"+tb.host_computer.public_ip+\"</b>\")
			active_icon = \"<b> - </b>\"
			ti = ti + 1
		end for
		print(she_buf.join(char(10)))
		slect = user_input(\"select a <b>target</b> shell (q=quit):> \").to_int
		if typeof(slect) != \"number\" then return \"aborting...\"
		if slect >= 0 and slect < temp_buf.len then
			target_shell = temp_buf[slect]
		else
			return \"aborting...\"
		end if
	end if
	if DEBUG then print \"debug: scpm bottom: tar_path: \"+target_path+\" t_file: \"+globals.tagged_for_scp
	return globals.secure_copy(target_shell, target_path, direction, skip)
end function
command.iwlist = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<u>IWLIST || WIFI NETWORKS || WIFI POWER\"+char(10)+
	\"Usage: iwlist -- returns a string containing all wifi networks in range\"+char(10)+
	\"-- uses the command:<b> air false\"+char(10)+
	\"note: use the <b>air</b> menu for iwconfig functionality\"
	return command.air(\"false\")
end function
command.ifconfig = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: ifconfig [option:-l|local -p|public] --  returns ip and gateway information\"+char(10)+\"Usage: ifconfig [-c|connect] [lan_ip] [gateway] -- connect via ethernet to gateway and request lan_ip.\"+char(10)+\"Usage: ifconfig -d -- list network devices\"
	print(colorGreen+\"- - - - - - - - - - - - - - - - - - - - - - -\"+CT)
	dat = []
	globals.localip = globals.localmachine.local_ip
	globals.pubip = globals.localmachine.public_ip
	if arg1 == \"-l\" or arg1 == \"local\" or arg2 == \"-l\" or arg2 == \"local\" then dat.push(localip)
	if arg1 == \"-p\" or arg1 == \"public\" or arg2 == \"-p\" or arg2 == \"public\" then dat.push(pubip)
	if arg1 == \"-d\" or arg2 == \"-d\" then
		dat.push(\"___\")
		dat.push(localmachine.network_devices)
	end if
	if arg1 == \"-c\" or arg1 == \"connect\" then
		device = \"eth0\"
		address = arg2
		gateway = arg3
		if not is_valid_ip(address) then return(\"ifconfig: invalid ip address\")
		if not is_valid_ip(gateway) then return(\"ifconfig: invalid gateway\")
		output = localmachine.connect_ethernet(device, address, gateway)
		return output
	end if
	if arg1 == 0 and arg2 == 0 then //dat.push(pubip)
		if localmachine.is_network_active then
			router = get_router(localmachine.network_gateway)
			if not router then 
				dat.push(\"ifconfig: error: gateway: \"+localmachine.network_gateway)
			end if
			dat.push(\"Connected to: \"+localmachine.active_net_card)
			if localmachine.active_net_card == \"WIFI\" then
				if router then dat.push(\"<b>\"+router.essid_name+\"</b>\")
				if router then dat.push(router.bssid_name)
			end if
			dat.push(localmachine.network_gateway+char(10)+\"<b>\"+localmachine.public_ip+char(10)+\"<b>\"+localmachine.local_ip)
		else
			dat.push(char(10)+\"No active network connection.\"+char(10))
		end if
	end if
	return dat.join(char(10))
end function
command.air = function(arg1, arg2=0, arg3=0, arg4=0) // requires crypto.so
	if arg1 == \"help\" or arg1 == \"-h\" then return \"air: aircrack menu. Saves cracked .cap files to current path and reads those files from current path. \"+char(10)+\"Advanced: air [-f|false] -- same as command.iwlist, prints wifi nets in range and exits.\"+char(10)+\"Advanced: air -c [/path_to_file.cap] -- uses aircrack to return passkey from file.cap\"+char(10)+\"Advanced: select option [h] within air to activate detection of hidden wifi signals.\"+char(10)+\"-- You must be within range (on the same network) to detect and connect to these non-broadcasting signals.\"+char(10)+\"-- This allows bypassing firewalls in many instances.\"
	print(\"AirMenu v 0.1.3, by Plu70\")
	is_it_known = function(a)
		chrom = \"\"
		line = a.split(\" \")
		//p = \"/\"
		//if globals.currentPath != \"/\" then p = globals.currentPath + \"/\"
		//file = localmachine.File(p + line[2]+\".cap\")
		file = command.tree(\"/\",line[2]+\".cap\",1,\"N\")
		if file then
			chrom = colorGreen
		else
			chrom = colorOrange
		end if
		parsed_data = chrom + a + CT
		return parsed_data
	end function
	data_stream = function(alist)
		data = \"\"
		i = 0
		for element in alist
			data = data + \"[\" + colorWhite + i + CT + \"] \" + is_it_known(element) + char(10)
			i = i + 1
		end for
		return data
	end function

	scan_wifi = function(a1,detect_hidden)
		print(command.ifconfig)
		dev = localmachine.network_devices
		dsp = dev.split(char(10))
		wl = false
		for dl in dsp
			if dl.split(\" \")[0] == \"wlan0\" then wl = true
		end for
		if not wl then
			print(colorRed+\"air: error: wlan0 not found.\"+CT)
			return 0
		end if
		crypto.airmon(\"start\", \"wlan0\")
		print(colorGreen+\"- - - - - - - - - - - - - - - - - - - - - - -\"+CT)
		print(format_columns(\"DEV NAME MON\"+char(10)+dev))
		bssid = \"temp\"
		essid = \"temp\"
		power = \"temp\"
		ip = get_shell.host_computer.public_ip
		if detect_hidden == 2 then print(\"Probing for hidden signals on local network: \"+char(10)+ip)
		print(\"<align=center><b>(>|<)</b></align>\")
		networks = localmachine.wifi_networks(\"wlan0\")
		output = []
		if DEBUG then print(\"dh: \"+detect_hidden)
		if detect_hidden == 2 then
			if not localmachine.is_network_active then
				print(\"No network detected.\")
				return 1
			end if
			router = get_router( ip )
			if not router then return \"air: router not found\"
			clist = router.devices_lan_ip
			if DEBUG then print(\"clist: \"+clist)
			output = []
			for c in clist
				rw = get_router(c)
				if typeof(rw) != \"router\" then continue
				if DEBUG then print(rw.local_ip)
				if rw.local_ip == router.local_ip then continue
				if DEBUG then 
					for r in rw 
						print r 
					end for 
				end if					
				if rw.essid_name and networks.indexOf(rw.essid_name) == null then
					wire = rw.bssid_name+ \" 100% \" +rw.essid_name
					output.push(wire)
				end if
			end for
			if output.len then
				print( \"Found \"+output.len+\" hidden wireless signal(s): \")
				print(output.join(char(10)) + char(10) + \"<b>- - - - - - - - - - - - - - - - </b>\")
			else
				print(\"No hidden wireless signals found.\")
			end if
		end if
		networks = networks + output
		print(data_stream(networks))
		waitFor = false
		if a1 and a1 == \"false\" then waitFor = \"false\"
		if not waitFor then waitFor = user_input(\"Select a network # ( m=manual, h=detect_hidden, q=quit )\"+char(10)+\":> \").to_int
		if waitFor == \"h\" or waitFor == \"H\" then
			if globals.GLASSPOOL then print(colorOrange+\"Warning: Operation ignores GLASSPOOL.\"+CT)
			return 2
		end if
		if waitFor < networks.len and waitFor >= 0 and typeof(waitFor) == \"number\" then
			memory = networks[waitFor].split(\" \")
			print(memory)
			bssid = memory[0]
			power = memory[1]
			essid = memory[2]
		else
			if waitFor == \"m\" or waitFor == \"M\" then
				bssid = user_input(\"bssid:> \")
				essid = user_input(\"essid:> \")
				if bssid == \"\" or essid == \"\" then return 0
				power = user_input(\"estimated_power must be non-zero. If internal (hidden) wifi use 100 or 100%  \"+char(10)+\"estimated_power:> \")
				if power == \"\" then return 0
				memory = [bssid, power, essid]
			else
				return 0
			end if
		end if
		if is_it_known(memory.join(\" \")) then passw = crypto.aircrack(command.tree(\"/\",essid+\".cap\",1,\"N\").path)
		if passw and passw != \"temp\" then
			print(passw + \"@\" + bssid)
			print(\"Connection status: [\" + localmachine.connect_wifi(\"wlan0\", bssid, essid, passw) + \"]\"+char(10))
			wait(1)
			return detect_hidden
		end if
		print(\"Note: answering y/Y will use brutus. This will take a long long time. \")
		print(\"Note: answering c/C will allow you to type the password\")
		print(\"Note: answering q/Q will abort\")
		print(\"Note: anything else will use aircrack to crack the wifi key \")
		print(\"ie:\"+colorCyan+\" press enter\"+CT+\"; recommended)\")
		brut = user_input(\"Brute force the key? [c/y/N] (q=quit)\"+char(10)+\":> \")
		if brut.lower == \"q\" then return \"aborting...\"
		if brut == \"y\" or brut == \"Y\" then
			d_count = 0
			time_s = time
			print(\"Trying: \"+colorGold+dict_a.len+CT+\" passwords...\"+char(10)+\"<b>This may take some time...</b>\")
			for d in globals.dict_a
				try = localmachine.connect_wifi(\"wlan0\", bssid, essid, d)
				if try == 1 then
					print(d+\"@\"+bssid)
					print(\"Connection status: [\" + try + \"]\"+char(10))
					wait(1)
					return detect_hidden
				end if
				d_count = d_count + 1
				if d_count > 1000 then
					d_count = 0
					print(\" working for: \"+colorOrange+( (time - time_s) / 60 )+CT+\" minutes...\")
				end if
				wait(.01)
			end for
		end if
		if brut.lower == \"c\" then
			ur_p = user_input(\"network credentials (q=quit):> \")
			if ur_p.lower == \"q\" then return \"aborting...\"
			try = localmachine.connect_wifi(\"wlan0\", bssid, essid, ur_p)
			if try == 1 then print(essid+\" @ \"+bssid)
			print(\"Connection status: [\" + try + \"]\"+char(10))
			return detect_hidden
		end if
		max = (300000 / ( power.remove(\"%\").val) + 15 )
		max = max + 10 // just in case
		status = crypto.aireplay(bssid, essid, max)
		if status then print(status) else print(\"Scan complete.\")
		print(\"Processing...\")
		wait(2)
		cap = globals.get_file(home_dir+\"/file.cap\")
		if cap then
			catch = cap.move(globals.currentPath, essid+\".cap\")
			if catch then print(catch)
		else
			print(\"Error! file.cap not found.\")
		end if
		cap = globals.get_file(essid+\".cap\")
		if not cap then
			print(\"Error. Failed to rename file.cap to \" + essid+\".cap\")
		else
			print(\"...file saved as \" + essid+\".cap\")
			print(\"The key is:<b> \"+crypto.aircrack(globals.currentPath + \"/\" + essid + \".cap\")+\"</b>\")
		end if
		return detect_hidden
	end function
	scw = 1
	if arg1 == \"-f\" then arg1 = \"false\"
	if arg1 == \"-c\" then
		if arg2 then
			cap = globals.get_file(arg2)
			if cap then return \"air_crack: key:<b> \"+crypto.aircrack(cap.path)+\"</b>\" else return \"air_crack: \"+arg2+\" not found.\"
		else
			return \"usage: air -c [/path_to_file.cap] -- uses aircrack to return passkey from file.cap\"
		end if
	end if
	while scw
		scw = scan_wifi(arg1,scw)
	end while
	return \"air: exiting...\"
end function
command.probe = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<u><b>Probe || nMap || portscan</b></u>\"+char(10)+\"Usage: probe [optional: ip] [optional: port] -- standard whois and portmap\"+char(10)+\"probe -f [opt:ip] [opt:port] -- full scan. Takes longer. Gets all reachable, non-firewalled machines on subnet.\"+char(10)+\"</b>Usage: probe [-s|show] -- display currently loaded portmap.</b>\"+char(10)+\"-- when local on a network, probe each router by LAN ip to probe that subnet\"+char(10)+\"Quick: probe -q [opt:ip] [opt:port] -- quick scan, gets only surface level machines on subnet.\"+char(10)+\"Note: in all cases probe will set target ip and target port.\"
	if not localmachine.is_network_active then return \"probe: no network connection.\"
	if arg1 ==\"-s\" or arg1 == \"show\" then
		if PORT_MAP then return globals.display_portmap(1)
	end if
	if arg1 then globals.targetIP = arg1
	if arg2 then globals.targetPort = arg2.to_int
	get = 15
	if arg1 == \"-f\" then
		if arg2 then globals.targetIP = arg2
		if arg3 then globals.targetPort = arg3.to_int
		get = 255
	end if
	if arg1 == \"-q\" then
		if arg2 then globals.targetIP = arg2
		if arg3 then globals.targetPort = arg3.to_int
		get = 2
	end if
	if not arg1 or not is_valid_ip(globals.targetIP) or (arg1 == \"-f\" and not arg2) then set_ip
	if not arg2 or ( (arg1 == \"-f\" or arg1 == \"-q\") and not arg3) then globals.targetPort = \"router\"
	if arg4 and arg4 == \"1\" then
		return who_scan(get,0,1)
		return 0
	end if
	return who_scan(get,0,0)
	return 0
end function
command.lanpro = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: lanpro [ip] -- full lan scan. returns only lan addresses.\"+char(10)+\"Does not autoset ip or portmap for 5phinx. Use<b> probe -f </b>instead.\"
	if not localmachine.is_network_active then return \"lanpro: no network connection.\"
	get = null
	t = time
	if is_valid_ip(arg1) and not is_lan_ip(arg1) then 
		if get_router(arg1).public_ip == get_router.public_ip then 
			print colorLightBlue+(\"</b>lanpro: running locally on \"+arg1)
			if typeof(get_router(arg1)) == \"router\" then get = globals.lan_probe(get_router(arg1))
		else
			print colorLightBlue+(\"</b>lanpro: running remotely on \"+arg1)
			get = globals.lan_probe(get_router(arg1),\"remote\")
		end if
	end if 
	if not arg1 then 
		print colorLightBlue+(\"</b>lanpro: running locally on local gateway\")
		get = globals.lan_probe(get_router)
	end if
	if is_lan_ip(arg1) then 
		print colorLightBlue+(\"</b>lanpro: running locally on \"+arg1)
		if typeof(get_router(arg1)) == \"router\" then get = globals.lan_probe(get_router(arg1))
	end if
	print colorLightBlue+\"lanpro: task complete in \"+colorWhite+(time-t)+\"</color> seconds\"
	if not get then return \"lanpro: invalid argument or router unreachable\" else return get
end function
command.nsl = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then	return \"<u>nsl || nslookup || reverse ip lookup || domain to ip</u>\"+char(10)+
	\"Usage: nsl [opt:-t] [ip|domain] -- uses nslookup on ip|domain and returns domain|ip as a string\"+char(10)+
	\"Example:<b> nsl www.burger.org | probe </b> -- gets the ip of burger.org and pipes to probe.\"+char(10)+
	\"NOTE: nsl will append <b>www.</b> to a domain if it is omitted.\"+char(10)+
	\"Usage: nsl [ip] -- returns domain linked to ip (reverse lookup)\"+char(10)+
	\"Usage: nsl [domain] -- returns ip linked to domain (normal lookup)\"+char(10)+
	\"Ope: [-t] -- passing -t as first param will set global targetIP to ip\"
	
	if not localmachine.is_network_active then return \"nsl: no network connection.\"
	print \"<u>\"+colorGold+\"= = = = NSLOOKUP = = = =\"
	set_targ = false
	if arg1 == \"-t\" then 
		set_targ = true 
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
	end if
	if not arg1 then arg1 = command.ifconfig(\"-p\")
	if typeof(arg1) != \"string\" then return \"nsl: invalid input\"
	address = arg1
	if typeof(address) != \"string\" then return \"nsl: expects string\"
	print \"Address: \"+address//+char(10)
	if is_valid_ip(address) then 
		if DEBUG then print \"debug: reverse nsl lookup\"
		who_string = whois(address) 
		if DEBUG then print \"debug: who_string: \"+who_string
		domain = who_string.split(char(10))[0].split(\":\")[1]
		print colorLightBlue+\"<u>Domain: \"
		if set_targ == true then 
			print domain.trim
			return command.target(\"ip\",address,\"router\") 
		else 
			return domain.trim
		end if
	end if
	prefix = address[0:4]
	if DEBUG then print(\"debug_prefix:[\"+prefix+\"]\")
	if prefix != \"www.\" then address = \"www.\"+address
	if DEBUG then print(\"debug_address:\"+address)
	print(colorLightBlue+\"<u>IP: \")
	addy = nslookup(address)
	if DEBUG then print \"addy: \"+addy
	if set_targ == true then return command.target(\"ip\",addy,\"router\")
	return addy.trim
end function
command.ping = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == \"-h\" or arg1 == \"help\" then return command_info(\"ping_usage\")+char(10)+\"Note: returns a string.\"
	if not localmachine.is_network_active then return \"ping: no network connection.\"
	if not is_valid_ip(arg1) then return command_info(\"ping_usage\")
	time_s = time
	catch = shell.ping(arg1)
	time_e = ( (time - time_s) * 1000 )
	if DEBUG then print(\"catch: \"+catch)
	if catch == true then
		if typeof(catch) == \"string\" then
			return catch
		else
			print(colorLightBlue+\"Ping \"+colorWhite+arg1+\"</color>: successful\"+CT)
			color_time = colorOrange
			if time_e < .03 then color_time = colorGreen
			if time_e > .1 then color_time = colorRed
			return colorLightBlue+\"Ping: packet round trip: \"+CT+color_time+time_e+CT+colorLightBlue+\" ms.\"+CT
		end if
	else
		return colorRed+\"ping: \"+arg1+\" unreachable.\"
	end if
	return 0
end function
command.whois = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"WHOIS || whois information || network info\"+char(10)+
		\"Usage: whois [opt:-t] -- returns local netowrk whois information if no params given\"+char(10)+
		\"Usage: whois [opt:-t] [ip] --  returns whois information for given ip\"+char(10)+
		\"--eg: whois 1.1.1.1\"+char(10)+
		\"Usage: whois [opt:-t] [-nb|--getbox] -- run whois on a loop until a Neurobox Network is found\"+char(10)+
		\"-- avg runtime is less than 20 seconds\"+char(10)+
		\"-- search automatically terminates if runtime exceedes 1 minute\"+char(10)+
		\"Opt: [-t] - passing -t as first argument sets global targetIP to ip\"+char(10)+
		\"--eg: whois -t 1.2.34\"+char(10)+
		\"--eg: whois -t -nb\"+char(10)+
		\"--eg: whois -t\"+char(10)+
		\"Note: flag order matters: -t must come first if it is used\"
		\"Note: [-t] option sets targetPort to \"\"router\"\" \"
	
	set_targ = false
	if arg1 == \"-t\" then 
		set_targ = true 
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4
	end if
	if not arg1 then 
		if set_targ then print command.target(\"ip\", localmachine.public_ip, \"router\" )
		return \"<size=75%>whois: returning localhost whois information:\"+char(10)+whois(globals.pubip).replace(\"Neurobox Network\",colorCyan+\"<size=125%>_Neurobox_Network_</size>\"+CT)
	end if
	if arg1 == \"--getbox\" or arg1 == \"-nb\" then 
		found = false
		time_s = time
		while not found 
			if time_s-time>60 then return \"whois: search exceeded 60 seconds: terminating search\"
			ip = command.rnip(\"1\")
			string = whois(ip)
			if string.indexOf(\"[Neurobox\") != null then 
				found = true
				if set_targ then print command.target(\"ip\",ip,\"router\")
			end if
		end while
		return string.replace(\"Neurobox Network\",colorCyan+\"<size=125%>Neurobox Network</size>\"+CT)
	end if 
	if not is_valid_ip(arg1) then 
		arg1 = command.nsl(arg1) 
		if not is_valid_ip(arg1) then return \"whois: invalid ip or domain\" else print arg1
	end if
	if set_targ then print command.target(\"ip\", arg1, \"rotuer\")
	print char(10)+\"<size=75%>whois: returning info:\"
	return whois(arg1).replace(\"Neurobox Network\",colorCyan+\"<size=125%>Neurobox Network</size>\"+CT)
end function
command.ssh = function(arg1, arg2, arg3=0, arg4=\"ssh\")
	ssh_help = function()
		return \"Secure Shell Protocol\"+char(10)+\"Usage: ssh [user@pass] [ip] [optional:pt (default 22)]\"+char(10)+\"ssh_usage: ssh [user@-brutus] [ip] [opt:pt] --  remote brute force attack\"+char(10)+\"e.g. ssh root@1234 1.1.1.1 \"+char(10)+\"e.g. ssh root@-brutus 1.2.3.4 21 ftp\"+char(10)+\"Sends shells to BUFFER or you may open immediately.\"
	end function
	if arg1 == 0 or arg2 == 0 or arg1 == \"-h\" or arg1 == \"help\" then return ssh_help
	if not localmachine.is_network_active then return \"nsl: no network connection.\"
	rem_ip = arg2.trim
	rem_pt = 22
	rem_usr = \"\"
	rem_pass = \"\"
	if arg1.indexOf(\"@\") >= 0 then
		split = arg1.split(\"@\")
		rem_usr = split[0].trim
		rem_pass = split[1].trim
	else
		return \"ssh: expects user@pass [ip]\"
	end if
	if arg2 == \"-t\" then
		rem_ip = globals.targetIP
		if globals.targetPort then rem_pt = globals.targetPort else rem_pt = 22
	end if
	if arg3 and arg3 != \"\" and arg3 != \" \" then rem_pt = arg3.to_int
	if typeof(rem_pt) != \"number\" or not rem_pt then return \"Invalid port.\"
	if not arg4 or (arg4 != \"ftp\" and arg4 != \"ssh\") then arg4  = \"ssh\"
	if rem_ip == \"\" or rem_pt == \"\" or rem_usr == \"\" or rem_pass == \"\" then return \"Error: invalid input.\"
	if not rem_ip or not rem_pt or not rem_usr or not rem_pass or not arg4 then return \"Error: invalid input.\"
	print(\"Connecting: \"+rem_ip+\" \"+rem_pt+\" \"+rem_usr+\" \"+rem_pass+\" \"+arg4)
	rem_shell = null
	if rem_pass == \"-brutus\" then return command.brutus(\"-s\", shell, rem_usr, rem_ip, rem_pt)
	rem_shell = shell.connect_service( rem_ip, rem_pt, rem_usr, rem_pass, arg4 )
	if typeof(rem_shell) == \"shell\" or typeof(rem_shell) == \"ftpshell\" then
		globals.BUFFER.push(rem_shell)
		print(\"Shell sent to BUFFER. Access via memory_alpha.\")
	end if
	return rem_shell
end function
command.calc = function(arg1=\"0\", arg2=\"0\", arg3=\"0\", arg4=0)
	calc_help = function()
		return \"calc [arg1] [arg2: + - * / (or: add, sub, mul, div)] [arg3] \"+char(10)+\"calc (a)sin/(a)cos/(a)tan/ [arg]\"+char(10)+\"calc pwr/abs/sqrt [arg]\"+char(10)+\"calc [min] rnd [max] |or| calc rnd [max]   (min=0)\"+char(10)+\"calc [arg1] pwr [arg2]\"+char(10)+\"calc [arg1] == [arg2] (check if equal.)\"+char(10)+\"Use pi to indicate pi. eg: calc pi || calc pi / 2 || calc cos pi || etc\"+char(10)+\"N.B. If an input is a function it will be evaluated\"+char(10)+\"-- EXCEPT when using the equals function (ie x == y)\"+char(10)+\"-- in this case function pointers will be compared.\"+char(10)+\"You may use @a or @clipa, @b or @clipb, @c or @clipc to reference the clipboards.\"+char(10)+\"-- ie calc @a + @b\"+char(10)+\"Returns: evaluation as string.\"+char(10)+\"calc [n] base [p] -- retruns the [p].adic representation of the number to evaluate.\"+char(10)+\"e.g. 42 base 2 -> 101010\"
	end function
	if @arg1 == \"-h\" or @arg1 == \"help\" then return calc_help
	calc = {}
	 
	// p-adic representation
	calc.base = function(n, p) // expects int: value, int:prime (must be greater than 1)
		if p < 1 then exit(\"Invalid base. P must be geater than 1\")
		p_adic_digits = []
		while n != 0
			quotient = null
			remainder = null
			res = divmod(n, p) // write divmod function, returns list
			quotient = res[0]
			remainder = res[1]
			p_adic_digits.push( remainder )
			n = quotient
		end while
		p_adic_digits = reverse( p_adic_digits ) // write a reverse function
		return p_adic_digits.join(\"\") // returns list
	end function
	divmod = function( val, prime )
		result = []
		result.push( floor(val / prime) )
		result.push( val % prime )
		return result
	end function
	reverse = function( list_input )
		new_list = []
		while list_input.len > 0
			new_list.push( list_input.pop )
		end while
		return new_list
	end function
	
	calc.equals = function(a1,a3)
		if @a1 == @a3 then
			print(\"equal\")
			return 1
		else
			print(\"not equal\")
			return 0
		end if
	end function
	calc.add = function(a1,a3)
		return (a1 + a3)
	end function
	calc.sub = function(a1,a3)
		return (a1 - a3)
	end function
	calc.mul = function(a1,a3)
		return (a1 * a3)
	end function
	calc.div = function(a1,a3)
		return (a1 / a3)
	end function
	calc.cos = function(a1,a3)
		return cos(a1)
	end function
	calc.sin = function(a1,a3)
		return sin(a1)
	end function
	calc.tan = function(a1,a3)
		return tan(a1)
	end function
	calc.acos = function(a1,a3)
		return acos(a1)
	end function
	calc.asin = function(a1,a3)
		return asin(a1)
	end function
	calc.atan = function(a1,a3)
		return atan(a1)
	end function
	calc.sqrt = function(a1,a3)
		return sqrt(a1)
	end function
	calc.pwr = function(a1,a3)
		tm=1
		for i in range(1,a3)
			tm=(tm * a1)
		end for
		return tm
	end function
	calc.rnd = function(a1,a3=0)
		//if typeof(a1) != \"number\" then a1 = a1.to_int
		ran = range(a3, a1)
		ran.shuffle
		return ran[0]
		//return (floor((rnd * a3.val) + a1.val))
	end function
	calc.abs = function(a1,a3)
		return abs(a1)
	end function
	calc.pi = function(a1,a3)
		return \"3.14159265358\"
	end function
	if @arg1 == \"@a\" or @arg1 == \"@clipa\" then arg1 = @globals.clip_board_alpha
	if @arg1 == \"@b\" or @arg1 == \"@clipb\" then arg1 = @globals.clip_board_beta
	if @arg1 == \"@c\" or @arg1 == \"@clipc\" then arg1 = @globals.clip_board_gamma
	if @arg2 == \"@a\" or @arg2 == \"@clipa\" then arg2 = @globals.clip_board_alpha
	if @arg2 == \"@b\" or @arg2 == \"@clipb\" then arg2 = @globals.clip_board_beta
	if @arg2 == \"@c\" or @arg2 == \"@clipc\" then arg2 = @globals.clip_board_gamma
	if @arg3 == \"@a\" or @arg3 == \"@clipa\" then arg3 = @globals.clip_board_alpha
	if @arg3 == \"@b\" or @arg3 == \"@clipb\" then arg3 = @globals.clip_board_beta
	if @arg3 == \"@c\" or @arg3 == \"@clipc\" then arg3 = @globals.clip_board_gamma
	if @arg2 == \"==\" then arg2 = \"equals\"
	if @arg1 == \"pi\" and @arg2 == 0 then return calc.pi
	if @arg1 == \"pi\" then arg1 = calc.pi
	if @arg2 == \"pi\" then arg2 = calc.pi
	if @arg3 == \"pi\" then arg3 = calc.pi
	if @arg2 == \"+\" then arg2 = \"add\"
	if @arg2 == \"-\" then arg2 = \"sub\"
	if @arg2 == \"*\" then arg2 = \"mul\"
	if @arg2 == \"/\" then arg2 = \"div\"
	if calc.hasIndex(@arg1) then
		c = @calc[arg1]
		if typeof(@arg2) == \"number\" then arg2 = str(arg2)
		return str(c(arg2.val))
	else
		if calc.hasIndex(@arg2) then
			c = @calc[arg2]
			par1 = 0
			par2 = 0
			if typeof(@arg1) == \"function\" then par1 = @arg1 else par1 = arg1
			if typeof(@arg3) == \"function\" then par2 = @arg3 else par2 = arg3
			if DEBUG then print(\"par1: \"+typeof(@par1)+char(10)+\"par2: \"+typeof(@par2)+char(10))
			if typeof(@arg1) == \"string\" then par1 = arg1.val
			if typeof(@arg3) == \"string\" then par2 = arg3.val
			if DEBUG then print(\"par1: \"+@par1+char(10)+\"par2: \"+@par2+char(10))
			return str(c(@par1,@par2))
		else
			return \"calc: <b>invalid input</b>\"
		end if
	end if
end function
command.sniff = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: sniff -- listen to network traffic. Prints a string if connections detected.\"+char(10)+\"-- runs in daemon mode. exits on first sniffed connection (or ctrl+c).\"
	if not globals.metaxploit then return \"sniff: metaxploit not found\"
	localmachine.touch(currentPath, \"sniffed\")
	opath = currentPath
	if opath == \"/\" then opath = null
	snout = localmachine.File(currentPath+\"/sniffed\")
	if not snout then print(colorRed+\"Write Error: cannot create\"+CT+colorOrange+currentPath+\"/sniffed\"+CT)
	print(colorRed+\"-------sniffing--------\"+CT)
	sniffed = globals.metaxploit.sniffer(1)
	if snout.has_permission(\"w\") and snout.has_permission(\"r\") then
		snout.set_content(snout.get_content+char(10)+sniffed)
		print(\"sniff: output saved to \"+snout.path)
	else 
		return \"sniff: unable to write \"
	end if
	if localmachine.File(program_path+\"/encode.src\") then print(\"sniff: encode.src saved to \"+program_path+\"/encode.src (hopefully...)\")
	return command.clipb(sniffed)
end function
command.rshell = function(arg1, arg2, arg3=0, arg4=0)
	if (arg1 == \"help\" or arg1 == \"-h\") and arg2==\"extra\" then return \"An <b>rshell</b> will require the following:\"+char(10)+\"* a server running <b>rshell-server</b>, available from most hack shops.\"+char(10)+\"* rshell-interface software running on the above server (see: <b>rsi -h</b>)\"+char(10)+\"* running this command (<b>rshell</b>) as follows:\"+char(10)+\"<b> rshell [ip.of.your.server] [process_name] </b>-- where proces_name is the desired name for the rshell. \"+char(10)+\"Once connected, access the rshell from the rshell-interface (rsi command)\"+char(10)+\"n.b. it is recommended to add rshells to the BUFFER and interact with them there, but it is not required, to do so press [4] after selecting a shell from rsi then acces<b> malp</b> and press [5].\"
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"REVERSE SHELL || rshell || reverse shell || back door || backdoor\"+char(10)+
	colorWhite+\"Usage: rshell [rshell_server_ip] [opt:stealthy_process_name] [opt:port] \"+char(10)+
	colorCyan+\"</b>Required: [rshell_server_ip] -- the ip of your rshell server\"+char(10)+
	\"-- use <b>@home</b> to indicate the ip in 5hell.src >> HOME_SERVER[0] \"+char(10)+
	\"-- @home server is currently: [\"+colorGold+HOME_SERVER[0]+CT+\"]\"+char(10)+char(10)+
	colorCyan+\"</b>Opt: [stealthy_process_name] -- name of the rshell; appears in ps\"+char(10)+
	\"-- process_name cannot be: dsession, Xorg or kernel_task\"+char(10)+
	\"-- default name: ps\"+char(10)+char(10)+
	colorCyan+\"</b>Opt: [port] -- the port on which your rshell server listens\"+char(10)+
	\"-- default is set in 5hell.src >> HOME_SERVER[7]\"+char(10)+
	\"-- default is currently: [\"+colorGold+HOME_SERVER[7]+CT+\"]\"+char(10)+char(10)+
	\"E.G: <b>rshell 123.4.5.06 ps 1337</b> -- while <u>on</u> the victim computer\"+char(10)+
	\"-- and ip is your rshell server with port 1337 forwarded\"+char(10)+
	\"E.G: <b>rshell @home not_a_virus</b> -- use default ip and port \"+char(10)+
	\"E.G: <b>rshell @home</b> -- use default ip, port, name\"+char(10)+char(10)+
	\"See also: rsi -h\"+char(10)+
	\"Extra:<b> rshell [-h|help] extra -- display extra help page for general rshell information.\"
	if not arg2 then arg2 = \"ps\"
	if not arg3 or typeof(arg3) != \"string\" then arg3 = HOME_SERVER[7] else arg3 = arg3.to_int
	if typeof(arg3) != \"number\" then
		print(\"rshell: invalid port, defaulting to \"+HOME_SERVER[7])
		arg3 = HOME_SERVER[7]
	end if
	if globals.metaxploit then return metaxploit.rshell_client(arg1,arg3,arg2) else return \"rshell: metaxploit.so not found\"
end function
command.sphinx = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return colorRed+\"<u>5phinx:</color> network penetration test tool\"+char(10)+
	\"Press F1 or ? within 5phinx for further help.\"+char(10)+
		\"Usage: sphinx -- launch 5phinx\"+char(10)+
		\"Usage: <b>sphinx [ip] [port]</b>\"+char(10)+
		\"-- preset targetIp and targetPort with\"+char(10)+
		\"-- port 0 == router port\"+char(10)+
		\"-- port 8080 == router http port!!\"+char(10)+
		\"Hint: to attack a router within the netwrok target the LAN IP of the router first. \"+char(10)+
		\"-- then target port 8080 and exploit it\"+char(10)+
		\"-- this is done on the same network as the router\"+char(10)+
		\"Hint: Use the arrow keys to access additional windows in 5phinx\"+char(10)+
		\"-- Up goes to a useless bank grabber\"+char(10)+
		\"-- Right goes to a useful quick menu, right again goes to malp\"+char(10)+
		\"-- Down takes you to herme5\"+char(10)+
		\"-- Left takes you to malp\"+char(10)+
		\"-- return to the main screen by pressing the opposite arrow key\"+char(10)+
		\"Note: as usual, all results are sent to malp\"
	if not globals.metaxploit or not globals.crypto then return \"One or more required libraries was not found.\"
	if arg1 and is_valid_ip(arg1) then globals.targetIP = arg1
	if arg2 and typeof(arg2.to_int) == \"number\" then 
		globals.targetPort = arg2.to_int 
	else 
		if not globals.targetPort then globals.targetPort = \"router\"
	end if
	if DEBUG then print \"<b>debug: ip is \"+globals.targetIP+\" and port is: \"+globals.targetPort+\" which is a: \"+typeof(globals.targetPort)
	globals.main
	return 0
end function
if DEBUG then 
	if command.hasIndex(\"sphinx\") then print \"debug: sphinx loaded!\"
end if
command.silentclean = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then
		return \"<u>SILENTCLEAN || silentclean || log wipe || scrubber || corrupt logs\"+char(10)+
		\"Usage: silentclean [opt:-d|-n|--n] -- corrupt the system.log\"+char(10)+
		\"-- operates on active computer/shell object (ie it respects glasspool)\"+char(10)+
		\"-- does NOT accept piped objects (use rclean for that)\"+char(10)+
		\"Usage: \"+colorWhite+\"</b>silentclean \"+CT+\"-- corrupt system.log of active computer/shell object\"+char(10)+\"--\"+char(10)+
		\"Usage: \"+colorWhite+\"</b>silentclean \"+CT+\"[\"+colorWhite+\"-d\"+CT+\"] -- delete rkit and/or 5hell, then corrupt system.log\"+char(10)+\"--\"+char(10)+
		\"Usage: \"+colorWhite+\"</b>silentclean \"+CT+\"[\"+colorWhite+\"-n\"+CT+\"] -- nuke system, delete rkit/5hell, corrupt system.log\"+char(10)+
		\"-- use [\"+colorWhite+\"--n\"+CT+\"] on systems running <b>Xorg</b> (aka a home pc)\"+char(10)+\"--\"+char(10)+
		\"Alias: you may use <b>sc</b> in place of <b>silentclean</b>\"+char(10)+
		\"-- e.g: |><b> silentclean -d</b> is the same as:\"+char(10)+
		\"--------|><b> sc -d</b>\"+char(10)+
		colorGold+\"</b>-- this is defined in 5hell.src >> aliases section\"+char(10)+
		\"N.B. run sc as root since /var is usually write protected.\"+char(10)+char(10)+
		\"<b>Important: silentclean does not support piped objects\"+char(10)+
		\"-- use rclean [-d|-n] [piped object] instead\"+char(10)+
		\"-- or open the object with \"+colorLightBlue+\"</b>glasspool\"+CT+\" and run sc [-d|-n]\"+char(10)+
		\"-- or be fancy and use: <b>gp -d sc @B [#] </b>\"+char(10)+
		\"NOTE: if silentclean detects \"+colorLightBlue+\"Xorg \"+CT+\"as a running process on the machine:\"+char(10)+
		\"-- it will determine you are on a home pc and require an override to execute\"+char(10)+
		\"-- this is to help prevent accidentally nuking yourself\"+char(10)+
		\"-- the override flag is <b>--n</b>\"+char(10)+
		\"--ie: <b>silentclean --n</b>\"+char(10)+char(10)+
		\"N.B. silentclean [-n|--n] will remove the following:\"+char(10)+
		colorOrange+\"</b>-- /lib, /boot, /sys, 5hell, rkit\"+char(10)+
		char(10)+
		colorGold+\"Advanced: \"+char(10)+
		\"By default, silentclean will create the file /var/system.bak and move it over /var/system.log.\"+char(10)+
		\"While this works wonders for preventing traces, when the log regenerates (as it eventually will) it will\"+char(10)+
		\"generate with guest-readable permissions. To combat this, or to engage in other creative shenanigans, you\"+char(10)+
		\"may create a file called 'silentclean' or rename an empty log file, or other file, as silentclean, and this\"+char(10)+
		\"command (as well as rclean) will select that file to move over system.log. In this manner, the log is not\"+char(10)+
		\"actually corrupted, and thus retains it's permissions when the next log write occurs.\"+char(10)+
		\"Naturally, this allows you to leave 'custom' log files behind in addition to just covering your tracks.\"
	end if
	if arg1 and typeof(arg1) != \"string\" and arg1 != \"-d\" and arg1 != \"-n\" then print colorOrange+\"silentclean: <b>ignoring</b> unsupported input\"+char(10)+\"-- instead: use rclean [opt:-d|-n] [piped_object]\"+char(10)+\"-- or open the object with glasspool then run sc [-d|-n]\"+char(10)+\"--eg: <b>gp -d \"\" sc -d \"\"\"
	if arg2 then print colorOrange+\"silentclean: warning: additional parameters detected\"+char(10)+\"-- silentclean does not support piped objects\"+char(10)+\"-- use rclean instead\"
	cleaner = command.tree(\"/\",\"5hell\",\"1\",\"N\")
	if cleaner then 
		if cleaner.parent.name == \"rkit\" then cleaner = cleaner.parent
	end if
	syslog = globals.get_file(\"/var/system.log\")
	if not syslog then return \"silentclean: <b>/var/system.log not found!!</b>\"

	nuke_em = function()
		libFolder =  globals.get_file(\"/lib\")
		bootFolder = globals.get_file(\"/boot\")
		systemFolder = globals.get_file(\"/sys\")
		if cleaner then cleaner.delete
		if libFolder then libFolder.delete
		if bootFolder then bootFolder.delete
		if systemFolder then systemFolder.delete
		print(\"Files nuked. Reboot when ready.\")
	end function

	if syslog and syslog.has_permission(\"w\") and syslog.parent.has_permission(\"w\") then
		// check for file named silentclean
		syslogbak = command.tree(\"/\",\"silentclean\",\"1\",\"N\")
		if not syslogbak then 
			localmachine.touch(\"/var\",\"system.bak\")
			syslogbak = globals.get_file(\"/var/system.bak\")
		end if
		if typeof(syslogbak) == \"file\" then
			//syslog.delete
			if not syslogbak.is_binary then syslogbak.set_content(\"No IPs Today :D\")
		else
			return \"silentclean: write failed; permission denied\"
		end if
		if arg1 == \"-n\" then 
			if globals.localmachine.show_procs.indexOf(\"Xorg\") == null then arg1 = \"--n\" else return \"silentclean: \"+colorOrange+\"</b>detected home pc; execution halted\"+char(10)+\"-- re-run with \"+colorWhite+\"</b>silentclean --n\"+CT+\" to override\"
		end if
		if arg1 == \"--n\" then nuke_em
		if arg1 == \"-d\" or arg1 == \"--n\" then
			if cleaner then cleaner.delete
		end if
		try = syslogbak.move(\"/var\", \"system.log\")
		syslog = globals.get_file(\"/var/system.log\")
		// add code to give the new file the same permissions as the original log
		return try
	else
		return \"silentclean: write failed; permission denied\"
	end if
	return 0
end function
command.scrub = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"logs || log scrubbing || proxy management || scp\"+char(10)+
	\"Usage: scrub [opt:-s] -- wipe logs of all proxies using kraken \"+char(10)+
	\"-- the [-s] option scrubs the logs with a file named 'silentclean' stored on the server\"+char(10)+
	\"-- this requires a file named silentclean to be somewhere on the proxy\"+char(10)+
	\"-- it may be an empty file\"+char(10)+
	\"note: uses the command<b> kraken scrub\"
	return command.kraken(\"scrub\", arg1, arg2)
end function
command.prox = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"KRAKEN shortcut || proxy tunneling\"+char(10)+\"
	Usage: prox -- use kraken to route through proxy net and open terminal at end\"+char(10)+
	\"-- equivalent to<b> kraken connect\"
	return command.kraken(\"connect\", arg1, arg2)
	return 0
end function
if DEBUG then print(\"<size=75%>loading ...kraken.5pk...(10.875b)</size>\")
// gonna have to completely reqrite kraken, otherwise it's going to become impossible to maintain
command.kraken = function(arg1, arg2=0, arg3=0, arg4=0) // release the kraken!
	kraken_help = function()
		return \"Usage: kraken [optional: upload_path] propagate file or folder to all proxies, chlock, delete /etc/passwd using Config/Map.conf\"+char(10)+\"shortcuts: kraken connect == prox\"+char(10)+\"shortcuts: kraken scrub == scrub\"+char(10)+\"Usage: kraken [/path|prox|scrub|-l|buffer] -- shells will be sent to BUFFER.\"+char(10)+\"New: kraken [command] [-s] -- run silentclean locally on each proxy after command. (if silentclean is installed on that system)\"+char(10)+\"Advanced: kraken [add|del|show] [opt:ip] [opt:pass] -- add|remove items to|from Map.conf or display current map.\"+char(10)+\"Usage:<b> kraken show -p </b>-- show proxy list with passwords.\"+char(10)+\"New:<b> kraken -l </b> -- download logs from proxies (and then scrub)\"+char(10)+\"Usage: kraken -- launch kraken menu\"+char(10)+\"NEW: kraken will no longer scrub logs by default! \"+char(10)+\"-- please use <b>kraken scrub</b> or the shortcut <b>scrub</b> to clean corrupt proxy logs.\"+char(10)+\"Logs are still scrubbed by default when running:\"+char(10)+\"-- kraken -l, kraken connect, prox (shorcut for kraken connect)\"+char(10)+\"-- kraken scrub, scrub (shorcut for kraken scrub)\"+char(10)+\"Kraken will <b>not</b> autoscrub for:\"+char(10)+\"-- kraken [path] and/or  kraken buffer\"
	end function
	if arg1 == \"-h\" or arg1 == \"help\" then return kraken_help
	map_path = home_dir + \"/Config/Map.conf\"
	map_file = globals.get_file(map_path)
	if not map_file then
		print( \"kraken: map.conf not found. \" )
		mak_map = user_input(\"Create it? [Y/n] ||: \",0,1)
		if mak_map.lower == \"n\" then return \"aborting...\"
		print localmachine.touch(home_dir+\"/Config\", \"Map.conf\")
		map_file = globals.get_file(map_path)
		if map_file then print(home_dir+\"/Config/Map.conf created.\") else return \"kraken: write error!\"
	end if
	map_contents = map_file.get_content
	//map read
	print(colorCyan+\"Initializing Kraken v 0.9.5 by Plu70...\"+CT)
	time_s = time
	MAP = {}
	MAP.accounts = {\"accounts\":[{\"user\":\"user\",\"ip\":\"ip\",\"password\":\"password\"}]}

	MAP.init = function(map_string)
		if map_string == \"\" then //return \"Kraken: empty Map.conf\"
			map_string = \"{\"\"accounts\"\":[],\"\"historyConnections\"\":[]}\"
		end if
	  MAP.accounts = slice(map_string, 12).split(\"}\")
	end function

	proxy = {}
	proxy.accounts = {}
	proxy.set = function(i,k,v,ik,iv,pk,pv)
	  proxy.accounts[i] = {k:v,ik:iv,pk:pv}
	end function
	proxy.show = function(show_pass)
		ps = null
		i = 0
		for pr in proxy.accounts
			if show_pass == \"-p\" then ps = \"root@\"+pr.value.password+\" \"
			print(\"[\"+colorWhite+i+CT+\"]<b> \"+ps+pr.value.ip+\" </b>\")
			i = i + 1
		end for
	  return 0
	end function
	proxy.add = function(ip,pass)
	  proxy.accounts[proxy.accounts.len] = {\"user\":\"root\",\"ip\":ip,\"password\":pass}
	  return \"added: root@\"+pass+\" \"+ip
	end function
	proxy.del = function(int)
	  if proxy.accounts.hasIndex(int.to_int) then
	    tar = proxy[\"accounts\"][int.to_int][\"ip\"]
	    proxy.accounts.remove(int.to_int)
	    return \"deleted: \"+tar
	  else
	    return \"invalid index\"
	  end if
	end function

	proxy.save = function()
		out = {\"accounts\":[],\"historyConnections\":[]}
		for i in proxy.accounts
			out.accounts.push(i.value)
		end for
		string = \"{\"\"accounts\"\":[\"+out.accounts.join(\",\")+\"],\"\"historyConnections\"\":[]}\"
		final = \"\"
		for char in string
			if char != \" \" then final = final + char
		end for

		// if Map.conf is meant to be binary, convert final to code
		// -- write Map.conf.src with code
		// -- make Map.conf and copy it over Map.conf.src then rename to Map.conf 

		map_source = \"if get_custom_object.hasIndex(\"\"kraken_password\"\") and get_custom_object.kraken_password == \"\"password\"\" then get_custom_object.kraken_map = \"\"\"+final+\"\"\" else exit \"\"kraken: access denied;get_custom_object.remove(\"\"kraken_password\"\");exit \"\"kraken: write complete\"\"\"
		make_map = false
		if make_map == true then 
			map_file = command.poke(map_path)
			map_folder = map_path.replace(\"/Map.conf\",\"\")
			if typeof(map_file) != \"file\" then return \"kraken: cannot create Map.conf\"+char(10)+\"-- \"+map_file
			map_file.move(map_folder,\"Map.conf.src\")
			map_file.set_content(map_source)
			globals.shell.build(map_file.path,map_folder) 
			map_conf = globals.get_file(map_path)
			if not map_conf then return \"kraken: failed to build Map.conf\"
			map_conf.move(map_path.replace(\"/Map.conf\",\"\"),\"Map.conf.src\") 
			map_conf.move(map_path.replace(\"/Map.conf\",\"\"),\"Map.conf\") 
			return \"kraken: successfully built Map.conf\"
		end if

		new_map = globals.get_file(map_path)
		if not new_map then return \"kraken: error; Map.conf vanished!\"
		if new_map.has_permission(\"w\") then new_map.set_content(final) else return \"kraken: write error, Map.conf not saved!\"
		return colorOrange+\"</b>kraken: saved map to \"+new_map.path
	end function

	MAP.parse = function()
	  accts = []
	  m_size = MAP[\"accounts\"].len
	  for m in MAP[\"accounts\"]
	    //print(m_size)
	    m_size = m_size - 1
	    m = m.replace(\"{\",\"\")
	    m = slice(m,1)
	    //print(m)
	    if m and m_size > 1 then accts.push(m.split(\",\"))
	  end for
	  i = 0
	  for a in accts
	    //print(format_columns(a[0] + \" \" + a[1] + \" \" + a[2] ))
	    line = a[0].split(\":\")
	    key = line[0]
	    key = slice(key,1,-1)
	    val = line[1]
	    val = slice(val,1,-1)
	    nums = a[1].split(\":\")
	    ik = nums[0]
	    ik = slice(ik,1,-1)
	    iv = nums[1]
	    iv = slice(iv,1,-1)
	    pass = a[2].split(\":\")
	    pk = pass[0]
	    pk = slice(pk,1,-1)
	    pv = pass[1]
	    pv = slice(pv,1,-1)
	    proxy.set(i,key,val,ik,iv,pk,pv)
	    i = i + 1
	  end for
	end function

	scrub = false
	connect = false
	get_logs = false
	map_file = localmachine.File(home_dir + \"/Config/Map.conf\")
	//MAP.init(map_file.get_content)
	MAP.init(map_contents)
	MAP.parse
	time_e = (time - time_s)
	print(\"...init completed in [\"+colorOrange+time_e+CT+\"] seconds.\")
	print(colorCyan+\"////////////////////////////////////////////////////////\"+CT)
	waitFor = null
	if arg1 then waitFor = arg1
	print(\"Proxy net consists of \"+proxy[\"accounts\"].len + \" nodes: \")
	print(colorOrange+\"</b>!Kraken will no longer scrub your proxy logs by default!<b>\"+CT)
	print(colorOrange+\"</b>Run:<b> scrub</b> or<b> kraken scrub </b>manually to corrupt logs.\"+CT)
	print(colorOrange+\"</b>Logs <u>will</u> be scrubbed for: <b>kraken connect</b> and the <b>prox</b> command.\")
	last_shell = shell
	if not waitFor then waitFor = user_input(\"[\"+colorCyan+\"/path/to_file_or_folder\"+CT+\"] = upload to all proxies and BUFFER shells\"+char(10)+\"[\"+colorWhite+\"prox\"+CT+\"] route through proxies and open shell at last proxy \"+char(10)+\"[\"+colorWhite+\"-l\"+CT+\"] download (then scrub) proxy logs and BUFFER shells\"+char(10)+\"[\"+colorWhite+\"scrub\"+CT+\"] scrub logs on all proxies and BUFFER shells\"+char(10)+\"[\"+colorWhite+\"show\"+CT+\"] show ips of proxies in map\"+char(10)+\"[\"+colorWhite+\"add\"+CT+\"] add proxy to map \"+char(10)+\"[\"+colorWhite+\"del\"+CT+\"] remove proxy from map \"+char(10)+\"[\"+colorWhite+\"buffer\"+CT+\"] = add all proxies to BUFFER without scrubbing\"+char(10)+\"[help] show help\"+\" [q]=quit \"+char(10)+\"kraken:> \",0,0)
	if waitFor == \"q\" or waitFor == \"Q\" or waitFor == \"\" then return \"Aborting...\"
	if waitFor == \"help\" or waitFor == \"-h\" then return kraken_help
	if typeof(waitFor) == \"file\" then waitFor = waitFor.path
	if typeof(waitFor) != \"string\" then return \"kraken: invalid input: expects file_object or string\"
	if waitFor.split(\" \")[0] == \"show\" then
		if waitFor.split(\" \").len > 1 then return proxy.show(waitFor.split(\" \")[1])
		return proxy.show(arg2)
	end if
	if waitFor.split(\" \")[0] == \"-l\" then
		get_logs = true
		if localmachine.File(\"/root/logs\") then
			print(\"kraken: found /root/logs/ \")
		else
			mklog = user_input(\"/root/logs not found. create it? [Y/n] ||: \",0,1)
			if mklog == \"n\" then return
			localmachine.create_folder(\"/root\", \"logs\")
			if localmachine.File(\"/root/logs\") then print(\"kraken: created /root/logs\") else return \"kraken: write error: unable to create /root/logs\"
		end if
		print(\"kraken: saving proxy logs to /root/logs\")
		print(\"Logs are numbered in reverse order. First in Map.conf will have <b>highest</b> number.\")
		print(\"e.g. 5 total proxies: the first in map.conf will be saved as system-5.log and the last will be system-1.log\")
		print(\"<size=85%><u>logs will not be overwritten when re-running this command. mind your drive space.</u></size>\")
	end if
	if waitFor == \"add\" then
		nip = arg2
		npa = arg3
		if not arg2 then nip = user_input(\"add_ip:> \")
		if nip == \"\" then return \"aborting...\"
		if not arg3 then npa = user_input(\"add_pass:> \",1,0)
		if npa == \"\" then return \"aborting...\"
		if not is_valid_ip(nip) then return \"Kraken: invalid ip.\"
		if npa == \"\" or npa == \" \" then return \"Kraken: invalid password.\"
		print(\"Adding: \"+nip+char(10)+proxy.add(nip, npa))
		proxy.show
		return proxy.save
	end if
	if waitFor == \"del\" then
		proxy.show
		del_me = arg2
		if not del_me then del_me = user_input(\"del# (q=quit):> \")
		if del_me == \"\" or del_me == \" \" or del_me.lower == \"q\" then return \"aborting...\"
		print(proxy.del(del_me))
		proxy.show
		return proxy.save
	end if
	buffer = false
	if waitFor == \"buffer\" then buffer = true
	if waitFor == \"-l\" or waitFor == \"scrub\" or waitFor == \"connect\" or waitFor == \"prox\" then
		scrub = true
		if waitFor == \"connect\" or waitFor == \"prox\" then
			connect = true
			if not proxy[\"accounts\"].len then return \"kraken: no proxy found.\"
		end if
	else
		scrub = false
	end if
	fileOrFolder = \"scrub\"
	if not scrub and not buffer then fileOrFolder = localmachine.File(waitFor)
	if not fileOrFolder then return \"kraken: file not found.\"
	upload_path = \"scrub\"
	if not scrub and not buffer then upload_path = fileOrFolder.path
	destination_path = \"scrub\"
	if not scrub and not buffer then destination_path = fileOrFolder.parent.path
	if not scrub and not buffer then print(\"Uploading \"+upload_path+\" to \"+destination_path+\"...\")
	remote = null
	for prx in proxy[\"accounts\"]
		print(\"<b>Connecting: </b>\" + prx.value.user + \"@\" + \"***************\" + \" \" + prx.value.ip)
		remote = last_shell.connect_service(prx.value.ip, 22, prx.value.user, prx.value.password)
		if typeof(remote)  != \"shell\" then return \"Connection failed.\"
		if not scrub and not buffer then shell.scp(upload_path, destination_path, remote)
		BUFFER.push(remote)
		last_shell = remote
	end for
	if not remote then return \"kraken: connection error\"
	o = 0
	for el in range(1,proxy[\"accounts\"].len)
		o = o - 1
		if get_logs then
			print(colorCyan+\"Fetching log: \"+CT+char(10)+BUFFER[o].scp(\"/var/system.log\",\"/root/logs\",globals.shell))
			got_log = localmachine.File(\"/root/logs/system.log\")
			if got_log then
				wait(1)
				oi = str(o)
				while got_log.rename(\"system\"+oi+\".log\") == \"There is already a file with that name, please choose another one.\"
					oi = oi+str(o)
				end while
				print(\"Kraken: pulled log to<b> /root/logs/system\"+oi+\".log </b>\")
			else
				if get_logs then print(colorOrange+\"</b>Kraken: log missed!<b>\"+CT)
			end if
		end if
		if scrub then
			print(\"Scrubbing log...\")
			root = BUFFER[o].host_computer.File(\"/\")
			root.chmod(\"o-rwx\", 1)
			root.chmod(\"g-rwx\", 1)
			root.chmod(\"u-rwx\", 1)
			pwf = remote.host_computer.File(\"/etc/passwd\")
			if pwf then pwf.delete
			if arg2 == \"-s\" or arg3 == \"-s\" then
				catch = BUFFER[o].launch(\"/root/rkit/silentclean\")
				_cascade // exit if cascade
				if catch then
					print(catch)
				else
					print(\"<b>Scrubbed.</b>\")
				end if
			else
				catch = rclean(BUFFER[o])
				if catch then
					print(catch)
				else
					print(\"<b>Scrubbed.</b>\")
				end if
			end if
		end if
	end for
	print(colorCyan+\"Kraken: task complete in </b>\"+colorOrange+(time - time_s)+colorCyan+\"<b> seconds.\"+CT)
	print(colorCyan+\"////////////////////////////////////////////////////////\"+CT)
	if connect then 
		get_custom_object.return_value = \"#!#CASCADE#!#\"
		exit remote.start_terminal
	end if
	return 0
end function

//////data3a5e////////////////
command.liber = function(arg1, arg2, arg3=0, arg4=0) // requires metaxploit.so
	if not metaxploit then return \"Error: metaxploit.so not found\"
	//if GLASSPOOL then return \"liber: local use only.\"
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"library version info || LIBER || metaLib version || liber te\"+char(10)+
	\"<b>Usage: liber [/path/lib_file|MetaLib] -- returns library name and version\"+char(10)+
	\"--e.g: liber /usr/cache/libhttp.so -- get name and version \"+char(10)+
	\"--e.g: bios -m | liber\"+char(10)+
	\"<b><color=white>Usage: liber [-l] [libname] -- returns version info for libname located in /lib/\"+char(10)+
	\"--e.g: liber [-l] libssh.so -- get info for /lib/libssh.so\"+char(10)+
	\"<b>Usage: liber [-l] -- print version info for all libraries in /lib\"+char(10)+
	\"<b>Usage: liber [/folder] -- print version info for all libraries in folder\"+char(10)+
	\"--e.g: liber /usr/libcache\"+char(10)+
	\"<b>Usage: liber [-i] [/path/lib_file] -- returns an imported lib object from path\"+char(10)+
	\"-- equivalent to <b>bios -i [/path]</b>\"+char(10)+
	\"-- [-i] is for API objects such as metaxploit, crypto, blockchain, aptclient, etc\"+char(10)+
	\"---- user <b>meta link [-l|-r]</b> to link metalib or netsession objects\"+char(10)+
	\"--e.g: liber [-i] [/lib/blockchain.so] | malp -- imports lib and pipes to malp (BUFFER)\"+char(10)+
	\"NOTE : liber is limited to the scope of the <b>metaxploit</b> object currently in use.\"+char(10)+
	\"NOTE : liber will color code results if database.csv exists\"+char(10)+
	\"---- \"+colorOrange+\"orange means the library is unkown\"+char(10)+
	\"---- \"+colorCyan+\"cyan means the library is known\"+char(10)+
	colorWhite+\"Usage: liber [-r|-lr] [path|libname] -- run as above but return raw output\"
	color_on = true
	if arg1 == \"-r\" then 
		color_on = false 
		arg1 = arg2
		arg2 = arg3 
		arg3 = arg4
	end if
	l_path = arg1
	if typeof(l_path) == \"MetaLib\" then return arg1.lib_name+\" v \"+arg1.version
	if typeof(l_path) != \"string\" and typeof(l_path) != \"file\" then return \"liber: invalid type: expects file, string, or metalib\"
	if arg1 == \"-i\" then 
		if not arg2 then arg2 = user_input(\"path to lib:> \").lower.trim
		if arg2 == \"\" then return \"liber: -i expects a path\"
		print colorWhite+\"<u>liber: running command.bios -i \"+arg2+CT+\"</u>\"
		return command.bios(arg1,arg2)
	end if
	if arg1 == \"-l\" or arg1 == \"-lr\" then 
		if arg1 == \"-lr\" then color_on = false 
		if arg1 == \"-lr\" then arg1 = \"-l\"
		if arg2 and typeof(arg2) == \"string\" then l_path = \"/lib/\"+arg2 else l_path = \"/lib\"
		if arg2 and typeof(arg2) != \"string\" then print \"liber: expects path as a string.\"
	end if
	if DEBUG then print(\"liber: l_path = \"+l_path+\" and is a \"+typeof(l_path))
	if typeof(l_path) == \"string\" then lib_file = globals.get_file(l_path)
	if typeof(l_path) == \"file\" then lib_file = l_path
	if not lib_file then return(\"File not found.\")
	if DEBUG then print(\"got: \"+typeof(lib_file))
	print colorGreen+\"<u>==========liber==========\"
	buf = []
	if lib_file.is_folder then
		for f in lib_file.get_files
			lib = metaxploit.load(f.path)
			if typeof(lib) != \"MetaLib\" then
				buf.push(\"liber: \"+lib_file.path+ \": unknown format\")
			else
				buf.push( lib.lib_name + \" v \" + lib.version )
			end if
		end for
	else
		lib = metaxploit.load(lib_file.path)
		if typeof(lib) != \"MetaLib\" then
			buf.push(\"liber: \"+lib_file.path+ \": unknown format\")
		else
			buf.push( lib.lib_name + \" v \" + lib.version )
		end if
	end if
	// check libs in buf against database
	datbas = command.tree(\"/\",\"database.csv\",1,\"N\")
	if DEBUG then print \"debug: datbas: \"+datbas
	if DEBUG then 
		if typeof(datbas) == \"file\" then print \"debug: \"+datbas.path 
	end if
	if datbas and datbas.has_permission(\"r\") then 
		dbase_data = datbas.get_content.split(char(10))
		db_buf = []
		for db_entry in dbase_data
			if db_entry.indexOf(\"Hooked:\") != null then continue
			db_buf.push(db_entry)
		end for
		dbase_data = db_buf
		if DEBUG then print \"debug: buf: \"+char(10)+buf
		if DEBUG then print \"debug: buf size: \"+buf.len
		if DEBUG then print \"debug: dat size: \"+dbase_data.len
		b_index = 0 // buf index
		d_index = 0 // dbase_data index
		color_known = colorCyan+\"</b>\"
		color_unkwn = colorOrange+\"</b>\"
		for entry in buf 
			if DEBUG then print \"debug: entry: \"+entry
			if DEBUG then 
				print \"-- B[\"+b_index+\"] -- \"
				print \"-- B[\"+buf[b_index]+\"]\"
			end if
			if color_on then 
				if dbase_data.indexOf(entry) != null then buf[b_index] = color_known+entry+CT else buf[b_index] = color_unkwn+entry+CT 
			end if
			b_index = b_index + 1
			d_index = 0
		end for
	else 
		print \"liber: database.csv not found or read protected;\"
		print \"-- skipping database check\"
	end if
	if DEBUG then print \"debug: buf: \"+char(10)+buf
	return format_columns(buf.join(char(10)))
end function
//////////////////BEGIN DATABASER/////////////////
command.db = function(arg1, arg2, arg3=0, arg4=0)
    if not globals.metaxploit then return colorRed+\"</b>db: error: metaxploit is not loaded\"
    remote = false
    pre_load = false
    inject = null
    lib_path = \"\"
	db_usage = \"<b><u>DB || dbaser || Databaser</u>\"+char(10)+
	colorLightBlue+\"</b>Automated remote port and local lib scanning and databasing.\"+char(10)+
	colorLightBlue+\"</b>Results are sent to the BUFFER.\"+char(10)+
	colorLightBlue+\"Database is saved to <u>~/rkit/database.csv\"+char(10)+
	colorOrange+\"Logs: </b>logs will be left by db when:\"+char(10)+
	\"-- a net_session is obtained on a server (not a router):\"+char(10)+
	\"-- \"+colorWhite+\"</b>connection established port ##\"+char(10)+
	\"-- a shell object is obtained on any machine:\"+char(10)+
	\"-- \"+colorWhite+\"shell obtained on port ##\"+char(10)+
	colorOrange+\"Note:</b> logs may be left in other ways. See: \"+colorGreen+\"help logs\"+CT+\" for more.\"+char(10)+char(10)+
	\"Note: targetIP and targetPort are set with <b>probe</b> and/or <b>target</b>\"+char(10)+char(10)+
	colorWhite+\"</b>Usage: db [\"+colorRed+\"-r\"+CT+\"] [opt:ip] [opt:port] [opt:inject]\"+char(10)+
	\"-- scans given port and databases results\"+char(10)+
	\"-- uses targetIP and targetPort if not supplied\"+char(10)+
	\"-- supplying [-i] for inject results in a prompt\"+char(10)+
	\"---- enter a lan_ip or password for the inject value at the prompt\"+char(10)+
	\"Usage: db -r [ip] <color=yellow>*</color> -- db all ports at given ip\"+char(10)+
	\"Usage: db -r <color=yellow>*</color> -- db all ports of targetIP\"+char(10)+char(10)+
	\"Usage: db -r -i -- \"
	colorWhite+\"</b>Usage: db [\"+colorCyan+\"-l\"+CT+\"] [opt:lib_name] [opt:inject]\"+char(10)+
	\"-- scan a local lib and database resutls\"+char(10)+
	\"-- brings up menu if lib_name not supplied\"+char(10)+
	\"-- supplying [-i] for inject results in a prompt\"+char(10)+
	\"---- enter a lan_ip or password for the inject value at the prompt\"+char(10)+
	\"Usage: db -l <color=yellow>*</color> -- db all local libs\"+char(10)+char(10)+
	\"Usage: db -l -i -- choose a lib from the menu and prompt for an inject\"+char(10)+
	colorWhite+\"</b>Usage: db [\"+colorMagenta+\"-m\"+CT+\"] [opt:metaLib|metaxploitLib] [opt:metaxploitLib|metaLib] [opt:inject]\"+char(10)+
	\"-- scan currently linked metaLib or piped metaLib with currently linked metaxploitLib or piped metaxploitLib\"+char(10)+
	\"-- unlike other modes, this mode will not link a new metaLib\"+char(10)+
	\"---- unless a metalib is piped to it\"+char(10)+
	\"-- instead, it scans the already linked metaLib\"+char(10)+
	\"-- supplying [-i] for inject results in a prompt\"+char(10)+
	\"---- use <b>meta link [piped_metaLib]</b> to choose a metaLib to scan\"+char(10)+
	\"---- use <b>meta -i [pipe_metaxploitLib]</b> to choose the scanning metaxploitLib\"+char(10)+
	\"---- see <b>meta help</b> for more\"+char(10)+char(10)+
	\"Note: Use <b>meta link</b> and <b>meta scan</b> to scan without databasing\"+char(10)+
	\"Note: It is not possible exploit/database libs that are not in the /lib folder\"+char(10)+
	\"Note: the default 'inject' is '192.168.0.2' to avoid unintentional password changes\"
	if arg1 == \"-h\" or arg1 == \"help\" then return(db_usage)
	if typeof(arg1) != \"string\" or [\"-m\",\"-r\",\"-l\"].indexOf(arg1) == null then return \"db: invalid flag: expects -m|-r|-l\"
	if DEBUG then print(\"In command.db...\")
	inject = null
	if DEBUG then print(\"db: arg2: \"+arg2+\" arg3: \"+arg3+\" arg4: \"+arg4)
    // params: -m -metaLib (scan linked metaLib or piped metaLib)
	if arg1.lower == \"-m\" then 
		pre_load = true
		print colorLightBlue+\"<size=75%></b>db: preparing custom scan...\"
		if arg2 != \"-i\" then 
			if DEBUG then print \"debug: db -m: arg2: \"+arg2+\" arg3: \"+arg3+\" arg4: \"+arg4
			if typeof(arg2) == \"MetaxploitLib\" then print command.meta(\"-i\",arg2) 
			if typeof(arg3) == \"MetaxploitLib\" then print command.meta(\"-i\",arg3) 
			if typeof(arg4) == \"MetaxploitLib\" then print command.meta(\"-i\",arg4) 
			if typeof(arg2) == \"MetaLib\" then print command.meta(arg2)
			if typeof(arg3) == \"MetaLib\" then print command.meta(arg3)
			if typeof(arg4) == \"MetaLib\" then print command.meta(arg4)
			// add some error checking here ^
			// we check for -i after we check for all the other flags
		end if
		if not globals.metaLib then return \"db: link or pipe a metaLib before using -m\" else print colorLightBlue+\"<size=75%></b>db: custom scan ready\"
	end if
	if not globals.metaxploit then return \"metaxploit.so not found\"
    // params: -r|-R -remote (scan remote target)
	if arg1.lower == \"-r\" then
		remote = true
		if arg2 == \"-i\" or arg3 == \"-i\" or arg4 == \"-i\" then 
			inject = user_input(\"db: please supply an inject value\"+char(10)+\"db: enter a lan ip for a bounce exploit\"+char(10)+\"db: enter a password for pw change exploits\"+char(10)+\"inject:> \"+colorGold+\"</b>\")
			if inject == \"\" then print \"db: ok, using nothing as an inject\"
		end if
		if not arg2 or arg2 == \"-i\" then
			arg2 = globals.targetIP
			arg3 = globals.targetPort
		end if
        if not is_valid_ip(arg2) and arg2 != \"*\" then return \"db: invalid target ip\"
        if is_valid_ip(arg3) then globals.targetIP = arg3
        if is_valid_ip(arg2) then globals.targetIP = arg2
        if arg2 == \"*\" then 
            if is_valid_ip(arg3) then arg2 = arg3 else arg2 = globals.targetIP
            arg3 = \"*\"
        end if
        if not globals.targetIP then return \"db: error: supply or set a target ip\"
        if arg3 == \"*\" then 
            // get all ports on target
            if is_valid_ip(arg2) then rr = get_router(arg2) else rr = \"\"
            if typeof(rr) == \"router\" then 
                locals.ports = rr.used_ports
                if DEBUG then print \"debug: rr is a router. ports are: \"+ports
            else 
                if DEBUG then print \"debug: guessing gateway...\"
                gate_guess = arg2.split(\"\\.\")
                gate_guess[-1] = \"1\"
                gate_guess = gate_guess.join(\".\")
                rr = get_router(gate_guess)
                if typeof(rr) == \"router\" then 
                    locals.ports = rr.used_ports
                    if DEBUG then print \"debug: rr found a router. ports are: \"+ports
                else 
                    return \"db: target has non-standard gateway.\"+char(10)+\"db: try again with gateway ip\"
                end if
            end if
            if DEBUG then 
                if ports.len > 0 then print \"debug: port[0]: \"+ports[0].port_number else print \"debug: no ports found\"
            end if
            for port in locals.ports
                p = str(port.port_number)
                print colorCyan+\"db: -r \"+arg2+ \" \"+ p // we dont scan the router here. once this finishes, router is scanned below
                command.db(arg1, arg2, p, inject)
            end for 
        end if 
        if arg3 == 0 or arg3 == \"0\" then arg3 = \"router\"
        if typeof(arg3) == \"number\" then arg3 = str(arg3)
        if arg3 != \"router\" and arg3 != \"*\" then
            globals.targetPort = arg3.to_int
        else
            globals.targetPort = \"router\"
        end if
	end if
	// params: -l|-L -local_libs (/lib) (scan local lib)
	if arg1 == \"-l\" or arg1 == \"-L\" then
		remote = false
		if arg2 and arg2 != \"-i\" then
			if arg2 == \"*\" then          ///////// wildcard! babY! ////////////
				lib_f = localmachine.File(\"/lib\")
				if not lib_f then return \"db: /lib folder not found!\"
				libs = lib_f.get_files
				for l in libs  
					arg2 = l.name
					print colorCyan+\"db: -l \"+arg2
					command.db(arg1,arg2,inject)
				end for 
				return 0
			end if
			lib_path = \"/lib/\"+arg2
		else 
			lib_path = \"/lib/\"+globals.get_lib(\"L\").split(\" \")[0]
			if DEBUG then print(\"lib_path \"+lib_path)
		end if
	end if
	// arg: -f|-F -path_to_file (add file or folder to db)
	if arg1.lower == \"-f\" then
		return \"depricated function\"
	end if
	// params: -i -inject (inject value)
    if arg2 == \"-i\" or arg3 == \"-i\" or arg4 == \"-i\" then inject = user_input(\"enter a lan ip or password for injects:> \")
	if DEBUG then print \"debug: purging xploits\"
	command.purge(\"-x\", \"y\")
	DATA = []
	lib_info = function()
		if typeof(globals.metaLib) != \"MetaLib\" then return \"MetaLib: error 266\"
		info = globals.metaLib.lib_name + \" v \" + globals.metaLib.version
		return info
	end function
	load_lib = function()  // remote false
		globals.metaLib = metaxploit.load(lib_path)
		if globals.metaLib then
			if DEBUG then print(lib_info)
		else
			return \"Error. File not found.\"
		end if
	end function
	get_lib = function() // remote true
		if globals.targetPort == \"router\" then
			net_session = globals.metaxploit.net_use( globals.targetIP )
		else
			net_session = globals.metaxploit.net_use( globals.targetIP , globals.targetPort )
		end if
		if net_session then
			globals.metaLib = net_session.dump_lib
		else
			print(\"Error. Can't establish net session.\")
			return
		end if
		if DEBUG then print(\"debug: db: lib_info\"+lib_info)
	end function
	if remote then
		if not pre_load then get_lib // pre_load == true means db the currently loaded metaLib (wip)
	else
		if not pre_load then load_lib // this means we don't link or load a lib here
	end if
	if not globals.metaLib then return colorRed+\"MetaLib: error 265: unable to link/load net_session/metaLib.\"+CT
	DATA.push(lib_info)
	if globals.metaLib then print(colorCyan+\"scanning library: \" + lib_info + char(10))
	pass_inject = \"192.168.0.2\"
	lan_inject = globals.targetIP
	if not inject or inject.trim == \"\" then
		if globals.metaLib.lib_name == \"kernel_router.so\" then 
			if is_lan_ip(globals.targetIP) then
				inject = globals.targetIP
			else
				rtt = \"\"
				if localmachine.is_network_active then rtt = get_router(targetIP) else return \"db: error: no active network connection\"
				if typeof(rtt) == \"router\" then
					ports = rtt.used_ports
					if ports.len then pt = ports[0] else pt = 0
					if typeof(pt) == \"port\" then
						inject = pt.get_lan_ip
					else
						inject = rtt.local_ip
					end if
				else
					inject = localmachine.local_ip
				end if
			end if
		else 
			print colorCyan+\"</b>db: using default inject: \"\"192.168.0.2\"\"\"
			inject = \"192.168.0.2\"
		end if 
	end if
	if inject == \"\" then inject = \"192.168.0.2\"
	if is_valid_ip(inject) then 
		lan_inject = inject 
	else 
		if is_lan_ip(globals.targetIP) then
			lan_inject = globals.targetIP
		else
			rtt = \"\"
			if localmachine.is_network_active then rtt = get_router(targetIP) else return \"db: error: no active network connection\"
			if typeof(rtt) == \"router\" then
				ports = rtt.used_ports
				if ports.len then pt = ports[0] else pt = 0
				if typeof(pt) == \"port\" then
					lan_inject = pt.get_lan_ip
				else
					inject = rtt.local_ip
				end if
			else
				lan_inject = localmachine.local_ip
			end if
		end if
		if typeof(inject) == \"string\" then pass_inject = inject 
	end if
	memory = metaxploit.scan(globals.metaLib)
	globals.MEMORY = memory
	if not memory then print(\"no exploits detected.\")
    globals.meta_scan = []
	_user_color = function( string )
		cc = colorGreen
		if string == \"???\" then cc = colorWhite
		if string == \"guest\" then cc = colorWhite 
		if string == \"root\" then cc = colorRed
		return cc+string+CT
	end function
	_object_color = function( string )
		cc = colorWhite
		if string == \"file\" then cc = colorGreen
		if string == \"computer\" then cc = colorCyan
		if string == \"shell\" then cc = colorGold
		if string == \"firewall_disable\" or string == \"password_change\" then cc = colorOlive
		return cc+string+CT
	end function
	for mem in memory
		address = metaxploit.scan_address(globals.metaLib, mem).split(\"Unsafe check:\")
        globals.meta_scan.push(address)
		for add in address
			if add == address[0] then continue
			value = add[add.indexOf(\"<b>\")+3:add.indexOf(\"</b>\")]
			value = value.replace(\"\\n\", \"\")
			result = globals.metaLib.overflow(mem, value, pass_inject)
			if result == null then
				print(colorOrange+\"checking for bounce (this process is not perfect)...\"+CT)
				if DEBUG then print \"in db: preparing to overflow: \"+ mem + \" \" + val + \" \" + lan_inject
				result = globals.metaLib.overflow(mem, value, lan_inject)
				if result then
					DATA.push(\"Hooked: \" + globals.checkUser(result) + \" \" + _object_color(typeof(result)) + \":bounce with \" + mem + \" \" + value)
					print(\"Hooked: \" + _user_color(globals.checkUser(result)) + \" \" + _object_color(typeof(result)) + colorOrange+\":bounce</color></b> with \" + mem + \" \" + value)
					globals.XPLOITS.push(mem + \" \" + value + \" \" + globals.checkUser(result) + \" \" + typeof(result)+\":bounce\")
					globals.BUFFER.push(result)
					continue
				end if
			end if
			result_type = typeof(result)
			if result == 1 or result == 0 then // firewall or password change
				if globals.metaLib.lib_name == \"kernel_router.so\" then // firewall
					result_type = \"firewall_disable\"
				else 
					result_type = \"password_change\"
				end if
			end if
			DATA.push(\"Hooked: \" + globals.checkUser(result) + \" \" + result_type + \" with \" + mem + \" \" + value)
			print(\"Hooked: \" + _user_color(globals.checkUser(result)) + \" \" + _object_color(result_type) + \" with \" + mem + \" \" + value)
			globals.XPLOITS.push(mem + \" \" + value + \" \" + globals.checkUser(result) + \" \" + result_type)
			if result then globals.BUFFER.push(result)
		end for
	end for

	print colorOrange+\"- - - - - - - - - - - - - - - - - - - - \"
	// find rkit and database.csv, confirm db.csv is in rkit
	// if no database.csv then create database.csv in rkit if present or current path if not
	/////////////////////////////////////////////////////////////
	locals.rkit = command.tree(\"/\",\"rkit\",1,\"N\")
	locals.datafile = command.tree(\"/\",\"database.csv\",1,\"N\")

	if typeof(rkit) == \"file\" and rkit.is_folder then 
		datafile = command.tree(rkit.path,\"database.csv\",1,\"N\")
		if not datafile then datafile = command.tree(\"/\",\"database.csv\",1,\"N\")
		if not datafile then 
			print \"tree: unable to locate database.csv\"
			print \"db: creating database.csv in \"+rkit.path
			localmachine.touch(rkit.path, \"database.csv\")
			datafile = localmachine.File(rkit.path+\"/database.csv\")
			if not datafile then return \"db: write error: permission denied.\"
		else 
			if datafile.parent.name != \"rkit\" then 	
				print \"db: database.csv found outside of rkit\"
				print \"db: attempting: \"+colorWhite+\"</b>mv \"+datafile.path+\" \"+rkit.path 
				print datafile.move(rkit.path,\"database.csv\")
			end if
		end if
	else
		print \"db: rkit not detected.\"
		if datafile then 
			print \"db: found \"+datafile.path
		else
			print \"db: creating database.csv in current path...\"
			localmachine.touch(currentPath, \"database.csv\")
			datafile = localmachine.File(currentPath+\"/database.csv\")
			if not datafile then return \"db: write error: permission denied.\"
		end if	
	end if
//////////////////////////////////////
	if not datafile then return(\"db: database.csv not found\")
	if datafile.has_permission(\"w\") then print \"db: writing database to: \"+datafile.path else return \"db: write error: permission denied.\"
	current_data = \"test\"
	if DEBUG then print command.file(datafile.path)
	if datafile.has_permission(\"r\") then current_data = datafile.get_content.trim.split(char(10)) else return \"db: read error: permission denied.\"
	if DEBUG then print \"debug: database before splice: \"+current_data.join(char(10)).len
	//prepare the output
	while current_data.indexOf(lib_info) >= 0
		buf_top = current_data[:current_data.indexOf(lib_info)]
		buf_bot = current_data[current_data.indexOf(lib_info):]
		buf_bot.pull
		tag = buf_bot.pull
		while tag and tag.indexOf(\"Hooked:\") >= 0
			if buf_bot.len then tag = buf_bot.pull else tag = null
		end while
		if tag then buf_top.push(tag)
		current_data = buf_top[0:]
		if buf_bot.len then current_data = current_data[0:]+buf_bot[0:]
	end while
	//write output to database.csv
	debug_loop = 0
	if DEBUG then print \"debug: database size before write is: \"+current_data.join(char(10)).len 
	if DEBUG then print \"debug: DATA size before write is: \"+DATA.join(char(10)).len
	while current_data.join(char(10)).len + DATA.join(char(10)).len > 159990 
		print \"db: \"+colorOrange+\" warning: database size exceeds 160kb\"+char(10)+colorOrange+\"db: trimming oldest entries...\"
		current_data.pull 
		while current_data[0].indexOf(\"Hooked: \") != null 
			current_data.pull 
		end while
		debug_loop = debug_loop + 1
		if DEBUG then print \"debug: trim loop: \"+debug_loop
		if DEBUG then print \"debug: database size is: \"+current_data.join(char(10)).len + DATA.join(char(10)).len
	end while
	catch = datafile.set_content(current_data.join(char(10)).trim+char(10)+DATA.join(char(10)).trim)
	if DEBUG then print command.file(datafile.path)
	if DEBUG then print datafile.get_content
	if catch then return(catch)
	return 0
end function///////////////END DATABASER//////////////////
command.linkdb = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Link Database\"+char(10)+
	\"Uasage: linkdb [target_lib] [optional:path_to_database] \"+char(10)+
	\"-- link a lib in the database that matches target_lib\"+char(10)+
	\"-- eg:<b> linkdb 1.0.1</b> \"+char(10)+
	\"-- prompts to link any entry that contains 1.0.1\"+char(10)+
	\"Usage: linkdb [target_lib] @home -- uses connect_service to access remote database for linking\"+char(10)+
	\"-- set ip, port and pw with launch params or the <b>target</b> command.\"+char(10)+
	\"-- eg:<b> linkdb kernel @home \"+char(10)+
	\"---- connects to machine at target ip and prompts to link any entry that matches 'kernel' \"
	if not arg1 then return \"linkdb: invalid input\"
	link = function(f,a,y)
		buf = f.get_content.split(char(10))
		found_it = false
		done = 0 //\"Database: \"+a+\" not found. Scan required.\"
		for line in buf
			if line.indexOf(a) >= 0 and not found_it then
				wait_for = \"y\"
				if not y then wait_for = user_input(\"Database: found \"+line+char(10)+\"Link this database? [Y/n]\"+char(10)+\"||: \",0,1)
				if wait_for != \"n\" and wait_for != \"N\" then
					print(colorLightBlue+\"Preparing to link database: \"+CT+char(10)+colorOrange+\"</b>\"+line+\"</color>\")
					print(\"Purging XPLOITS...\")
					globals.XPLOITS = []
					globals.MEMORY = null
					found_it = line
					done = colorOrange+\"Database: link for </b>\"+colorWhite+found_it+\"</color> complete.\"+CT
					continue
				else
					continue
				end if
			end if
			line = line.split(\" \")
			if found_it and line.indexOf(\"Hooked:\") == 0 then
				globals.XPLOITS.push(line[line.indexOf(\"with\")+1]+ \" \" +line[line.indexOf(\"with\")+2]+ \" \" +line[line.indexOf(\"Hooked:\")+1]+ \" \" +line[line.indexOf(\"Hooked:\")+2])
			else
				if found_it then
					found_it = false
					return done
				end if
			end if
		end for
		return done
	end function
	
	if arg1 == \"no_network\" then return 0 //// ???????wtf
	boo = 0
	file = null
	if arg2 and arg2.lower == \"-y\" then 
		boo = 1
		arg2 = 0
	end if	
	if arg3 and arg3.lower == \"-y\" then boo = 1
	if arg4 and arg4.lower == \"-y\" then boo = 1
	if arg2 then
		if arg2 == \"@home\" then
			r_ip = \"\"
			r_p = \"router\"
			if params and params.len > 1 then
				r_ip = params[0]
				r_p = params[1].to_int
			else
				r_ip = targ.ip
				r_p = targ.pt
			end if
			if not r_ip.is_valid_ip then return \"linkdb: set remote ip and port with command.target [ip] [port] before using @home option.\"
			r_pas = \"\"
			if params and params.len > 2 then
				r_pas = params[2]
			else
				r_pas = user_input(\"pass:> \", 1)
			end if
			r_r = shell.connect_service(r_ip, r_p, \"root\", r_pas)
			if r_r and typeof(r_r) == \"shell\" then
				file = r_r.host_computer.File(\"/root/rkit/database.csv\")
				if not file then return (colorRed+\"404: remote database not found\"+CT)
			else
				return (\"linkdb: error; remote server unreachable.\"+CT)
			end if
		else
			file = localmachine.File(arg2+\"/database.csv\")
		end if
	else
		file = localmachine.File(\"/root/rkit/database.csv\")
		if not file then file = localmachine.File(current_path+\"/database.csv\")
		if not file then
			globals.grepped_file = null
			globals.list_files(localmachine.File(\"/\"), \"database.csv\", 1, \"N\")
			file = globals.grepped_file
		end if
	end if
	if file and file.has_permission(\"r\") then 
		catch = link(file,arg1,boo) // catch is 0 on failure
		if catch then
			print(catch) 
			return 0 // return 0 on success
		else 
			return \"linkdb: database entry not found\"+char(10)+
			\"-- run db or meta scan\"
		end if
	end if
	print \"linkdb: database.csv not found\"+char(10)+\"-- run db to create it\" // print this, do NOT return this or everything breaks
	return 0
end function
command.meta = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Metaxploit || MetaxploitLib || exploits || XPLOITS || MetaLib || Hack\"+char(10)+
	\"<color=yellow>Important note: \"+char(10)+
	\"A \"+colorOrange+\"metaxploitLib \"+CT+\"is the object obtained from include_lib(\"+colorOrange+\"metaxploit.so\"+CT+\")\"+char(10)+
	\"<color=yellow>A \"+colorLightBlue+\"metaLib\"+CT+\" is the object obtained from metaxploit.load() or net_session.dump_lib\"+char(10)+
	\"<color=yellow>A net_session object will dump a \"+colorLightBlue+\"metaLib\"+CT+\" object\"+char(10)+
	\"<color=yellow>A \"+colorLightBlue+\"metaLib\"+CT+\" gets scanned, a \"+colorOrange+\"metaxploitLib \"+CT+\"does the scanning\"+char(10)+
	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - \"+char(10)+
	\"The <color=yellow>meta</color> command is used for fine control over \"+colorLightBlue+\"</b>metaLib\"+CT+\" and \"+colorOrange+\"</b>metaxploitLib\"+CT+\" processes\"+char(10)+
	\"<b>Usage: meta -- print the currently linked \"+colorLightBlue+\"</b>metaLib\"+CT+\" name and version if any\"+char(10)+

	colorCyan+\"Usage: meta load [\"+colorLightBlue+\"</b>metaLib\"+CT+\"] -- directly load a piped metaLib object\"+char(10)+
	\"-- meta link [metaLib] and meta [metaLib] will also be accepted\"+char(10)+
	colorCyan+\"Usage: meta load [opt:\"+colorLightBlue+\"</b>lib_name</color>] -- load a local \"+colorLightBlue+\"</b>metaLib\"+char(10)+
	\"-- passing a lib name will link that lib if it is in /lib\"+char(10)+
	\"-- not passing a lib name will bring up the menu\"+char(10)+
	\"----- the menu will display libs in the <b>localhost</b>'s /lib folder\"+char(10)+
	\"----- if using an imported \"+colorOrange+\"</b>metaxploitLib\"+CT+\" the list may be wrong\"+char(10)+
	\"----- selecting a lib from the list that is present on the target <b>will still work</b>, but\"+char(10)+
	\"--- the \"+colorOrange+\"</b>metaxploitLib\"+CT+\" object loads from the lib folder of it's native machine\"+char(10)+
	\"----- use the command while in glasspool to get the correct contents of /lib \"+char(10)+
	\"------- if you have an available shell/computer that matches the metaxploitLib\"+char(10)+
	colorCyan+\"Usage: meta load [\"+colorLightBlue+\"</b>/full/path</color>] -- load a local \"+colorLightBlue+\"</b>metaLib</color> from path\"+char(10)+
	\"-- only libs in /lib may be exploited\"+char(10)+
	\"-- libs loaded from outside of /lib may not not\"+char(10)+
	\"---- they may still have their name, version, and patch status checked\"+char(10)+
	\"-- full paths only\"+char(10)+
	\"---- the file checked is on the machine linked to the metaxploit object\"+char(10)+
	colorCyan+\"Usage: meta link [opt:\"+colorLightBlue+\"</b>ip</color>] [opt:\"+colorLightBlue+\"</b>port</color>] -- link a remote net_session \"+char(10)+
	\"-- dumps the \"+colorLightBlue+\"</b>metaLib\"+CT+\" from the net_session and loads it\"+char(10)+
	\"-- uses global targetIP and targetPort if ip and port are not passed\"+char(10)+
	\"-- passing ip and port sets global targetIP and targetPort\"+char(10)+
	\"-- if ip is passed without port; defaults to targetPort (or router if not set)\"+char(10)+
	colorGold+\"</b>Note: both link and load will attempt to run <b>linkdb</b> on the \"+colorLightBlue+\"</b>metaLib\"+char(10)+
	colorCyan+\"</b>Usage: meta scan -- scans the loaded \"+colorLightBlue+\"</b>metaLib</color> and loads vulns to memory\"+char(10)+
	\"-- uses the currently active \"+colorOrange+\"</b>MetaxploitLib\"+CT+\" object\"+char(10)+
	\"-- does NOT update the database\"+char(10)+
	\"-- equivalent to 5phinx [1]\"+char(10)+
	\"-- use db -r or db -l or db -m for databasing\"+char(10)+
	\"-- use zap or roil or 5phinx [A] or [2] after scanning to fire the exploits\"+char(10)+
	colorCyan+\"</b>Usage: meta [-i|import] [path|\"+colorOrange+\"</b>metaxploitLib</color></b>] -- import a new \"+colorOrange+\"metaxploitLib \"+CT+\" object\"+char(10)+
	\"-- imports from a path or from a piped object\"+char(10)+
	\"-- use <b>meta restore</b> to revert to the <u>previously used</u>\"+colorOrange+\" metaxploitLib\"+CT+\" object\"+char(10)+
	colorCyan+\"</b>Usage: meta \"+colorLightBlue+\"</b>return</color> -- return the currently linked\"+colorLightBlue+\"</b> metaLib\"+CT+\" object\"+char(10)+
	colorCyan+\"</b>Usage: meta [\"+colorOrange+\"</b>-x\"+CT+\"] -- return the current \"+colorOrange+\"</b>metaxploitLib\"+CT+\" object\"+char(10)+
	\"- - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - \"+char(10)+char(10)+
	\"Next: once a metaLib or net_session is linked:\"+char(10)+
	\"-- scan the imported object with <b>meta scan</b> or <b>db -m</b>\"+char(10)+
	\"-- if not using db use roil to send all attacks at once\"+char(10)+
	\"-- use <b><color=green>db -m</b></color> to force databasing the linked \"+colorLightBlue+\"metaLib \"+char(10)+
	\"-- n.b: running db without -m will cause db to look for a new lib to link and overwrite the linked \"+colorLightBlue+\"metaLib\"+char(10)+char(10)+
	\"Note: importing a \"+colorOrange+\"</b>metaxploitLib\"+CT+\" from your server to a remote target\"+char(10)+
	\"-- allows using your hardware to scan the target's local libraries.\"+char(10)+
	\"-- Likewise, exporting a remote \"+colorLightBlue+\"</b>metaLib\"+CT+\" back to your server \"+char(10)+
	\"---- allows you to use your hardware to scan the remote libs.\"+char(10)+
	\"-- use <b>bios> along with <b>cob get</b> and <b>cob set</b> to import/export objects\"+char(10)+char(10)+
	\"eg: <b>meta -i @o myx1 | meta link net.so | meta -i @o myx0 | meta scan\"+char(10)+
	\"-- a library from the machine connected to myx1 will be scanned using\"+char(10)+
	\"---- the hardware of the machine connected to myx0\"
	if arg1 then

		if typeof(arg1) == \"MetaLib\" then 
				globals.metaLib = arg1
				print \"meta: loaded new <b>MetaLib</b> object\"
				return command.linkdb(arg1.lib_name+\" v \"+arg1.version,\"-y\")
		end if
	
		if arg1 == \"import\" or arg1 == \"-i\" then 
			if not arg2 or (typeof(arg2) != \"string\" and typeof(arg2) != \"MetaxploitLib\") then return \"meta: -i expects a metaxploitLib object or a path to a metaxploit.so\"
			print \"<size=75%>meta: backing up current metaxploit object\"
			globals.backup_meta = globals.metaxploit
			globals.metaxploit = null
			target_lib = null
			if typeof(arg2) == \"string\" then 
				target_lib = globals.get_file(arg2)
				if target_lib then globals.metaxploit = include_lib(target_lib.path)
			end if
			if typeof(arg2) == \"MetaxploitLib\" then globals.metaxploit = arg2 

			if not globals.metaxploit or typeof(globals.metaxploit) != \"MetaxploitLib\" then 
				globals.metaxploit = globals.backup_meta
				if typeof(arg2) == \"string\" then reason = \"-- invalid path\" else reason = \"-- invalid input\"
				return \"meta: metaxploit import failed: \"+char(10)+reason+char(10)+\"meta: backup metaxploit restored\"
			end if
			return colorWhite+\"<u>meta: a new metaxploitLib has been imported!\"+char(10)+\"<size=75%>meta: use <b>meta restore</b> to revert back to the last metaxploitLib\"+char(10)+\"<size=75%>-- the hot_swap_libs option in <b>aptm</b> will restore local metaxploit.so\"
		end if
	
		if arg1 == \"restore\" then 
			if globals.backup_meta then 
				globals.metaxploit = globals.backup_meta 
				if typeof(globals.metaxploit) == \"MetaxploitLib\" then return \"meta: previous metaxploitLib restored\" else return colorRed+\"meta: error! backup metaxploitLib corrupted!\"+char(10)+\"-- use <b>meta -i [/path]</b> to manually restore\"
			else 
				return \"meta: no backup metaxploitLib to restore\"
			end if
		end if
	
		if not globals.metaxploit then return \"metaxploit.so not found\"
	
		if arg1 == \"link\" or arg1 == \"-r\" then
			arg = 0
			if arg2 and typeof(arg2) == \"MetaLib\" then 
				globals.metaLib = arg2
				print colorLightBlue+\"</b><size=75%>meta: linked new <b>MetaLib</b> object\"
				return command.linkdb(arg2.lib_name+\" v \"+arg2.version,\"-y\")
			end if
			if not localmachine.is_network_active then return \"meta: no network connection!\"
			arg = \"Y\"
			if arg2 and is_valid_ip(arg2) then globals.targetIP = arg2
			if arg3 and (typeof(arg3.to_int) == \"number\" or arg3 == \"router\") then globals.targetPort = arg3.to_int
			if globals.targetIP then // and globals.targetPort then
				return command.linkdb(get_lib(arg),\"-y\") // edit get_lib to take 3rd param: auto link
			else
				return \"meta: invalid target IP\"
			end if
		end if
	
		if arg1 == \"load\" or arg1 == \"-l\" then 
			if arg2 and typeof(arg2) == \"MetaLib\" then 
				globals.metaLib = arg2
				print colorLightBlue+\"</b><size=75%>meta: loaded new <b>MetaLib</b> object:\"
				return command.linkdb(arg2.lib_name+\" v \"+arg2.version,\"-y\")
			end if
			arg = \"L\"
			scan_this_lib = arg2
			return command.linkdb(get_lib(arg,scan_this_lib),\"-y\") //else return \"meta: invalid metaLib\"// edit get_lib to take 3rd param: auto link
		end if
	
		if arg1 == \"return\" then return globals.metaLib

		if arg1 == \"-x\" then return globals.metaxploit
	
		if arg1 == \"scan\" then
			if not globals.metaxploit then return colorRed+\"meta: error: metaxploitLib not found\"
			if globals.metaLib then
				//get_lib
				globals.scan_memory
			else
				print(\"meta: please establish a net session\"+char(10)+\"-- or load a lib with:\"+char(10)+\"<b>meta link [-l|-r]</b> \"+char(10)+\"-- before scanning\" )
			end if
			return 0
		end if
	
	end if
	
	if not globals.metaxploit then print \"meta: metaxploit.so not found\" 
	if typeof(globals.metaLib) == \"MetaLib\" then return globals.metaLib.lib_name + \" v \" +globals.metaLib.version
	return \"meta: no MetaLib linked\"
	
end function
command.zap = function(arg1, arg2, arg3, arg4)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"ZAP || Single Attack || overflow || exploit\"+char(10)+
	\"Usage: zap -- select attack; Equivalent to 5phinx [A]\"+char(10)+
	\"Usage: zap [memory_address] [unsec_value] [opt:pass|ip] -- manually input overflow parameters\"+char(10)+
	\"Usage: zap [int] -- run the attack at index [int] \"
	if not metaLib then return \"Link metaLib before continuing.\"
	print colorRed+\"<size=75%><u>zap:<color=white> zapping...\"
	if arg1 and arg2 and typeof(arg1) != \"number\" and typeof(arg1.to_int) != \"number\" then
		result = null
		if arg3 then
			result = globals.metaLib.overflow( arg1, arg2, arg3 )
		else
			result = globals.metaLib.overflow( arg1, arg2 )
		end if
		if result and result != 1 then 
			print \"malp: sending \"+typeof(result)+\" to \"+colorOrange+\" BUFFER...\"
			globals.BUFFER.push(result)
		end if
		print colorRed+\"</b>zap: \"+colorWhite+\"</b>returning...\"
		return result
	end if
	return globals.select_attack(arg1)
end function
command.roil = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Attack All | Spam Attack | Run all Exploits | Into the Roil\"+char(10)+
	\"Usage: roil [opt: [inject] | opt: [-p|--prompt]] -- launches hail mary overflow attack \"+char(10)+
	\"-- equivalent to option [2] in 5phinx\"+char(10)+
	\"-- optional inject value may be a lan ip or a password, depending on the target\"+char(10)+
	\"---- if attacking a router: inject should be a lan ip, to be used with a BOUNCE exploit\"+char(10)+
	\"---- if attacking a server: inject should be a password, to be used with pw change exploits\"+char(10)+
	\"<b>-- if inject is -p or --prompt then roil will prompt for the following:\"+char(10)+
	\"---- an inject value (ip or pw)\"+char(10)+
	\"---- if a <b><color=yellow>shell is found, you will get an Open Shell? prompt\"+char(10)+
	\"---- if a <b><color=white>computer is found, the computer handler will open\"+char(10)+
	\"---- if a <b><color=green>file is found, 5hell will run <b>tree</b> on the file object\"+char(10)+
	\"Note: roil returns zero and sends all objects to the \"+colorOrange+\"BUFFER.\"+char(10)+
	\"Note: an inject value only matters for password change and bounce exploits\"+char(10)+
	\"N.B.: roil does <b>not</b> database results; use <b>db</b> instead\"+char(10)+
	\"-- this may change in the future\"
	globals.roil(arg1)
	return 0
end function
command.purge = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == \"-h\" or arg1 == \"help\" then return \"Usage: purge [-b] -- clear object BUFFER \"+char(10)+
	\"Usage: purge [-t] -- clear transmit buffer (tbuf)\"+char(10)+
	\"Usage: purge [-x] -- clear XPLOITS buffer \"+char(10)+
	\"Usage: purge [-c] -- clear CC command buffer \"+char(10)+
	\"Usage: purge [-e] -- clear enum buffer\"+char(10)+
	\"Usage: purge [-s] -- clear tagged4scp buffer\"+char(10)+
	\"Usage: purge [-r] -- purge the RSI buffer (remove all rshells)\"+char(10)+
	\"Usage: purge [-o] -- purge custom object  (excludes macro registry)\"+char(10)+
	\"Usage: purge [-m] -- purge macro registry\"+char(10)+
	\"Usage: purge [-d] -- purge monitors (daemons)\"+char(10)+
	\"Usage: purge [-b] -- purge the BUFFER (excludes shell [0])\"+char(10)+
	\"Advanced: purge [opt] [y] -- skip confirmation \"+char(10)+
	\"Advanced: purge -b [#] -- remove BUFFER entry at #\"+char(10)+
	\"Advanced: purge -d [daemon_name] -- remove monitor process with the specified identifier\" 
	confirm = arg2
	if arg1 == \"-b\" then
		if confirm == \"0\" then return \"purge: cannot purge the launch shell.\"
		if typeof(confirm) != \"number\" and typeof(confirm.to_int) == \"number\" then confirm = confirm.to_int
		if not confirm then confirm = user_input(\"Clear BUFFER: are you sure? [y/N] ||: \",0,1)
		if confirm == \"y\" or confirm == \"Y\" then
			globals.BUFFER = [get_shell]
			if globals.GLASSPOOL then globals.BUFFER.push(globals.shell)
			return \"BUFFER purged.\"
		else
			if typeof(confirm) == \"number\" then 
				print(\"purging...\")
				if globals.BUFFER.hasIndex(confirm) then return globals.BUFFER.remove(confirm) else return \"purge: invalid index\"
			else
				return \"aborting...\"
			end if
		end if
	end if
	if arg1 == \"-t\" then
		if not confirm then confirm = user_input(\"Clear T_BUF: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then
			globals.T_BUF = [(localip+\"@\"+pubip)]
			return \"T_BUF purged.\"
		else
			return \"aborting...\"
		end if
	end if
	if arg1 == \"-c\" then
		if not confirm then confirm = user_input(\"Clear CC: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then
			globals.command_buffer = []
			return \"CC purged.\"
		else
			return \"aborting...\"
		end if
	end if
	if arg1 == \"-x\" then
		if not confirm then confirm = user_input(\"Clear XPLOITS: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then
			globals.MEMORY = null
			globals.XPLOITS = []
			globals.meta_scan = []
			return \"XPLOITS purged.\"
		else
			return \"aborting...\"
		end if
	end if
	if arg1 == \"-e\" then
		if not confirm then confirm = user_input(\"Clear ENUM: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then
			globals.enumerated = []
			return \"ENUM purged\"
		else
			return \"aborting...\"
		end if
	end if
	if arg1 == \"-s\" then
		if not confirm then confirm = user_input(\"Clear tagged4scp: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then
			globals.tagged_for_scp = \"\"
			return \"tagged4scp purged...\"
		else
			return \"aborting...\"
		end if
	end if
	if arg1 == \"-r\" then 
		if not confirm then confirm = user_input(\"Clear all rshells: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then
			globals.rsi_purge
			return \"RSI buffer purged...\"
		else
			return \"aborting...\"
		end if
	end if	
	if arg1 == \"-o\" then 
		if not confirm then confirm = user_input(\"Clear custom_object: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then print \"purging custom object...\"
		gco = get_custom_object
		if DEBUG then print \"debug: printing gco indexes...\"
		for index in gco.indexes
			if DEBUG then print index
			if index != \"__isa\" and index != \"classID\" and index != \"macros\" and index != \"stack_pool\" then gco.remove(index)
		end for
		return \"custom object purged...\"
	end if
	if arg1 == \"-m\" then 
		if not confirm then confirm = user_input(\"Clear all rshells: are you sure? [y/N]||: \",0,1)
		if confirm.lower == \"y\" then print \"purging macro registry...\"
		if DEBUG then print \"debug: macros: \"+char(10)+get_custom_object.macros
		get_custom_object.macros = {}
		return \"macros purged...\"
	end if
	if arg1 == \"-d\" then
		manager = new DaemonManager
		manager.Init
		if manager.__initialized and manager.__file then
			if not confirm then confirm = user_input(\"Stop daemons: are you sure? [y/N]||: \",0,1)
			if typeof(confirm) == \"string\" and confirm.lower == \"y\" then
				print \"stopping daemons...\"
				result = manager.__file.delete
				if typeof(result) == \"string\" and result.len > 0 then return \"Error deleting rshell.d: \" + result
				return \"daemons stopped successfully.\"
			else if typeof(confirm) == \"string\" and confirm.lower != \"n\" then
				result = manager.Stop(confirm)
				if result then return \"\"
				return \"failed to stop \" + confirm
			else if typeof(confirm) == \"string\" and confirm.lower == \"n\" then
				return \"aborting...\"
			else
				return \"invalid entry: \" + @confirm
			end if
		else
			return \"Error starting daemon manager\"
		end if
	end if
	return \"valid options: -t OR -c OR -b OR -d OR -e OR -s OR -r OR -m OR -x OR -o\"
end function
// cobble, get_custom_object interface by Plu70
if DEBUG then print(\"<size=75%>loading cobble.5pk...(6.251kb)</size>\")

command.cob = function(arg1,arg2,arg3=0,arg4=0)
	usage_info = \"<u>Cobble || custom object || cob || meta buffer</u>\"+char(10)+
	colorCyan+\"Usage: cob set [key] [val] -- set custom object key to val.\"+char(10)+
	\"-- returns string on success or error\"+char(10)+
	colorCyan+\"Usage: cob get [key] -- get value of custom object key.\"+char(10)+
	\"-- returns value at key or null\"+char(10)+
	\"-- returns @reference (pointer) if value is a function\"+char(10)+
	colorCyan+\"Usage: cob return -- returns the raw custom object\"+char(10)+
	\"-- pipe to command.<b>code</b> to decompile the object.\"+char(10)+
	\"-- ie:<b> cob return | code</b>\"+char(10)+
	colorCyan+\"Usage: <b>cob inspect</b> -- returns key/value pair information of custom object\"+char(10)+
	\"-- returns a string pairing each key with its [trucated] value\"+char(10)+
	\"-- values are truncated to make the object easier to inspect\"+char(10)+
	\"-- please use <b>cob return | code</b> if you want the raw output\"+char(10)+
	colorCyan+\"Usage: cob indexes -- return custom object indexes as a LIST\"+char(10)+
	\"-- pipe to the <b>string</b> command to stringify\"+char(10)+
	colorCyan+\"Usage: cob search [val] --  search for index of val.\"+char(10)+
	\"-- returns string; key or failure message.\"+char(10)+
	\"Inactive: cob sign -- future ability to sign custom object.\"+char(10)+
	\"-- currently returns 0 (zero).\"+char(10)+
	colorCyan+\"Usage: cob del [key] -- delete key and its value from custom object.\"+char(10)+
	\"-- returns string on success or failure.\"+char(10)+
	colorCyan+\"Usage: cob <b>purge</b> -- purge the custom object\"+char(10)+
	colorCyan+\"Usage: cob install [key] -- install a function residing in the custom object at [key]\"+char(10)+
	\"-- this will add the function as a 5hell command (it will show up in help)\"+char(10)+
	\"-- functions must still follow the standard template to avoid errors\"+char(10)+
	\"-- the funciton will not persist after 5hell is closed\"+char(10)+
	\"-- please compile your custom function into 5hell.src for persistent functions\"+char(10)+
	\"Advanced: the \"+colorGold+\"cerebrum\"+CT+\" command loads the dictionary to the custom object\"+char(10)+
	\"-- it is loaded to custom_object.dictionary and can be removed by passing the 'purge' param to cerebrum\"+char(10)+
	\"-- this is allows you to use the dictionary between nested shell.launches with only a single run of cerebrum.\"+char(10)+char(10)+
	\"<b>N.B.</b> -- since version 3.8.3 5hell.src contains aliases for cob set and cob get:\"+char(10)+
	colorGold+\"Usage: set [key] [value] -- same as cob set [key] [value]\"+char(10)+
	colorGold+\"Usage: get [key] -- same as cob get [key]\"+char(10)+char(10)+
	colorGold+\"EZclip: you may use \"+colorWhite+\"@o </color>[<color=white>key</color>]</b>\"+char(10)+
	\"-- to reference a key in the custom object\"+char(10)+
	\"-- the <b>@o [key]</b> will be replaced by the key's value, much like using @a, @b, @c for the clipboard\"
	if arg1 == \"help\" or arg1 == \"-h\" then return usage_info
	if not arg1 then return \"cob: invalid input: see <b>cob -h</b>\"
	cobble = get_custom_object
	cob = {}
	cob.set = function( key=0, val=0, nil=0, nul=0 )
		if not @key then return null
		if typeof(@key) == \"function\" then
			if typeof(@val) == \"function\" then
				cobble[@key] = @val
			else
				cobble[@key] = val
			end if
		else
			if typeof(@val) == \"function\" then
				cobble[key] = @val
			else
				cobble[key] = val
			end if
		end if
		if cobble.hasIndex( @key ) then return \"cob: set<b> \"+@key+\"</b> to <b>\"+@val+\"</b>\" else return \"cob: set error\"
	end function

	cob.get = function( key=0, val=0, nil=0, nul=0 )
		if cobble.hasIndex( @key ) then return cobble[@key]
		if cobble.hasIndex( key ) then return cobble[ key ]
		return \"cob: key not found\"
	end function

	cob.search = function ( val=0, key=0, nil=0, nul=0 )
		if cobble.indexOf( @val ) != null then
		if typeof(@val) == \"function\" then return cobble.indexOf( @val )
		return cobble.indexOf( val )
		else
		if cobble.indexOf( val ) != null then return cobble.indexOf( val )
		return \"cob: value not found\"
		end if
	end function

	cob.return_indexes = function(key=0,val=0,nil=0,nul=0)
		return cobble.indexes
	end function
	
	cob.inspect = function( key=0, val=0, nil=0, nul=0 )
		inspect_buf = []
		value_buf = []
		st = \"KEY \"+colorWhite+\":\"+CT+\" [\" + colorGold+\"</b>\"+ \"TYPE\" + \"</color>] \"+colorWhite+\":\"+CT+\" \"
		sv = \"VALUE\"
		inspect_buf.push(st)
		value_buf.push(sv)
		for thing in cobble 
			parsed_value = @thing.value
			if typeof(@thing.value) == \"string\" and thing.value.len > 32 then parsed_value = thing.value[:27]+\"...\"
			if typeof(@thing.value) == \"list\" and thing.value.len > 5 then parsed_value = thing.value[:5]+[\"...\"]
			if typeof(@thing.value) == \"map\" and thing.value.len > 0 then parsed_value = \"{...}\"
			inspect_buf.push(@thing.key + \" \"+colorWhite+\":\"+CT+\" [\" + colorGold+\"</b>\"+ typeof(@thing.value) + \"</color>] \"+colorWhite+\":\"+CT+\" \")// + parsed_value)
			value_buf.push(@parsed_value)
		end for
		inspect_buf.push(\"[end of \")
		value_buf.push(\" custom object]\")
		format_buf = format_columns(inspect_buf.join(char(10)).trim)
		format_buf = format_buf.split(char(10))
		fi = 0
		if DEBUG then 
			print \"debug: f_buf: \"+format_buf
			print \"debug: v_buf: \"+value_buf
		end if 
		for line in format_buf
			format_buf[fi] = @line + @value_buf[fi]
			fi = fi + 1
		end for
		return format_buf.join(char(10))
	end function

	cob.del = function( key=0, val=0, nil=0, nul=0 )
		if typeof(@key) == \"function\" then
		if cobble.remove( @key ) then return \"cob: removed key: <b>\"+@key+\"</b>\" //else return \"cob: key not found.\"
		else
		if cobble.remove( key ) then return \"cob: removed key: <b>\"+key+\"</b>\" else return \"cob: key not found\"
		end if
	end function

	cob.sign = function( key=0, val=0, nil=0, nul=0 )
		return cob.set( \"signature\" , command.code(\"-a\", key))
	end function

	cob.install = function(key=0, val=0, nil=0, nul=0)
		g = @cob.get
		new_command = g(key)
		if typeof(@new_command) == \"string\" then return new_command + \": Install failed\"
		if typeof(@new_command) == \"function\" then 
			command[key] = @new_command 
			return \"Set command.\"+key+\" to \"+@new_command
		else 
			return \"cob: install expects a function\"
		end if
	end function

	if arg1 == \"return\" then return cobble
	if arg1 == \"install\" then 
		if arg2 then return cob.install(arg2) else return \"cob: install expects a key from the custom object\"
	end if
	if arg1 == \"set\" then
		if @arg3 then
			if @arg2 == \"@clipa\" then arg2 = @globals.clip_board_alpha
			if @arg2 == \"@clipb\" then arg2 = @globals.clip_board_beta
			if @arg2 == \"@clipc\" then arg2 = @globals.clip_board_gamma
			return cob.set( @arg2, @arg3 )
		else
			return \"cob: invalid input: see <b>cob -h</b>\"
		end if
	end if
	if arg1 == \"get\" then
		if @arg2 then
			g = @cob.get
			return g( @arg2 )
		else
			return \"cob: invalid input: see <b>cob -h</b>\"
		end if
	end if
	if arg1 == \"indexes\" then 
		return cob.return_indexes
	end if
	if arg1 == \"inspect\" then
		return cob.inspect
	end if
	if arg1 == \"sign\" then return cob.sign(signature)
	if arg1 == \"search\" then
		if @arg2 then return cob.search( @arg2 ) else return \"cob: invalid input: see <b>cob -h</b>\"
	end if
	if arg1 == \"del\" then
		if @arg2 then return cob.del( @arg2 ) else return \"cob: invalid input: see <b>cob -h</b>\"
	end if
	if arg1 == \"purge\" then return command.purge(\"-o\",\"y\")
	return \"cob: invalid input: see <b>cob -h</b>\"
end function
command.smtp = function(arg1,arg2=0,arg3=0,arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"SMTP || MAIL USER LIST\"+char(10)+\"Usage: smtp [ip] [port] -- return mail user list if ip/port is running smtp mail server\"+char(10)+\"-- user target ip and target port if not supplied\"
	tar_ip = 0
	tar_port = 0
	if not globals.crypto then return \"smtp: crypto.so not found\"
	if arg1 then 
		if is_valid_ip(arg1) then tar_ip = arg1
	else 
		if globals.targetIP then tar_ip = globals.targetIP else return \"smtp: invalid or unsupplied ip address\"
	end if
	if arg2 and typeof(arg2.to_int) == \"number\" then tar_port = arg2.to_int
	if not tar_port then 
		if globals.targetPort then tar_port = globals.targetPort else return \"smtp: invalid or unsupplied port\"
	end if
	print colorGreen+\"smtp: pulling from \"+CT+colorWhite+tar_ip+colorGreen+\": \"+CT+tar_port+CT+\"...\"
	ml = globals.mail_user_list(tar_ip,tar_port)
	if not ml then return \"smtp: mail server not found\" else return ml
end function
command.osint = function(option_flags, octet_rules, user_name, spool)
    if not option_flags or option_flags == \"help\" or option_flags == \"-h\" then return \" osint || open source information || OSINT || fuzzer\"+char(10)+
    colorWhite+\"Usage: osint [option] [ip_octet_rules] [user_name] [bool:spool]\"+char(10)+
	\"-- scour domains for valid emails using: user_name@domain\"+char(10)+
	\"note: a mail account is required to use this function\"+char(10)+
    colorGold+\"</b>Options:\"+char(10)+
	\"  \"\" \"\"  [-l|list] -- return output as a list of domain strings\"+char(10)+
    \"  \"\" \"\"  [-s|space] -- return output as a string of single spaced domains\"+char(10)+
    \"  \"\" \"\"  [-n|newline] -- return output as a string of domains; one per line\"+char(10)+
    \"  \"\" \"\"  [-c|comma] -- return output as a comma separated value \"+char(10)+
    colorGold+\"</b>Octet Rules:\"+char(10)+
    \"Input method:\"+colorWhite+\"list\"+CT+\" -- supply a list with 8 indexes containing ints or string:ints corresponding-\"+char(10)+
    \"to the minimum and maximum values for each octet, in order. This means if our octets are:\"+char(10)+
    \"<b>k.j.i.h</b> and the ip range we want is 1.1.1.1 to 115.1.1.255, the list would be:\"+char(10)+
    \"<b>[1,115,1,1,1,1,1,255]</b><color=white>\"+char(10)+
	\"-- where [0] is k_min, [1] is k_max, [2] is j_min, [3] is j_max, and so on.\"+char(10)+
    \"-- incomplete octet rules or out-of-bounds entries will return an error. \"+char(10)+
    \"Input method:\"+colorWhite+\"string\"+CT+\" -- supply a string, without spaces, formed as follows:\"+char(10)+
    colorCyan+\" oc1_min-oct1_max\"+CT+\".\"+colorCyan+\"oct2_min-oct2_max\"+CT+\".\"+colorCyan+\"oct3_min-oct3_max\"+CT+\".\"+colorCyan+\"oct4_min-oct4_max \"+char(10)+
    \"--eg: 1-200.1-1.0-234.1-255\"+char(10)+
    colorGold+\"</b>User name:\"+char(10)+
    \"Input: any npc user name \"+char(10)+
    colorGold+\"Spool:\"+char(10)+
	\"-- bool:[1|0] pass a positive value for the 'spool' parameter to write results to disk\"+char(10)+
    \"-- writes to current_path/spool.osint\"+char(10)+
	colorGold+\"Output:\"+char(10)+
	\"--  osint will perform a whois lookup on each ip\"+char(10)+
    \"---- parse the string for the ip's domain\"+char(10)+
    \"---- attempt to locate username@domain to determine if it exists\"+char(10)+
    \"---- on positive hit, push domain to output buffer\"+char(10)+
    \"---- return results based on options\"
	// banner
	print colorLightBlue+\"<u><size=125%>OS\"+colorWhite+\"int npc finder v0.9 by Plu</color>70\"
	// handle error checking and input validation
	if not octet_rules or (typeof(octet_rules) != \"string\" and typeof(octet_rules) != \"list\") then return \"osint: invalid octet rules: expects list or string\"
	if not user_name or typeof(user_name) != \"string\" then return \"osint: invalid user name: expects string \"
	// confirm mail account is active 
	if not globals.inbox then 
		print \"Please login to a mail account then return here to continue: \"
		command.mail 
	end if
	if not globals.inbox then return \"osint: please login to a mail account before continuing\"
	// prepare octet rules
	if typeof(octet_rules) == \"string\" then 
		octet_buff = octet_rules.split(\"\\.\")
		octet_rules = []
		for pair in octet_buff
			p = pair.split(\"-\")
			if p.len != 2 then return \"osint: malformed octet rules: expects list or string:\"+char(10)+\"[k_s,k_e,j_s,j_e,i_s,i_e,h_s,h_e]\"+char(10)+\"k_s-ke.j_s-j_e.i_s-i_e.h_s-h_e\"
			if p[0] > p[1] then return \"osint: octet max must be less than or equal to octet min\"
			octet_rules.push(p[0])
			octet_rules.push(p[1])
		end for
	end if 
	l = 0
	for o in octet_rules
		if typeof(o) != \"number\" and typeof(o) == \"string\" then o = o.to_int
		if typeof(o) != \"number\" then return \"osint: malformed octet rules: expects list:[int|string] or string:\"+char(10)+\"[k_s,k_e,j_s,j_e,i_s,i_e,h_s,h_e]\"+char(10)+\"k_s-ke.j_s-j_e.i_s-i_e.h_s-h_e\"
		octet_rules[l] = o
		l = l + 1
	end for
	if octet_rules.len != 8 then return \"osint: malformed octet rules: expects list or string:\"+char(10)+\"[k_s,k_e,j_s,j_e,i_s,i_e,h_s,h_e]\"+char(10)+\"k_s-ke.j_s-j_e.i_s-i_e.h_s-h_e\"
    if octet_rules[1] == 0 then return \"osint: octet_1_max must be greater than 0\"
		// handle option flags to set delimiter
    delim = \"\"
	verbose = false
    if option_flags == \"-cv\" or option_flags == \"-c\" then
        delim = \",\"
		if option_flags == \"-cv\" then verbose = true
    end if 
	if option_flags == \"-nv\" or option_flags == \"-n\" then
        	delim = char(10)
			if option_flags == \"-nv\" then verbose = true
    end if 
	if option_flags == \"-lv\" or option_flags == \"-l\" then
        delim = \"list\"
		if option_flags == \"-lv\" then verbose = true
    end if 
	if option_flags == \"-sv\" or option_flags == \"-s\" then 
        delim = char(32)
		if option_flags == \"-sv\" then verbose = true
    end if
    // check for the output file if spool flag is set
    spool_file = null
    if spool then
        spool_file = command.poke(\"spool.osint\")
        if not spool_file or typeof(spool_file) != \"file\" then
            return \"error: please create spool.osint before continuing\"
        end if
    end if
	// prepare the output buffer list
    d_list = []
	cycle = 0
    // generate the output by iterating through IP octet ranges
	print \"osint: scanning... \"+char(10)+colorWhite+\"<size=125%><align=center>>.>\"
    for k in range(octet_rules[0], octet_rules[1])  // assuming [start, end] for each octet
        for j in range(octet_rules[2], octet_rules[3])
            for i in range(octet_rules[4], octet_rules[5])
                for h in range(octet_rules[6], octet_rules[7])
                    ip = str(k) + \".\" + str(j) + \".\" + str(i) + \".\" + str(h)
                    // Validate IP format and check if its a LAN IP
                    if not is_valid_ip(ip) or is_lan_ip(ip) then continue
                    // Perform WHOIS lookup and parse the result
                    who_string = whois(ip)
					if who_string.indexOf(\"[Neurobox\") != null then who_string = who_string.split(char(10)) else continue
					//the following got nerfed, can't check if an email exists this way any more
                    if DEBUG then print \"debug: in osint loop: domain: \"+domain
                    // Attempt to send mail and check if user exists
					if who_string[0].indexOf(\": \") == null then continue
                    domain = who_string[0].split(\": \")[1].remove(\"www.\")
                    targ = user_name + \"@\" + domain
                    if verbose or DEBUG then print \"osint: attempting: \"+ip+\" : \"+targ
					if globals.inbox.send(targ,\"do not reply\",\"your account has been suspended due to non payment\") != \"Mail not delivered\" then 
						d_list.push(targ)
						print colorWhite+targ
						// Write the output to spool file if spool is true
						if spool then
							print(\"osint: writing results to:\" + spool_file.path)
							result = spool_file.set_content(d_list.join(char(10)))
							if result != 1 then
								print \"error: unable to write to spool file\"
							end if
						end if
					end if 
					wait(2.5)
					if cycle % 1000 == 0 then wait(.1)
					if DEBUG then print \"scanning...\"
					cycle = cycle + 1
                end for
            end for
        end for
    end for
    
    // Return the output as per the specified delimiter
    if delim == \"list\" then
        return d_list
    else
        return d_list.join(delim)
    end if
end function
command.fetch = function(arg1,arg2,arg3,arg4)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"SPOT || FETCH || MetaxploitLib || krberos\"+char(10)+
	\"Usage: fetch [shell_object] -- obtain a MetaxploitLib object from a supplied shell\"+char(10)+
	\"-- uploads metaxploit.so to /home/guest\"+char(10)+
	\"-- creates a source file in /home/guest\"+char(10)+
	\"-- builds and runs the file\"+char(10)+
	\"-- places the MetaxploitLib in the custom object\"+char(10)+
	\"-- 'spots' out the files; moves them all to an empty file named '.'\"+char(10)+
	\"-- returns the MetaxploitLib as an object\"+char(10)+
	\"NOTE: This is not a jump file. It is a spot file. That is all.\"
	if typeof(arg1) != \"shell\" then return 0
	print colorGold+\"</b>fetch: fetching MetaxploitLib from: \"+char(10)+colorWhite+\"</b>\"+arg1.host_computer.public_ip+ \" <b>:</b> \"+arg1.host_computer.local_ip
	//my_x = globals.get_file(meta_path)
	my_x = globals.get_file(MetaxploitLib.path)
	if not my_x then my_x = command.grep(\"-f\",\"metaxploit.so\")
	if typeof(my_x) != \"file\" then return \"fetch: failed: metaxploit.so not found\" 
	my_perms = my_x.permissions.values 
	pr = my_perms[-3]
	pw = my_perms[-2]
	px = my_perms[-1]
	print colorGold+\"</b>-- preparing payload...\"
	print colorGold+\"</b>-- setting permissions...\"
	ctch = command.perms(\"o+rwx\",my_x.path)
	if ctch then print ctch
	print my_x.path + \" \" + my_x.permissions
	print colorGold+\"</b>-- uploading payload...\"
	print globals.shell.scp(my_x.path,\"/home/guest\",arg1)
	print colorGold+\"</b>-- restoring permissions...\"
	if pr == \"-\" then pr = \"r\" else pr = \"\"
	if pw == \"-\" then pw = \"w\" else pw = \"\"
	if px == \"-\" then px = \"x\" else px = \"\"
	ctch = command.perms(\"o-\"+pr+pw+px,my_x.path)
	if ctch then print ctch
	print my_x.path + \" \" + my_x.permissions
	arg1.host_computer.touch(\"/home/guest\",\"..src\")
	imp = arg1.host_computer.File(\"/home/guest/..src\")
	if not imp then 
		return colorGold+\"</b>fetch: infiltration failed, cannot write to /home/guest\" 
	else 
        print colorGold+\"</b>fetch: spot file created: \"+char(10)+imp.path+ \" \" +imp.permissions
	end if
	mole = \"get_custom_object.fetched = include_lib(\"\"/home/guest/metaxploit.so\"\")\"
	imp.set_content(mole)
	print colorGold+\"</b>-- clearing out fetched cache...\"
	if get_custom_object.hasIndex(\"fetched\") then get_custom_object.remove(\"fetched\")
	print colorGold+\"</b>-- building spot file...\"
	ctch = arg1.build(imp.path,imp.parent.path)
	if ctch then print ctch 
	print colorGold+\"</b>-- launching payload...\"
	globals.stack_pool(\"up\")
	arg1.launch(\"/home/guest/.\")
	_cascade // exit if cascade
	globals.stack_pool(\"down\")
	print colorGold+\"</b>-- spotting source files...\"
	imp.set_content(\"\")
	imp.move(\"/home/guest\",\"metaxploit.so\")
	imp.move(\"/home/guest\",\".\")
	if get_custom_object.hasIndex(\"fetched\") then
	  print \"cob: set <b>fetched</b> to <b>\"+get_custom_object.fetched
	  print colorGold+\"</b>fetch: task complete; returning...\"
	  return get_custom_object.fetched	
	else 
	  print \"fetch: failed to obtain remote MetaxploitLib\"
	  return 0
	end if
	return 0
end function
command.rnip = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: rnip [iter] [optional: delimiter] -- produce [iter] random ip addressses and\"+char(10)+\"return as a string with optional [delimiter] (default newline)\"+char(10)+\"e.g. rnip 100 ,  -- returns a string of 100 ips seperated by a comma\"
	loop = 1
	delimiter = char(10)
	if arg1 then loop = arg1.to_int
	if arg2 then delimiter = arg2
	rng = range(1,223)
	rnd = range(0,223)
	rand_ip = []
	if loop < 1 then return \"rnip: iteration must be a positive integer.\"
	for i in range(1,loop)
		rng.shuffle
		rnd.shuffle
		sub = rnd[0]
		rnd.shuffle
		ito = rnd[0]
		rnd.shuffle
		rand_ip.push([rng[0], rnd[0], ito, sub].join(\".\"))
	end for
	return rand_ip.join(delimiter)
end function
command.porter = function(arg1, arg2, arg3=0, arg4=0)
	if not arg2 or arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: porter [port] [comma,or,newline,separated,ip,list] --  print lib version of service on port, if any, for given ip address(es)\"
	if not localmachine.is_network_active then return \"nsl: no network connection.\"
	r_buf = []
	ip = arg2
	if ip.split(char(10)).len > 1 then
		ip = ip.split(char(10))
		ip = ip.join(\",\")
	end if
	array = false
	if ip.indexOf(\",\") >= 0 then
		ip = ip.split(\",\")
		array = true
	else
		i = ip
		ip = [i]
	end if
	a_size = 1
	if array then a_size = ip.len
	port = 0
	if arg1 then port = arg1.to_int else port = 0
	time_s = time
	print(colorLightBlue+\"- - - - - - - - - - - - - - - - - - - - -\"+CT)
	print(colorLightBlue+\"<align=center><b>(>|<)</b></align>\"+CT)
	for r in range(1, a_size)
		i = ip[r-1]
		if not localmachine.is_network_active then return \"porter: no network connection found.\"
		rtr = get_router(i)
		if typeof(rtr) != \"router\" then continue
		if port then
			pinfo = null
			png = rtr.ping_port(port)
			if png then pinfo = rtr.port_info(png)
			if pinfo then r_buf.push(i+\" \"+port+\": \"+pinfo)
		else
			pinfo = rtr.kernel_version
			if pinfo then r_buf.push(i+\" router: \"+pinfo)
		end if
	end for
	if r_buf == [] then r_buf.push(\"Porter: No_results_found.\")
	print(colorLightBlue+\"Porter: task complete in \"+colorOrange+(time - time_s)+colorLightBlue+\" seconds.\"+CT)
	save = \"y\"//user_input(\"Send results to clipb? [y/N] \"+char(10)+\"||: \",0,1)
	if save.lower == \"y\" then command.clipb(r_buf.join(char(10)))
	return colorLightBlue+\"Porter: clipped\"+CT+char(10)+format_columns(r_buf.join(char(10)))+char(10)+colorLightBlue+\" - - - - - - - - - - - - - - - - - - - - \"+CT
end function"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction5" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]dtools.5pk.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/root/src/dtools.5pk[/color]. Make sure to keep 'Allow import' checked."
fit_content = true

[node name="DtoolsCodeEdit" type="CodeEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 300)
layout_mode = 2
text = "if DEBUG then print(\"<size=75%>loading dtools.5pk v 4.0.7...(156.270)</size>\")
command.poke = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == \"-h\" or arg1 == \"help\" then return \"<u>touch || poke || makefile || overwrite</u>\"+char(10)+\"Usage: poke [/path/to/file] [opt: string] -- create file in path and optionally set contents to string.\"+char(10)+\"Usage: poke test.txt -- creates text.txt in the current path\"+char(10)+\"poke test.txt hello -- creates test.txt and sets content to hello\"+char(10)+\"Advanced: ls -la /virt | poke test.txt -- creates test.txt and pipes the output of ls -la /virt into it\"+char(10)+\"N.B. if file already exists then contents will be <b>overwritten</b> if string supplied.\"+char(10)+\"n.b.b. if string is more than one word use piping to supply string.\"+char(10)+\"<b>Advanced:</b> poke -f [path_to_existing_file] [content] -- will skip the overwrite prompt\"+char(10)+\"Advanced: poke -n [path] -- create path and/or set content to null.\"+char(10)+\"-- overwrites file content with a null character.\"
	skip = false
	if arg1 == \"-f\" then 
		arg1 = arg2
		arg2 = arg3
		arg3 = arg4
		skip = true
	end if
	if arg1 == \"-n\" then
		if not arg2 then return \"poke: -n option requires a valid path to a file.\"
		arg1 = arg2
		arg2 = \"!!nullify!!23tqg43qg34g!!\"
	end if
	destination = null
	final_name = null
	dest = globals.get_file(arg1)
	if not dest then
		split = arg1.split(\"/\")
		if DEBUG then print(\"split: \"+split)
		final_name = split.pop
		if DEBUG then print(\"final name: \"+final_name)
		//if split.len and split[0] == \"\" then dest = globals.get_file(split.join(\"/\")) else dest = globals.get_file(split.join(\"/\")) /// fix it
		if split.len then dest = globals.get_file(split.join(\"/\")) 
		if DEBUG then print(\"dest: [\"+dest+\"]\")
		if not dest then
			if split.len and split[0] == \"\" then destination = \"/\" else destination = currentPath
		else
			destination = dest.path
		end if
	else
		if dest.is_folder then
			return \"poke: \"+arg1+\" is a folder.\"
		else
			destination = dest.parent.path
			final_name = dest.name
		end if
	end if

	dest_folder = globals.get_file(destination)
	if not dest_folder then return(\"poke: destination path not found\")
	if not dest_folder.has_permission(\"w\") then return(\"poke: permission denied\")
	try = localmachine.touch(dest_folder.path, final_name)
	if try != 1 then
		print(\"poke: \"+try)
		// if arg2 then
		// 	if try == \"The file already exists\" and skip != true and user_input(\"overwrite contents? [Y/n] ||: \",0,1).lower == \"n\" then
		// 		return \"aborting...\"
		// 	end if
		// end if
	end if
  	dest_name = \"\"
	if dest_folder.path != \"/\" then dest_name = \"/\"+final_name else dest_name = final_name
	output = globals.get_file(dest_folder.path+dest_name)
	if not output then return \"poke: write error\"
	if arg2 and output.has_permission(\"w\") then
    	if arg2 == \"!!nullify!!23tqg43qg34g!!\" then arg2 = \"\"
    	if output.is_binary then 
			return \"poke: can't poke a binary file.\"
    	else
      		output.set_content(arg2)
    	end if
  	else
    	if arg2 then return \"poke: permission denied.\"
  	end if
	return output
end function
command.merge = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or not arg2 or arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: merge file_path_1 file_path_2 --  combine files. file_1 will have file_2 appended to it.\"
	file1 = localmachine.File(arg1)
	file2 = localmachine.File(arg2)
	if file1 and file2 then
		catch = file1.set_content( file1.get_content.trim + file2.get_content.trim )
	else
		return(\"Check path(s) and try again.\")
	end if
	return catch
end function
command.append = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == \"-h\" or arg1 == \"help\" then return \"Usage: append [path_to_file] [text] (works best with pipe) --  add text to end of file.\"+char(10)+\"Usage: append [file_object] [text] -- append text to file object\"+char(10)+\"-- pipe file object to clipa/b/c and use @a/b/c to reference\"+char(10)+\"-- eg: clipb @B 1 -- where BUFFER[1] is a file, then: append @b [text]\"+char(10)+\"Usage: append @clipa|b|c [text] -- append to the end of a clip space.\"+char(10)+\"N.B.<b> @clipa and @clipc will append text directly with no new line. </b>\"+char(10)+\" -- @clipb will add a new line and then append text.\"
	path_to_file = arg1
	buf = arg2
	if path_to_file == \"@clipa\" then
		globals.clip_board_alpha = globals.clip_board_alpha+buf
		return \"clipped:\"+char(10)+globals.clip_board_alpha
	end if
	if path_to_file == \"@clipb\" then
		globals.clip_board_beta = globals.clip_board_beta+char(10)+buf
		return \"clipped:\"+char(10)+globals.clip_board_beta
	end if
	if path_to_file == \"@clipc\" then
		globals.clip_board_gamma = globals.clip_board_gamma+buf
		return \"clipped:\"+char(10)+globals.clip_board_gamma
	end if
  if typeof(path_to_file) == \"file\" then file = path_to_file
	if typeof(path_to_file) == \"string\" then file = globals.get_file(path_to_file)
	if not file then return \"404: file not found\"
	if file.get_content == \"\" then return file.set_content(buf)
	return file.set_content(file.get_content+char(10)+buf)
end function
command.dfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"Usage: dfit [path_to_file]\"+char(10)+\"Takes text file and splits contents by newline, joins by comma and outputs to a.csv by default.\"+char(10)+\"As the name suggests, this is for making dictionary files. Output is a csv (comma separated values) file.\"
	df = null
	if arg1 then
		df = arg1
	else
		return \"Usage: dfit [path_to_file]\"
	end if
	dump = localmachine.File(currentPath+\"/\"+df)
	if not dump then
		dump = localmachine.File(df)
		if not dump then return(df+\" not found.\")
	end if
	P_LIST = []
	outFileName = user_input(\"Enter outfile name or leave blank for a.csv: \"+char(10))
	if outFileName == \"\" or outFileName == \" \" then outFileName = \"a.csv\"
	print(\"Scanning...\")
	lines = dump.get_content.split(char(10))
	print(\"Found \"+lines.len+\" lines. Sorting... \")
	for pw in lines
		if pw == \"\" then continue
		P_LIST.push(pw.trim)
	end for
	get_shell.host_computer.touch(currentPath,outFileName)
	outfile = get_shell.host_computer.File(currentPath+\"/\"+outFileName)
	if not outfile then return \"Error: check write permissions\"
	outfile.set_content(P_LIST.join(\",\"))
	return (char(10)+\"File \"+outFileName+\" saved. \")
end function
command.chop = function(arg1, arg2=0, arg3=0, new_name=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"<u><b>CHOP || DELIMITER || FILE TOOLS || clipboard tools || split\"+char(10)+
	\"Usage: chop [input] [index] [delimiter] [output]\"+char(10)+
	colorGreen+\"Usage: chop [path_to_file|@clipa|b|c] [index] [delimiter] [output_filename] -- chop a file\"+char(10)+
	\"<color=green>param: <color=white>path_to_file</color> -- file to chop\"+char(10)+
	\"-- if path_to_file is @clipa, @clipb, or @clipc it will chop the clipboard instead\"+char(10)+
	\"-- clipboard contents must be a string\"+char(10)+
	\"<color=green>param: <color=white>index</color> -- keep column of elements at index of split\"+char(10)+
	\"-- default: 0\"+char(10)+
	\"<color=green>param: <color=white>delimiter</color> -- split each line at this pattern\"+char(10)+
	\"-- default: char(32) aka a sapce\"+char(10)+
	\"-- to use char(10) as a delimiter pass \"\"/n\"\" or a piped newline for the delimiter parameter\"+char(10)+
	\"-- one way to pipe a newline is: <b>code -c 10 | clipa</b> -- this will place a newline in the clipboard\"+char(10)+
	\"---- then:<b> chop [path] [index] @a [outpath]\"+char(10)+
	\"<color=green>param: <color=white>output_filename</color> -- name for outfile\"+char(10)+
	\"-- prompts for output filename if not supplied\"+char(10)+
	\"-- outputs to current path with filename: output_filename \"+char(10)+
	\"-- output_filename may be @clipa, @clipb, or @clipc to output to clipboards instead\"+char(10)+char(10)+
	\"Usage Example: text to chop:\"+char(10)+char(10)+
	\"big bada boom\"+char(10)+
	\"ding dong daddy\"+char(10)+
	\"abracadabra\"+char(10)+char(10)+
	\"* and: index is 1, delimiter is: 'da'\"+char(10)+
	\"* the output would be:\"+char(10)+char(10)+
	\"boom\"+char(10)+
	\"ddy\"+char(10)+
	\"bra\"+char(10)
	if DEBUG then print \"debug: in chop\"
	file = null
	clipping = false
	if typeof(arg1) == \"string\" then
		if arg1 == \"@clipa\" or arg1 == \"@clipb\" or arg1 == \"@clipc\" then
			clipping = true
		else
			file = globals.get_file(arg1)
			if not file then return \"404: file not found\"
		end if
	else
		return \"chop: arg1 must be string: /path or string: @clipa/b/c\"+char(10)+\"clipa/b/c contents must be string.\"
	end if
	if not new_name then new_name = user_input(\"Enter output file name or press <<b>return</b>> for: \"+arg1.remove(\"@\")+\".chop \"+char(10)+\"Enter @clipa or @clipb or @clipc to send output to clip space.\"+char(10)+\":> \",0,0)
	if new_name == \"\" then new_name = arg1.remove(\"@\")+\".chop\"
	new_file = null
	if new_name == \"@clipa\" or new_name == \"@clipb\" or new_name == \"@clipc\" then
		new_file = new_name
	else
		localmachine.touch(currentPath, new_name)
		new_file = globals.get_file(new_name)
		if not new_file then return \"chop: could not write output file. access denied. check write permissions or path and try again.\"
	end if
	if clipping == true then
		if arg1 == \"@clipa\" then
			if typeof(globals.clip_board_alpha) == \"string\" then data = globals.clip_board_alpha.replace(char(160),char(32)).split(char(10)) else return \"chop: clipa contents incompatible. expects string.\"
		end if
		if arg1 == \"@clipb\" then
		  if typeof(globals.clip_board_beta) == \"string\" then data = globals.clip_board_beta.replace(char(160),char(32)).split(char(10)) else return \"chop: clipb contents incompatible. expects string.\"
		end if
		if arg1 == \"@clipc\" then
			if typeof(globals.clip_board_gamma) == \"string\" then data = globals.clip_board_gamma.replace(char(160),char(32)).split(char(10)) else return \"chop: clipc contents incompatible. expects string.\"
		end if
	else
		data = file.get_content.replace(char(160),char(32)).split(char(10))
	end if
	if DEBUG then print \"debug: data: \"+data
	out = []
	del = char(32)
	if arg3 then del = arg3
	if del == char(10) then del = \"/n\"
	if DEBUG then print \"debug: del: \"+del
	//print(\"del: \"+del)
	inde = 0
	if arg2 then inde = arg2.to_int
	if typeof(inde) != \"number\" then inde = 0
	if del == \"/n\" then
		if DEBUG then print \"debug: del is a newline\"
		if data.hasIndex(inde) then out.push( data[inde] )
	else
		for line in data
			if line == \"\" then continue
			//print(\"Chopping \"+line)
			l_split = str(line).split(del)
			i = 0
			fix = []
			for c in l_split
				if c != \"\" then fix.push(l_split[i])
				i = i + 1
			end for
			//print(fix)
			if fix.hasIndex(inde) then out.push(fix[inde])
		end for
	end if
	if DEBUG then print \"debug: writing output\"
	if typeof(new_file) == \"file\" then
		//print(\"error: \"+new_file)
		print \"chop: saving contents to \"+colorWhite+new_file.path
		print new_file.set_content(out.join(char(10)))
		print \"chop: saved:\"
		return new_file.get_content
	else
		if new_file == \"@clipa\" then return command.clipa(out.join(char(10)))
		if new_file == \"@clipb\" then return command.clipb(out.join(char(10)))
		if new_file == \"@clipc\" then return command.clipc(out.join(char(10)))
	end if
end function
command.gopher = function(arg1, arg2, arg3=0, arg4=0) // requires crypto.so
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"Gopher: decipher tool\"+char(10)+\"Usage: gopher [/path/to/file|file_object|hash_string|hash_list|@tbuf] -- decipher hashes using onboard dictionary or crypto.decipher.\"+char(10)+\"-- outputs to /current_path/dump.txt\"+char(10)+\"-- see cerebrum for dictionary options.\"+char(10)+\"-- gopher [/path] -- decipher contents of path\"+char(10)+\"-- gopher [object] -- decipher piped file object\"+char(10)+\"-- gopher [list] -- decipher piped list of strings\"+char(10)+\"-- gopher [string] -- decipher hash string (with or without preceding user: )\"+char(10)+\"-- gopher @tbuf -- deciphers contents of @tbuf\"+char(10)+\"-- tbuf is set when <b>tree</b> encounters a user:hash pair in /home or /etc/passwd\"+char(10)+\"-- eg: gopher user:ee11cbb19052e40b07aac0ca060c23ee or gopher ee11cbb19052e40b07aac0ca060c23ee\"+char(10)+\"N.B. function takes string, file_object, list. function writes to dump.txt. function returns string.\"+char(10)+\"Advanced: gopher runs recursively on each line therefore each line of a file or list or string may:\"+char(10)+\"-- be a user:hash string\"+char(10)+\"-- be a hash string\"+char(10)+\"-- be a path to a file\"+char(10)+\"-- contain a list of the aforementioned types\"
	if not globals.crypto then print( \"Warning: Crypto: not found\" )
	data = []
	if typeof(arg1) != \"string\" and typeof(arg1) != \"list\" and typeof(arg1) != \"file\" then return \"gopher: invalid input: expects string, file, or list \"
	if DEBUG then print(\"top of gopher\")
	if arg1 == \"@tbuf\" then arg1 = globals.T_BUF // deprecated, @tbuf is now a callable variable, however this remains so that @tbuf may be used in an internal call
	if typeof(arg1) == \"file\" then
		if arg1.has_permission(\"r\") then data = arg1.get_content.split(char(10)) else return \"gopher: can't read \"+arg1+\": permission denied.\"
	end if
	if typeof(arg1) == \"string\" then
		fpath = globals.get_file(arg1)
		if fpath and typeof(fpath) == \"file\" then
			if DEBUG then print(\"gopher: found file: \"+fpath.path)
			if fpath.has_permission(\"r\") then data = fpath.get_content.split(char(10)) else return \"gopher: can't read \"+fpath.path+\": permission denied.\"
		else
			if DEBUG then print(\"in gopher: is_string: arg1 is: \"+arg1+\" which is a \"+typeof(arg1)+\" of length: \"+arg1.len)
			if arg1.len == 32 then // hash string
				data = arg1
			else 
				if arg1.indexOf(char(10)) >= 0 then 
					data = arg1.split(char(10))
				else 
					if arg1.indexOf(\":\") and arg1.len > 32 then data = arg1 else return \"gopher: skipping invalid string\"
				end if
			end if
		end if
	end if
	if typeof(arg1) == \"list\" then
		data = arg1 
	end if 
	if DEBUG then print(\"data type is: \"+typeof(data))
	if typeof(data) == \"list\" then
		for element in data 
			if element == \"\" or element == \" \" then continue
			if DEBUG then print \"debug: gopher loop is looping on element: \"+char(10)+element
			if is_valid_ip(element.split(\"@\")[0]) then 
				print \"gopher: skipping ip address line\" 
				continue
			end if
			wait(.1)
			print \"gopher: going for it...\"
			ctc = (command.gopher( element ))
			if ctc then print ctc
		end for
	end if
	if typeof(data) == \"string\" then 
		print(\"gopher: deciphering:<b> \"+data)
		user = \"unknown_user\"
		if data.indexOf(\":\") then
		data = data.split(\":\")
		user = data[0]
		data = data[1]
		end if 
		if data.len != 32 then return \"gopher: skipping invalid hash string\"
		pass = command.md5(\"-d\",data) // decipher here
		output = user + \":\" + pass + \":\"+data
		print(\"[\"+colorGold+user+\":\"+colorGold+pass+CT+\":\"+data+\"]\")
		dump = command.tree(\"/\",\"dump.txt\",\"1\",\"n\")
		if not dump then 
			command.poke(\"dump.txt\")
			dump = globals.get_file(\"dump.txt\")
		end if
		if dump and typeof(dump) == \"file\" and dump.has_permission(\"w\") then //and dump.has_permission(\"r\") then 
			print(\"gopher: saving data to \"+dump.path)
			print command.append(dump,output)
		else 
			print \"gopher: failed to write to dump.txt; check permissions\"
		end if
	end if 
	return 0
end function
command.grep = function(a1, a2, arg3=0, arg4=0)
	find_file = false
	return_name = false
	return_path = false
	return_list = false
	globals.grepped_file = null
	if a1 and a1 == \"-f\" or a1 == \"-n\" or a1 == \"-fn\" or a1 == \"-p\" or a1 == \"-fp\" or a1 == \"-a\" or a1 == \"-fa\" then
		find_file = true 
		if a1 == \"-n\" or a1 == \"-fn\" then return_name = true
		if a1 == \"-p\" or a1 == \"-fp\" then return_path = true
		if a1 == \"-a\" or a1 == \"-fa\" then return_list = true
		if DEBUG then print \"debug: grep: findfile == true\"
		a1 = a2
		a2 = arg3
		if not a2 then a2 = \"/\"
	end if
	if not a1 then return \"grep: input error\"
	if a1 == \"-h\" or a1 == \"help\" then return \"GREP || get regular expression || regex\"+char(10)+
		colorCyan+\"Usage: grep [opt:-f|-n|-p] [pattern] [opt: search_path (default: / ) | object] \"+char(10)+
		\"-- supports partial matches and limited regular expressions.\"+char(10)+char(10)+
		\"Usage: grep [pattern] [search_path|object] -- grep for text in files and folders\"+char(10)+
		\"-- searches for text matching a given pattern\"+char(10)+
		\"-- returns all matching text, with line numbers and positions, found in search_path\"+char(10)+
		\"-- search_path may be a file, or folder, or object\"+char(10)+
		\"-- descends folders and files from search_path\"+char(10)+
		\"-- descends from <b>/</b> on object if search_path is a shell or computer object\"+char(10)+
		\"-- descends from path of file if search_path is a file object\"+char(10)+char(10)+
		\"Usage: grep [-f] [pattern] [search_path|object] -- grep for file\"+char(10)+
		\"-- searches search_path or piped object for a <b>file</b> with name matching pattern \"+char(10)+
		\"-- piped computer and shell objects will be searched from the <b>/</b> directory.\"+char(10)+
		\"-- piped file objects will be searched from the path of the file.\"+char(10)+
		\"-- returns a <b>file object</b> for the first match in the file tree\"+char(10)+	
		\"---- what coutns as a first match is still a w.i.p....\"+char(10)+char(10)+
		\"Usage: grep [-n|-fn] [pattern] [search_path|object] -- grep for file name\"+char(10)+
		\"-- searches search_path for file with name matching pattern\"+char(10)+
		\"-- returns the <b>file name</b> as a string\"+char(10)+
		\"-- uses the same search method as -f\"+char(10)+
		\"-- the -fn option is equivalent to the -n option\"+char(10)+char(10)+
		\"Usage: grep [-p|-fp] [pattern] [search_path|object] -- grep for file path\"+char(10)+
		\"-- searches search_path for file with name matching pattern\"+char(10)+
		\"-- returns the <b>file path</b> as a string\"+char(10)+
		\"-- uses same search method as -f\"+char(10)+
		\"-- -fp option is equivalent to -p option\"+char(10)+char(10)+
		\"Usage: grep [-a|-fa] [pattern] [path|object] -- return a <b>list of file objects</b> matching pattern\"+char(10)+char(10)+
		colorCyan+\"<u>current regex tokens (more planned):</u>\"+char(10)+
		\"c   matches any literal character 'c'\"+char(10)+
		\"-- bob matches bob anywhere in the text.\"+char(10)+
		\"^   match pattern from beginning of word\"+char(10)+
		\"-- ^ber matches bertha  does not match robert\"+char(10)+
		\"$   match end of line (goes at end of pattern)\"+char(10)+
		\"-- .txt$ matches file.txt does not match file.txt.src\"+char(10)+
		\"#   matches one or more of <b>preceding</b> character\"+char(10)+
		\"-- c# matches c, cc, ccc, cccc \"+char(10)+
		\"*   matches any unicode char (wildcard)\"+char(10)+
		\"-- *#:*#  matches root:password, email@domain.com:password, xyz:1234\"+char(10)+
		\"- - - - - - - - - - - - - - - - - - - - - - - - - \"+char(10)+
		\"Important! Runtime depends on length of pattern and size of text to check. \"+char(10)+
		\"Since grep will recurse any folders in a given path, this command could result in very long run times. \"+char(10)+
		\"It is up to you to limit the scope of your searches accordingly.\"+char(10)
			
	gresult = []
	gname = null

	gp = function(grep_tar, t_f, use_re, findfile)
		if DEBUG then print \"debug: in gp\"
		if t_f.is_folder and t_f.is_binary then
			sub_folders = t_f.get_folders
			sub_files = t_f.get_files
			g_buf = null
    		if globals.grepped_file != null then return 
			for sub in sub_folders
				if use_re == true then
					if re.match(grep_tar.values, sub.name.values) then 
						//gresult.push(colorLightBlue+\"Found folder: \"+CT+colorOrange+sub.name+CT+colorLightBlue+\" in: \"+ sub.parent.path + CT)
						if sub.is_symlink then 
							gresult.push(colorLightBlue+\"Found symlink: \"+CT+colorOrange+sub.name+CT+colorLightBlue+\" linked to folder in: \"+ sub.parent.path + CT+char(10)+colorGold+\"               |<u>\"+sub.path)
						else
							gresult.push(colorLightBlue+\"Found folder: \"+CT+colorOrange+sub.name+CT+colorLightBlue+\" in: \"+ sub.parent.path + CT)
						end if
						if findfile == true then
							greppy.grepped.push(sub)
							print greppy.grepped[-1][\"name\"]
							print gresult[-1]
							globals.grepped_file = sub
							gname = sub.name
							if DEBUG then print \"debug: found \"+sub.path
							if not return_list then return
						end if
					end if
				else
					if sub.name == grep_tar or sub.name.indexOf(grep_tar) then 
						//gresult.push(colorLightBlue+\"Found folder: \"+CT+colorOrange+sub.name+CT+colorLightBlue+\" in: \"+ sub.parent.path + CT)
						if sub.is_symlink then 
							gresult.push(colorLightBlue+\"Found symlink: \"+CT+colorOrange+sub.name+CT+colorLightBlue+\" linked to folder in: \"+ sub.parent.path + CT+char(10)+colorGold+\"               |<u>\"+sub.path)
							
						else 
							gresult.push(colorLightBlue+\"Found folder: \"+CT+colorOrange+sub.name+CT+colorLightBlue+\" in: \"+ sub.parent.path+CT)
							
						end if
						if findfile == true then
							greppy.grepped.push(sub)
							print greppy.grepped[-1][\"name\"]
							if DEBUG then print \"debug: found \"+sub.path
							print gresult[-1]
							globals.grepped_file = sub
							if not return_list then return
						end if
					end if
				end if
				gp(grep_tar, sub, use_re, findfile)
			end for
			for f in sub_files
				if use_re == true then
					if re.match(grep_tar.values, f.name.values) then 
            			//gresult.push(colorLightBlue+\"Found file: \"+CT+colorOrange+f.name+CT+colorLightBlue+\" in: \"+ f.parent.path + CT)
						if f.is_symlink then 
							gresult.push(colorLightBlue+\"Found symlink: \"+CT+colorOrange+f.name+CT+colorLightBlue+\" linked to file in: \"+ f.parent.path + CT+char(10)+colorGold+\"               |<u>\"+f.path)
						else 
							gresult.push(colorLightBlue+\"Found file: \"+CT+colorOrange+f.name+CT+colorLightBlue+\" in: \"+ f.parent.path + CT)
						end if
						if findfile == true then
							greppy.grepped.push(f)
							if DEBUG then print \"debug: found \"+f.path
							print gresult[-1]
							globals.grepped_file = f
							if not return_list then return
						end if
          			end if
				else
					if f.name == grep_tar or f.name.indexOf(grep_tar) >= 0 then 
						if f.is_symlink then 
							gresult.push(colorLightBlue+\"Found symlink: \"+CT+colorOrange+f.name+CT+colorLightBlue+\" linked to file in: \"+ f.parent.path + CT+char(10)+colorGold+\"               |<u>\"+f.path)
						else 
							gresult.push(colorLightBlue+\"Found file: \"+CT+colorOrange+f.name+CT+colorLightBlue+\" in: \"+ f.parent.path + CT)
						end if
						if findfile == true then
							greppy.grepped.push(f)
							if DEBUG then print \"debug: found \"+f.path  
							print gresult[-1]
							globals.grepped_file = f
							if not return_list then return
						end if
          			end if
				end if
				gp(grep_tar, f, use_re, findfile)
			end for
		end if
		if t_f.is_binary or findfile == true then return
		buf = t_f.get_content
		if buf == \"\" or buf == null then return
		lines = buf.split(char(10))
		for line in lines
			words = line.split(\" \")
			for word in words
				if use_re == true then
					if re.match(grep_tar.values, word.values) then 
						gresult.push(colorLightBlue+\"Found: \"+CT+colorWhite+word+CT+colorLightBlue+\" on line \"+lines.indexOf(line)+\" word \"+words.indexOf(word)+\" in file: \"+ t_f.path + CT)
					end if
				else
					if word == grep_tar or word.indexOf(grep_tar) >= 0 then 
						gresult.push(colorLightBlue+\"Found: \"+CT+colorWhite+word+CT+colorLightBlue+\" on line \"+lines.indexOf(line)+\" word \"+words.indexOf(word)+\" in file: \"+ t_f.path + CT)
					end if
				end if
			end for
		end for
  	end function
	
	greppy = {}
	greppy.grepped = []
	output = \"No \"+a1+\" found.\"
	t_f = null // target file or folder
	grep_tar = a1.trim
	invoke_regex = false
	special_chars = [\"*\",\"^\",\"$\",\"#\"] // * changed to #, . changed to *
	for special in special_chars
		if grep_tar.indexOf(special) >= 0 then invoke_regex = true
	end for
  	if not a2 then a2 = \"/\"
	tf_path = a2
	if typeof(tf_path) == \"string\" then
		t_f = globals.get_file(tf_path)
		if not t_f then return \"grep: \"+a2+\" not found.\"
	end if
	// piped object handling. Unused if run as standalone but if baked into your own script, pipe objects to grep them.
	if typeof(tf_path) == \"file\" then t_f = tf_path
	if typeof(tf_path) == \"computer\" then t_f = tf_path.File(\"/\")
	if typeof(tf_path) == \"shell\" then t_f = tf_path.host_computer.File(\"/\")
	if typeof(t_f) != \"file\" then return \"grep: \"+a2+\": unkown type.\"
	// end piped object handling.
	if DEBUG then print \"debug: gresult is: \"+gresult
	gp(grep_tar, t_f, invoke_regex, find_file)///////////////////////////////fire away!
  	if DEBUG then print \"debug: ggf: \"+typeof(globals.grepped_file)
  	if globals.grepped_file then 
		if return_name then return globals.grepped_file.name // change this to greppy.grepped_file
		if return_path then return globals.grepped_file.path
		if return_list then return greppy.grepped
 	 	return globals.grepped_file
	end if
	if gresult != [] then output = gresult.join(char(10))
	return output
end function
command.tree = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"<b><u>tree || list files || file grep\"+char(10)+
	\"Usage: <b>tree</b> -- view filesystem tree (from / if no argument)\"+char(10)+
	\"Usage: tree [path|object] -- view filesystem from path down\"+char(10)+
	\"Usage: tree [opt: path(string)|object(object)] [opt: grep_target(string)] [quiet: 1|0] [opt: r|y|n]\"+char(10)+
	\"-- [path] - path to descend\"+char(10)+
	\"-- [object] - shell or computer: descends from / on object\"+char(10)+
	\"-- [object] - file: descends from path of file object on said object\"+char(10)+
	\"-- [grep_target] - search for target file by name\"+char(10)+
	\"---- matches exact name (no regex)\"+char(10)+
	\"---- <b>returns the file as an object if found</b>\"+char(10)+
	\"-- [1|0] -  1 = quiet, supress output\"+char(10)+
	\"-- [1|0] -  0 = verbose, print output\"+char(10)+
	\"-- [r|n|y] - r = send to t_buf, n = ignore, y = decipher (default is <b>r</b>)\"+char(10)+
	\"---- this option determines where bank.txt, mail.txt, passwd, and others are stored when encountered\"+char(10)+
	\"---- see command.clipa|b|c for more (ie <b>clipb -h</b>)\"+char(10)+
	\"-- e.g:<b> tree / database.csv 1 N | file -b</b> \"+char(10)+
	\"---- find database.csv on filesystem, display properties, pipe to BUFFER\"+char(10)+
	\"N.B. You may use @a, @b, @c or @clipa, @clipb, @clipc to reference [object]\"+char(10)+
	colorGreen+\"-- -- -- -- -- --\"+char(10)+
	\"<b>New: tree -f [path|object] [opt: 1|0 ]\"+char(10)+
	\"-- tree a directory or object and enumerate all files \"+char(10)+
	\"-- omitting path|object, and opt defaults to the / path\"+char(10)+
	\"-- [opt: 1] - quiet mode; suppress output.\"+char(10)+
	\"-- [opt: 0] - print output; default\"+char(10)+
	\"---- omitting this option will default to printing output\"+char(10)+
	\"-- enumerates to the enum buffer\"+char(10)+
	\"---- see <b>enum -h</b> for instructions on how to use it\"+char(10)+
	\"- - - - - - - - - - - - - - - - - - - <b>details</b> - - - - - - - - - - - - - - - - - - - \"+char(10)+
	\"Usage: tree -f [path] -- trees from path, enumerates file objects to enum, prints output\"+char(10)+
	\"-- returns string\"+char(10)+
	\"Usage: tree -f [object] -- trees from object's <b>/</b> directory, enumerates, prints output\"+char(10)+
	\"-- returns string\"+char(10)+
	\"Usage: tree -f [path|object] [1]-- performs as above but does <b>not</b> print output\"+char(10)+
	\"-- returns 0\"+char(10)+
	\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \"+char(10)+
	\"Usage: tree -r [path|object] -- trees from path or object's '/' dir \"+char(10)+
	\"-- returns output as a <b>list</b> of file objects\"+char(10)+
	\"-- does not print filesystem output\"+char(10)+
	\"-- does not enumerate output\"
	tem = null
	use_new_tree = false
	return_list = false
	if arg1 == \"-f\" or arg1 == \"-fr\" or arg1 == \"-rf\" or arg1 == \"-r\" then 
		use_new_tree = true 
		// new tree stuff goes here
		if arg1 == \"fr\" or arg1 == \"-rf\" or arg1 == \"-r\" then 
			return_list = true
			arg3 = \"2\"
		end if
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
	end if 
	if arg1 then
		if arg1 == \"@clipa\" or arg1 == \"@a\" then arg1 = globals.clip_board_alpha
		if arg1 == \"@clipb\"  or arg1 == \"@b\" then arg1 = globals.clip_board_beta
		if arg1 == \"@clipc\"  or arg1 == \"@c\" then arg1 = globals.clip_board_gamma
		if typeof(arg1) == \"string\" then tem = globals.get_file(arg1)
		if typeof(arg1) == \"shell\" or typeof(arg1) == \"ftpshell\" then tem = arg1.host_computer.File(\"/\")
		if typeof(arg1) == \"computer\" then tem = arg1.File(\"/\")
		if typeof(arg1) == \"file\" then tem = arg1
	else
		tem = localmachine.File(\"/\")
	end if
	if not tem or not p_validate(tem,\"size\") then return \"tree: invalid path or file\"
	if arg3 == \"0\" then arg3 = 0
	if use_new_tree == true then return globals.newtree(tem,arg2)
	globals.grepped_file = null
	globals.list_files(tem, arg2, arg3, arg4)
	if arg2 and globals.grepped_file and globals.grepped_file.name == arg2 then return globals.grepped_file
	return 0
end function
command.makfit = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or not arg2 or arg1 == \"help\" or arg1 == \"-h\" then return \"<u>File Compression || File Size || MAKFIT</u>\"+char(10)+
	\"Make it fit file compression tool by Plu70\"+char(10)+
	\"File sizes are (mostly) determined by name. This tool will\"+char(10)+
	\"-- build files with different names until at or below the desired size.\"+char(10)+
	\"-- if the -n option is used, no input file is used\"+char(10)+
	\"---- instead a dummy file is used and saved as the discovered name\"+char(10)+char(10)+
	\"<b>Usage: makfit [/path.src] [target_size_in_bytes] [opt: -A --include uppercase]\"+char(10)+
	\"-- target size in bytes determines ceiling for acceptable file size\"+char(10)+
	\"---- min 120000, max unlimited however it is unlikely to see > 10MB\"+char(10)+
	\"-- will change the file's name back to the name of the .src when done\"+char(10)+
	\"-- builds to size and outputs to parent path of .src file.\"+char(10)+
	\"Extra: makfit [-n] [target_size_in_bytes] [opt:-A] -- do not use a source file \"+char(10)+
	\"-- final filename may be used when compiling any script\"+char(10)+
	\"-- this allows you to find a filename without supplying a source file.\"+char(10)+
	\"Note: when successful makfit will return the compressed file as an object.\"+char(10)+
	\"Usage Example:\"+char(10)+
	\"|> poke my.src | scribus | makfit my.src 150000 | run\"
	no_source = false
	source = \"print(\"\"Hellow World\"\")\"
	time_start = time
	source_path = arg1
	SIZE = arg2.to_int
	if DEBUG then print(\"current path: \"+ currentPath)
	out_path = currentPath
	out_file = null
	source_file = null
	temp_path = currentPath
	if source_path.lower != \"-n\" then 
		source_file = globals.get_file(source_path)
		if not source_file then return \"makfit: could not find file: \"+source_path
		if source_file.is_binary then return \"makfit: expected text file, got binary.\"
		temp_path = source_file.parent.path	
		if source_file.has_permission(\"r\") then source = source_file.get_content else return \"makfit: cannot read source file. Permission denied.\"
		if DEBUG then print(\"Read: \"+source.len+\" bytes from source file.\")
	end if
	og_name = arg1
	if typeof(source_file) == \"file\" then og_name = source_file.name
	if og_name == \"-n\" then
		no_source = true
		og_name = \"probe.src\"
		if currentPath != \"/\" then source_path = currentPath+\"/\"+og_name else source_path = og_name
		print(\"makfit: running in sourceless mode\"+char(10)+\"Creating dummy file: probe.src\")
	 	command.poke(source_path)
		print(\"Securing system.\")
		command.perms(\"lock\",\"all\")
	end if
	print(colorLightBlue+\"Building \"+CT+colorWhite+ og_name +CT+colorLightBlue+\" to file size <= \" +CT+colorWhite+ SIZE +CT+colorLightBlue+\" bytes. \"+CT)
	og_name = og_name.split(\"\\.\")[0]
	if DEBUG then print(\"og_name: \"+og_name)
	print(\"<align=center>\"+char(3675)+\"</align>\")
	last_size = (SIZE + 1000)
	last_name = \"\"
	new_name = function(int)
		nm = []
		r = range(\"a\".code,\"z\".code)
		if arg3 == \"-A\" then
			R = range(\"A\".code, \"Z\".code) // it is somehow faster (for me) with this commented out. ymmv
			r = r + R											// i get about 45 sec avg with lowercase and 100 sec avg with upper+lower
		end if
		for loop in range(0, int)
			r.shuffle
			nm.push(char(r[0]))
		end for
		nm.push(\".\")
		r.shuffle
		nm.push(r[0])
		nm = nm.join(\"\")
		return nm
	end function
	//
	i = 0
	l = 1
	while last_size > SIZE
		i = i + 1
		if i >= 50 then
			l = l + 1
			i = 1
		end if
		n = new_name(l)
		catch = localmachine.touch(temp_path, n+\".src\") // create the temp source file
		if DEBUG then print(\"attempted to create \"+temp_path+ \" + \"+ n +\".src\"+char(10)+\"Result: \"+catch)
		if catch == \"Can't compile. Source code is empty\" then return catch
		out_path = temp_path+n
		if temp_path != \"/\" then out_path = temp_path+\"/\"+n
		if DEBUG then print(\"out_path: \"+out_path)
		temp = globals.get_file(out_path+\".src\")
		if not temp then return \"makfit: error could not create tempfile\"
		temp.set_content(source)                      // set it's content with the original source
		catch = shell.build(temp.path, temp_path)     // build it
		if DEBUG then print(\"attempted to build \"+temp.path+char(10)+\"Result: \"+catch)
		//wait(1)
		out_file = null
		out_file = globals.get_file(out_path)
		if not out_file then return(\"makfit: error: \"+out_path+\" not found. build failed.\"+CT)
		last_size = out_file.size.to_int    // check it's size
		if out_file.size.to_int > SIZE then
			out_file.delete
			temp.delete
		end if
    wait(.1)
	end while
	//
	time_end = time
	print(colorLightBlue+\"Compiled \"+colorWhite+out_file.name+colorLightBlue+\" to size: \"+colorWhite+out_file.size+colorLightBlue+\" bytes.\"+CT)
	print(colorLightBlue+\"Process completed in \"+colorOrange+ (time_end - time_start) +colorLightBlue+ \" seconds.\"+CT)
	if arg1 != \"-n\" then
		print(colorLightBlue+out_file.path+\" renamed to: \")
		re_name = \"\"
		if temp_path != \"/\" then temp_path = temp_path + \"/\"
		command.mv(out_file.path,temp_path+og_name)
		print(\"makfit: found filename:\"+colorLightBlue+\" \"+out_file.name)
	end if
	print(\"makfit: compiled:<u>\"+colorWhite+\" \"+out_file.path+\" \"+out_file.permissions+\" </u></b></color>to<b> \"+out_file.size+\" bytes\")
	//command.perms(\"lock\",\"all\") removed because this is bad
	print \"makfit: remember to secure the new file(s)\"+char(10)+\"makfit: returning output file object...\"
	return out_file
end function
command.make = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"</u>Make || Build</u>\"+char(10)+\"Usage: make [/path/file.src] [/destination/folder] [bool_importable: true/false | 1/0]\"+char(10)+\"-- build the .src file and ouput to destination folder.\"+char(10)+\"-- final file name will be input file name with .src stripped.\"+char(10)+\"-- e.g.<b> make /root/src/5hell.src /bin </b>\"+char(10)+\"-- build 5hell.src into a binary and output to:<b> /bin/5hell</b>\"+char(10)+\"-- n.b. make requires the source file to have the .src extension.\"+char(10)+\"-- importable code can be imported by other sources when building.\"+char(10)+\"-- this allows you to build programs with more than 160 characters by importing multiple source files.\"
	pathSource = arg1
	if typeof(arg1) == \"file\" then arg1 = arg1.path
	if typeof(arg1) != \"string\" then return \"make: invalid source path\"
	programPath = arg2
	if typeof(programPath) == \"file\" then programPath = programPath.path 
	importableCode = null
	if not arg2 or typeof(arg2) != \"string\" then programPath = globals.currentPath
  	if arg3 and (arg3 == \"true\" or arg3 == \"1\") then importableCode = 1 else importableCode = 0
	fileSource = globals.get_file(pathSource)
	folderDest = globals.get_file(programPath)
	if not fileSource then return(\"build: can't find \"+ pathSource)
	if not folderDest then return(\"build: can't find \" + folderDest)
	output = shell.build(fileSource.path, folderDest.path, importableCode)
	if output.len == 0 then
		return(\"make: build successful\")
	else
		return(output)
	end if
	return 0
end function
command.aptm = function(arg1, arg2, arg3=0, arg4=0) // requires aptclient.so
	if arg1 == \"-h\" or arg1 == \"help\" then return \"<u>Apt-Get Menu</u>\"+char(10)+\"Usage: aptm -- apt-get menu: \"+char(10)+
	\"-- manage apt functions\"+char(10)+
	\"-- add/remove/search repositories.\"+char(10)+
	\"Usage: aptm [piped_aptclientLib] -- change scope of aptm to supplied lib\"+char(10)+
	\"-- eg: bios -a | cob set apt | exit\"+char(10)+
	\"-- when used on a remote 'silent launch' of 5hell\"+char(10)+
	\"---- pipes aptclientLib to the custom object then exits back to original 5hell\"+char(10)+
	\"-- cob get apt | aptm\"+char(10)+
	\"---- pipes aptclientLib to aptm and changes scope of aptm to remote\"+char(10)+
	\"Advanced: press [7] hot_swap_libs in aptm \"+char(10)+
	\"-- reloads meta/crypto/apt to use latest versions after updating\"+char(10)+char(10)+
	\"APT command line options (skips the menu):\"+char(10)+
	\"Usage: <b>aptm [-i] [filename] [opt: path] </b>-- install filename, if it exists\"+char(10)+
	\"-- if not provided, the install path will be the repository's default\"+char(10)+
	\"-- this is usually /bin or /lib or /usr/bin\"+char(10)+char(10)+
	\"Usage: <b>aptm [-a] [repo_ip] </b>-- add a repository's ip to /etc/apt/sources.txt\"+char(10)+char(10)+
	\"Usage: <b>aptm [-d] [repo_ip] </b>-- remove a repository's ip from /etc/apt/sources.txt\"+char(10)+char(10)+
	\"Usage: <b>aptm [-u] [/path/filename] </b>-- check for a new version of a file\"+char(10)+char(10)+
	\"Usage: <b>aptm [-s] [opt:filename] </b>-- search repositorys for filename\"+char(10)+
	\"-- shows all available files if no filename is provided\"+char(10)+char(10)+
	\"Usage: <b>aptm [--hotswap] </b>-- reload metaxploit.so, crypto.so, and aptclient.so from disk\"+char(10)+
	\"-- searches for and loads the latest version of each lib <b>on disk\"+char(10)+
	\"---- does not run aptm upgrade\"+char(10)+
	\"-- this is the same include_lib routine executed at launch\"
  	if not globals.apt_get then return \"aptm: \"+colorRed+\"Error: no aptclientLib loaded\"+CT
  	if GLASSPOOL then print(colorOrange+\"Ignores Glasspool.\"+CT)
	// apt menu by Plu70
	if arg1 and typeof(arg1) == \"aptclientLib\" then
		print \"apt-get-menu: importing alternate aptclientLib\"+char(10)+\"-- pipe the old lib back to restore\"+char(10)+\"-- eg: liber -i /lib/aptclient.so | aptm\"
		globals.apt_get = arg1 
	end if
	apt = {}
	apt.exit = function()
		return 0
	end function
	apt.check_upgrade = function(override=0)
		apt.update
		chk_upg = function(check)
			need_up = apt_get.check_upgrade(check)
			if need_up == check+\" does not exist in this filesystem\" and check.split(\"/\").len == 1 then need_up = apt_get.check_upgrade(\"/lib/\"+check)
			if need_up == 1 then
				sp = check.split(\"/\")
				nm = sp.pop
				if sp != [] then
					print(\"__\")
					apt_get.install(nm, sp.join(\"/\"))
				else
					print(\"__\")
					apt_get.install(nm)
				end if
				return \"apt-get: \"+check+\" upgrade complete\"
			else
				return \"apt-get: \"+check+\" no upgrades found\"+char(10)+\"-- \"+need_up
			end if
		end function
		if typeof(arg2) == \"string\" and arg2 != \"\" then cup = arg2 else cup = user_input(\"upgrade file_name or /path\"+char(10)+\":> \")
    	if not cup or cup == \"\" or cup == \" \" then return print(\"aborting...\")
		if DEBUG then print \"debug: aptm: searching for: \"+cup
		//f = get_shell.host_computer.File(cup)
		f = globals.get_file(cup)
		if f and f.is_folder then
			files = f.get_files
			print(\"Checking: \"+f.path+char(10)+\"Found: \"+files.len+\" files.\")
			for sub in files
				print(chk_upg(sub.path))
			end for
			return print(\"Batch complete.\")
		end if
    	if f then 
			return print(chk_upg(f.path)) 
		else 
			return \"aptm: warning: file not found on system at given path\"+char(10)+
			\"-- if the lib is not located in /lib, you must use an absolute path\"+char(10)+
			\"-- if you are using a remote aptclientlib.so;\"+char(10)+
			\"---- rerun with <b>aptm -U [libname|path]</b> to force the upgrade\"
		end if
			return print(chk_upg(cup)) // when using a remote aptclientlib, a file may be on the target that is not on the attacking machine
	end function
	apt.add_repo = function()
		apt.update
	  	if typeof(arg2) == \"string\" and arg2 != \"\" then a = arg2 else a = user_input(\"add repo ip:> \")
		  return print(apt_get.add_repo(a))
	end function
	apt.del_repo = function()
		apt.update
		if typeof(arg2) == \"string\" and arg2 != \"\" then a = arg2 else a = user_input(\"del repo ip:> \")
		return print(apt_get.del_repo(a)) 
	end function
	apt.install = function()
		if typeof(arg2) == \"string\" and arg2 != \"\" then return print(apt_get.install(arg2,arg3)) else return print(apt_get.install(user_input(\"install:> \"), user_input(\"directory:> \")))
	end function
	apt.search = function()
		apt.update
		if typeof(arg2) == \"string\" and arg2 != \"\" then a = arg2 else a = (user_input(\"search:> \"))
		return print(apt_get.search(a))
	end function
	apt.show = function()
		apt.update
		print(\"_____________________________________________\"+char(10))
		rb = apt_get.show(user_input(\"show repo:> \"))
	  return print(char(10)+rb)
	end function
	apt.hot_swap = function()
		globals.super_import
		print \"Libraries hot_swapped.\"
		return 1
	end function
	apt.update = function()
	  return print(apt_get.update)
	end function
	
	// check for cli launch args
	apting = false 
	if not arg2 then arg2 = \"\"
	if not arg3 then arg3 = \"\"
	paf = function()
		outer.apting = true 
		outer.arg2 = 0
	end function
	// switch(variable)
		// 	case( condition, @action )
		//  case( condition, @action )
		//  case(...)
	// default( @action )
	switch(arg1)
		case(\"-u\", @apt.check_upgrade)
		case(\"-i\", @apt.install)
		case(\"-a\", @apt.add_repo)
		case(\"-d\", @apt.del_repo)
		case(\"-s\", @apt.search)
		case(\"--hotswap\", @apt.hot_swap)
	default( @paf )
	
	//apting = true
	while apting
		apt.update
		i = 0
		for c in apt.indexes
			print(\"[\"+colorWhite+i+CT+\"] - apt-get.\"+\"<b>\"+c+\"</b>\")
			i = i + 1
		end for
		//print(\"[\"+colorWhite+i+CT+\"] - Exit\")
		a_choice = user_input(\"(q=quit)||: \",0,1).to_int
		if a_choice == 0 or a_choice == \"q\" then return 0
		if typeof(a_choice) != \"number\" or a_choice >= i or a_choice < 0 then continue
		print(apt.indexes[a_choice])
		ap = apt[apt.indexes[a_choice]]
		ap
		print(\"_____________________________________________\")
		print
	end while
	return 0
end function
// felix file explorer by, Plu70
if DEBUG then print(\"<size=75%>loading felix.5pk...(13.584kb)</size>\")
command.felix = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: felix -- file explorer v 0.2, (wip). Use arrow keys to navigate. Press / to manually type a path.\"+char(10)+\"Advanced: felix [shell|computer|file] -- run felix on filesys of piped object.\"+char(10)+\"e.g. clipb @B 1 | felix -- where BUFFER[1] contained a file, shell or computer.\"
  action = {}
  action.cursor = 0
  action.last = 0
  min = 0
  action.max = 0

  action.memory = null
  action.buffer = function(arg=null)
    if arg then action.memory = arg
    if not action.memory then return char(176)
    return action.memory.name
  end function
  action.b = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    globals.BUFFER.push(selected)
    conf = user_input(\"felix:<b> sent \"+selected.name+\" to BUFFER. Acces via memory_alpha.</b>\"+char(10)+\"press <<b>anyKey</b>> to continue\",0,1)
    return inf
  end function
  action.get_selected = function(infile)
    folders = infile.get_folders
    files = infile.get_files
    contents = folders + files
    if contents.len == 0 then return 0
    if contents.hasIndex(action.cursor) then return contents[action.cursor] else return 0
  end function
  action.r = function(inf) //  remove
    selected = action.get_selected(inf)
    if not selected then return inf
    confirm = user_input(\"<b>delete</b> \"+selected.path+\"? [y/N] ||: \",0,1)
    if confirm.lower == \"y\" or confirm == \"RightArrow\" then
      check = selected.delete
      if check then print(check) else print(\"...deleted.\")
    else
      print(\"aborting...\")
    end if
    return inf
  end function
  action.z = function(f)
    if action.memory then action.memory = null
    return f
  end function
  action.x = function(inf)
    nf = action.get_selected(inf)
    if nf then action.buffer(nf)
    return inf
  end function
  action.v = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    if not action.memory then return inf
    dest = inf.path
    label = \"\"
    print(\"[0] abort \"+char(10)+\"[1] overwrite \"+selected.name+char(10)+\"[2] paste to \"+inf.path)
    if selected.is_folder then print(\"[3] paste to \"+selected.path)
    opt = user_input(\"(q=quit)||: \",0,1)
    if opt == \"0\" or opt.lower == \"q\" then return inf
    coop = user_input(\"[<b>0</b>] - Copy or [1] - Move (q=quit)||: \",0,1)
    if coop.lower == \"q\" then return inf
    if opt == \"3\" and selected.is_folder then
      dest = selected.path
      label = action.memory.name
      if coop.to_int == 1 then
        action.memory.move(dest, label)
      else
        action.memory.copy(dest, label)
      end if
      return inf
    end if
    if opt == \"1\" then
      label = selected.name
    else
      if opt == \"2\" then
        label = action.memory.name
      else
        return inf
      end if
    end if
    if coop.to_int == 1 then
      action.memory.move(dest, label)
    else
      action.memory.copy(dest, label)
    end if
    //action.memory = null
    return inf
  end function
  action.e = function(f)
    // poke, mkdir, rename
    return f
  end function
  action.f = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    print(command.file(selected))
    print(colorGreen+\"<u>==================================</u>\"+CT)
    wait_for = user_input(\"press <<b>anyKey</b>> to continue\",0,1)
    return inf
  end function
  action.n = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    new_name = user_input(\"rename_\"+selected.name+\"(null=abort):> \")
    if new_name == \"\" or new_name == \" \" then return inf
    print(selected.rename(new_name))
    return inf
  end function
  action.d = function(inf)
    return action.RightArrow(inf)
  end function
  action.RightArrow = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    if selected.is_folder then // descend into folder
      inf = selected
      action.last = abs(action.cursor)
      action.cursor = 0
      return inf
    end if
    if selected.is_binary then // run prompt
      if selected.name.split(\"\\.\")[-1] != \"so\" then
        doit = user_input(\"launch \"+selected.name+\"? [y/N] \"+char(10)+\"||: \",0,1).lower
        if doit == \"y\" or doit == \"RightArrow\" then
          if typeof(shell) == \"ftpshell\" then
            print(\"launch not available in ftpshell\")
            return inf
          end if
		  globals.stack_pool(\"up\")
          try = shell.launch(selected.path, user_input(\"params for: \"+char(10)+selected.path+\" \"))
		  _cascade // exit if cascade
		  globals.stack_pool(\"down\")
          if try then print(try)
        end if
        return inf
      else
        if selected.path.split(\"/\")[1] == \"lib\" then
          if user_input(\"database this lib.so? [y/N] ||:\",0,1).lower == \"y\" then
            if globals.metaxploit then command.db(\"-l\", selected.name)
          end if
          return inf
        else
          print(colorOrange+\"Selected .so is not in /lib \"+CT+char(10)+\"aborting... \")
          return inf
        end if
      end if
    end if
    if selected.has_permission(\"r\") then
      print(selected.get_content)
      pause = user_input(char(10)+\"press <<b>anyKey</b>> to continue\",0,1)
    end if
    return inf
  end function

  action.a = function(f)
    return action.LeftArrow(f)
  end function
  action.LeftArrow = function(f)
    if f.name != \"/\" then
      f = f.parent
      action.cursor = abs(action.last)
    end if
    return f
  end function

  action.w = function(f)
    return action.UpArrow(f)
  end function
  action.UpArrow = function(f)
    if action.cursor <= min then
      action.cursor = action.max
      return f
    end if
    action.cursor = action.cursor - 1
    return f
  end function

  action.s = function(f)
    return action.DownArrow(f)
  end function
  action.DownArrow = function(f)
    if action.cursor >= action.max then
      action.cursor = min
      return f
    end if
    action.cursor = action.cursor + 1
    return f
  end function

  action.f1 = function(f)
    print(\"-----\")
    print(\"Navigation: [w][a][s][d] or ArrowKeys \")
    print(\"            [d] - rightArrow to: launch bin, open text, scan .so, descend dir\")
    print(\"Manual  cd: [/] - type path stating with / \")
    print(\"               -- the [/] initiates manual entry \")
    print(\"Select:     [x] - selection buffer; sets item to copy from \")
    print(\"Paste:      [v] - performs a paste using selection buffer \")
    print(\"               -- to highlighted selection (opens context menu) \")
    print(\"Remove:     [r] - deletes file \")
    print(\"Unselect:   [z] - remove item from selection buffer \")
    print(\"Clr_scrn:   [c] - toggle clear screen or regular view \")
    print(\"File info:  [f] - get file info/properties for highlighted selection \")
    print(\"Buffit:     [b] - send highlighted selection to BUFFER \")
    print(\"Rename:     [n] - rename highlighted selection \")

    print(\"_____note: launching binaries via felix does NOT activate glasspool_____\")
    print(\"-----\")
    pause = user_input(\"press <<b>anyKey</b>> to continue\",0,1)
    return f
  end function

  action.get = function(arg, afile)
    arg = arg.trim
    if arg != \"DownArrow\" and arg != \"UpArrow\" and arg != \"LeftArrow\" and arg != \"RightArrow\" then arg = arg.lower
    //print(arg)
    if action.hasIndex(arg) then
      a = @action[arg]
      return a(afile)
    else
      return afile
    end if
  end function

  action.branch = function(f, arg) // takes a file object
    file_object = f
    f_path = arg.split(\"/\")
    if f_path[0] == \"\" then f_path[0] = \"/\"
    while file_object.name != \"/\"
      file_object = file_object.parent
    end while
    print(\"f_path: \"+f_path) // debug
    print(\"arg: \"+arg)       // debug
    while file_object.path != arg.trim
      globals.grepped_file = null
      globals.list_files(file_object, f_path.pull, 1,\"N\") // requires 5hell or 5hell.so
      if globals.grepped_file then file_object = globals.grepped_file else return f
    end while
    return file_object
  end function

  path_contents = function(f)
    folders = f.get_folders
    files = f.get_files
    contents = folders + files
    action.max = contents.len - 1
    output = f.permissions+\" \"+f.owner+\" \"+f.group+\" \"+f.size+\" \"+char(1068)+\"[\"+f.is_binary+\"] \"+f.path + char(10) + char(166) + \" [ \" + action.buffer + \" ]\"
    i = 0
    get = \"\"
    c_put = \"\"
    for c in contents
      c_put = c.permissions+\" \"+c.owner+\" \"+c.group+\" \"+c.size+\" \"+char(1068)+\"[\"+c.is_binary+\"] \"+c.name
      output = output+char(10)+c_put
      if i == action.cursor then
        get = c.name
        if get == null then get = \"\"
      end if
      i = i + 1
    end for
    //if get then print( format_columns(output).replace(get,colorOrange+get+CT).replace(\".src\",colorCyan+\".src\"+CT).replace(\".exe\",colorRed+\".exe\"+CT).replace(\".txt\",colorWhite+\".txt\"+CT).replace(\".log\",colorLightBlue+\".log\"+CT).replace(\".jpg\",colorLightBlue+\"</b>.jpg</color>\").replace(\".so\",colorGold+\"</b>.so</color>\").replace(\".html\",colorCyan+\".html\"+CT) ) else print(format_columns(output))
	if get then print( format_columns(output).replace(get,colorOrange+get+CT) ) else print(format_columns(output))
    return
  end function

  ////BEGIN MAINish
  felix = function(file)
    currentPath = file.path
    contents = file.get_folders + file.get_files
    action.max = contents.len - 1
    CLEAR = -1
    while true
      if CLEAR > 0 then
        clear_screen
        button_c = \"<b>C</b>\"
      else
        button_c = \"<b>c</b>\"
      end if
      path_contents(file)
      print(colorLightBlue+currentPath+CT)
      print(\"[F1] help [w][a][s][d] == [^][<][v][>] [q] quit\")
      print(\"[z] clr slct [x] select [v] paste [f] file [n] rename \")
      input = user_input(\"[\"+button_c+\"] tog clrs [r] remove [b] buffit ||: \",0,1)
      print
      if input.lower == \"c\" then
        CLEAR = (CLEAR * (-1)) //  flipbit
        continue
      end if
      if input.lower == \"q\" then return \"Goodbye.\"
      if input == \"/\" then
        input = input + user_input(input,0,0)
        file = action.branch(file, input)
        currentPath = file.path
        continue
      end if
      file = action.get(input, file)
      currentPath = file.path
    end while
    return 0
  end function
  /// END MAINish
  init = function(file_object)
    print(colorOrange+\"Felix file explorer v 1.1 by Plu70\"+CT)
    print(colorLightBlue+\"-----------------------------------------\"+CT)
    while file_object.name != \"/\"
      file_object = file_object.parent
    end while
    return felix(file_object)
  end function
  if typeof(arg1) == \"shell\" then return init(arg1.host_computer.File(\"/\"))
  if typeof(arg1) == \"computer\" then return init(arg1.File(\"/\"))
  if typeof(arg1) == \"file\" then return init(arg1)
  return init(localmachine.File(\"/\"))
end function

command.file = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return colorGreen+\"File || File Properties || Inspect File\"+char(10)+
	colorGreen+\"<u>================================\"+char(10)+
	\"Usage: <b>file [opt:-l|-c|-b|-r|-n|-p] [/path|file_object] [opt:shell|computer|file]</b>\"+char(10)+
		\" File shows the properties information for the given file \"+char(10)+
		\"and takes path or file_object and returns file information as a stirng.\"+char(10)+char(10)+
		\"Usage: file [opt] [/path] -- return information about the file at /path\"+char(10)+
		\"UsagE: file [opt] [object] -- return onformation about the file object\"+char(10)+
		\"Usage: file [opt] [/path] [object] -- return file info for file at path on object\"+char(10)+
		\"-- computer and shell objects: relative paths use present working directory\"+char(10)+
		\"-- file objects: must use absolute path\"+char(10)+
		\"-- file objects: will be searched from  the <b>/</b> directory\"+char(10)+
		\"Advanced: file [opt] [f_object] [object] -- will still return info of f_object; object is ignored\"+char(10)+
		\"Usage: \"+char(10)+
		\"-- file [<color=white>-l</color>] [path|object] [opt:object] -- return number of lines in the file as a string\"+char(10)+
		\"-- file [<color=white>-c</color>] [path|object] [opt:object] -- return number of chars in the file as a string\"+char(10)+
		\"-- file [<color=white>-s</color>] [path|object] [opt:object] -- return size of the file as a string\"+char(10)+
		\"-- file [<color=white>-b</color>] [path|object] [opt:object] -- send file to BUFFER (and display file info)\"+char(10)+
		\"---- also returns the file as an object\"+char(10)+
		\"---- eg: \"+colorLightBlue+\"</b>grep <b>-f</b> *#.log$ /var | file -b\"+char(10)+
		\"-- file [<color=white>-r</color>] [path|object] [opt:object] -- return the file as an object\"+char(10)+
		\"-- file [<color=white>-n</color>] [path|object] [opt:object] -- return the name of file \"+char(10)+
		\"-- file [<color=white>-p</color>] [path|object] [opt:object] -- return the path of file\"+char(10)+
		\"- - - - - - - - - - - - - - - - - -\"+char(10)+
		\"---- eg: <b></b>clipb @B [#] | file -p </b>-- return the path of the piped file object\"+char(10)+
		\"---- eg: <b>file [opt] [path|file] [shell|computer]</b> -- run file on the remote object instead of locally\"
  	get_lines = false
	get_chars = false
  	to_buffer = false
	return_name = false
	return_path = false
	return_file = false
	return_size = false 

	if arg1.indexOf(\"-\") >= 0 then //== \"-l\" or arg1 == \"-c\" or arg1 == \"-b\" then
		if arg1 == \"-r\" then return_file = true
		if arg1 == \"-l\" then get_lines = true
		if arg1 == \"-c\" then get_chars = true
    	if arg1 == \"-b\" then 
			to_buffer = true
			return_file = true 
		end if
		if arg1 == \"-n\" then return_name = true
		if arg1 == \"-p\" then return_path = true
		if arg1 == \"-s\" then return_size = true
		if arg2 then arg1 = arg2 else return \"file: missing path or object: file [opt] [thing] [opt:thing]\"
		if arg3 then arg2 = arg3
		if arg4 then arg3 = arg4
	end if
	if typeof(arg1) == \"string\" then
		file = null
		// backup og computer
		comp_stor = globals.localmachine
		// swap em if you got em
		if arg2 and typeof(arg2) == \"shell\" then globals.localmachine = arg2.host_computer
		if arg2 and typeof(arg2) == \"computer\" then globals.localmachine = arg2
		// find our file somewhere
		if arg2 and typeof(arg2) == \"file\" then
			while arg2.name != \"/\"
				arg2 = arg2.parent 
			end while
			file_list = globals.newtree(arg2,\"2\")
			if file_list then
				for f in file_list
					if f.path == arg1 then file == f 
				end for
			end if			
		else
			file = globals.get_file(arg1)
		end if
		// restore og computer
		globals.localmachine = comp_stor
		// complain if needed
		if not file or typeof(file) != \"file\" then return \"file: \"+arg1+\" not found.\"
		arg1 = file
	end if
	if typeof(arg1) == \"file\" then
		if return_path then return arg1.path
		if return_name then return arg1.name
    	imp_stat = null
		if DEBUG then print \"checking for symlink\"
		sym_stat = null 
		sym_stat = arg1.is_symlink
		if sym_stat then 
			sym_stat = \"yes\"+char(10)+\"parent: \"+arg1.parent.path
			imp_stat = \"symlink\"
		else 
			sym_stat = \"no\"
		end if
		if DEBUG then print \"checking import status: skipping symlinks\"
		imp_stat = arg1.allow_import
		if imp_stat != \"symlink\" then 
			if imp_stat then imp_stat = \"yes\" else imp_stat = \"no\"
		end if
		if DEBUG then print \"status: \"+imp_stat
  		file_id_info = [\"name: \"+arg1.name, \"path: \"+arg1.path, \"size: \"+arg1.size, \"owner: \"+arg1.owner, \"group: \"+arg1.group, \"perms: \"+arg1.permissions] 
		if arg1.is_folder then
			if DEBUG then print \"debug: is_folder\"
			file_id_info.push(\"type: folder\")
			conts = arg1.get_folders.len + arg1.get_files.len
			if DEBUG then print \"subs: \"+conts
			file_id_info.push(\"subs: \"+conts)
		else
			if arg1.is_binary then
				if DEBUG then print \"debug: is_binary\"
				file_id_info.push(\"type: binary\")
				file_id_info.push(\"import: \"+imp_stat)
			else
				if DEBUG then print \"debug: is_text\"
				file_id_info.push(\"type: ascii\")
				lines = 0
				chars = 0
				if arg1.get_content then
					lines = arg1.get_content.split(char(10)).len
					chars = arg1.get_content.values.len
				end if
				file_id_info.push(\"lines: \"+str(lines))
				file_id_info.push(\"chars: \"+str(chars))
			end if
		end if
		file_id_info.push(\"symlnk: \"+sym_stat)
		if return_size == true then 
			//print \"file: returning file size...\"
			return arg1.size
		end if
		if to_buffer then
			globals.BUFFER.push(arg1)
			print \"file: <b>\"+arg1.name+\"</b> sent to <b><color=orange>BUFFER</b>\"
			return format_columns(file_id_info.join(char(10)))
		end if
		if return_file then 
			print \"file: returning object for: \"+arg1.path
			return arg1
		end if
		if get_lines then
			if file_id_info.indexOf(\"type: binary\") == null then return str(lines) else return \"file: \"+arg1.path+\" is binary\"
		end if
		if get_chars then
			if file_id_info.indexOf(\"type: binary\") == null then return str(chars) else return \"file: \"+arg1.path+\" is binary\"
		end if
    	print(colorGreen+\"<u>==================================</u>\"+CT)
		return format_columns(file_id_info.join(char(10)))
	end if
	return \"file: unknown error\"
end function
command.fakepass = function(arg1=0, arg2=0, arg3=0, arg4=0)
    if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: fakepass [opt:ip] [opt:pass] -- create passwd.src in current_path. Check src and build to /bin/passwd. PW capture malware.\"
    ip = arg1
    p = arg2
    if not ip then ip = \"\"\"\"+user_input(\"remote ip:> \",0,0)+\"\"\"\" else ip = \"\"\"\"+ip+\"\"\"\"
    if ip == \"\"\"\"+\"\"+\"\"\"\" then return \"aborting...\"
    if not p then p = \"\"\"\"+user_input(\"remote pass:> \",1,0)+\"\"\"\" else p = \"\"\"\"+p+\"\"\"\"
    if p == \"\"\"\"+\"\"+\"\"\"\" then return \"aborting...\"
    passwd = \"if params.len != 1 then exit(\"\"<b>Usage: passwd [username]</b>\"\"+char(10)+\"\"Example: passwd john\"\");print(\"\"Changing password for user \"\"+params[0]+\"\".\"\");pass = user_input(\"\"New password:\"\", 1);catch = get_shell.host_computer.change_password(params[0], pass);if catch != 1 then;if catch then exit(catch);exit(\"\"Error: password not modified\"\");end if;\"
    rem_c = \"localmachine=get_shell.host_computer;ip = \"+ip+\";pt = 22;user = \"\"root\"\";p=\"+p+\";remote = get_shell.connect_service(ip, pt, user, p);if remote then;remote.host_computer.touch(\"\"/root/rkit\"\",\"\"rpm\"\");rpm=remote.host_computer.File(\"\"/root/rkit/rpm\"\");if rpm then rpm.set_content(rpm.get_content+char(10)+pass+char(10)+localmachine.public_ip+char(10)+localmachine.local_ip);end if;\"
    scrub = \"syslog = localmachine.File(\"\"/var/system.log\"\");if syslog then;localmachine.touch(\"\"/var\"\",\"\"system.bak\"\");sbk=localmachine.File(\"\"/var/system.bak\"\");if sbk then;sbk.set_content(\"\"No IPs Today :D\"\");syslog.delete;sbk.move(\"\"/var\"\", \"\"system.log\"\");end if;end if;\"
    final = \"if catch == 1 then exit(\"\"password modified OK\"\");if catch then exit(catch);print(\"\"Error: password not modified\"\")\"
    fp = passwd + rem_c + scrub + final
    localmachine.touch(currentPath, \"passwd.src\")
    source = globals.get_file(\"passwd.src\")
    print(\"FakePass v 0.2, by Plu70\")
    print(colorRed+\"- - - - - - - - - - - - - - - - - - - - -\"+CT)
    if not source then return \"write error: unable to create passwd.src in \"+currentPath
    source.set_content(fp)
    wait(1)
    print(source.get_content)
    print
    saved = \"password.src\"
    if currentPath != \"/\" then saved = \"/password.src\"
    print(colorLightBlue+\"Saved to: \"+colorWhite+currentPath+saved+CT)
    print(colorRed+\"- - - - - - - - - - - - - - - - - - - - -\"+CT+char(10))
    return 0
end function
command.cad = function(arg1=0, arg2=0, arg3=0, arg4=0)
    if arg1 == \"help\" or arg1 == \"-h\" then return \"cad: cloak and dagger protocol.\"+char(10)+\"Usage: cad [optional: ip ] -- or enter rshell-server ip at prompt\"+char(10)+\"Creates ps.src in current path. \"+char(10)+\"Review ps.src and build with make or makfit into /bin\"+char(10)+\"Remove .src, run /bin/ps once with metaxploit.so present then remove metaxploit.so\"+char(10)+\"The result is a hidden backdoor on the target. Use with care.\"
    ps = \"\"\"\"+\"ps\"+\"\"\"\"
    shell = \"\"\"\"+\"5hell\"+\"\"\"\"
    zp = \"\"\"\"+\"0.0%\"+\"\"\"\"
    z2 = \"\"\"\"+\"0.3%\"+\"\"\"\"
    z1 = \"\"\"\"+\"0.4%\"+\"\"\"\"
    zf = [zp,z1,z2]
    zf.shuffle
    m_path = \"\"\"\"+\"/lib/metaxploit.so\"+\"\"\"\"
    m = \"\"\"\"+\"metaxploit.so\"+\"\"\"\"
    add = arg1
    if not add then add = \"\"\"\"+user_input(\"rshell addr:> \")+\"\"\"\" else add = \"\"\"\"+add+\"\"\"\"
    if add == \"\"\"\"+\"\"+\"\"\"\" then return \"aborting...\"
    rip=\"ps=function();zp=\"+zp+\";z2=\"+z2+\";z1=\"+z1+\";zf=[zp,z1,z2];zf.shuffle;procs = get_shell.host_computer.show_procs;k_tar = \"+ps+\";k_tar1 = \"+shell+\";processes = [];processes = procs.split(char(10));for p in processes;process = p.split(char(32));process_CMD = process[4];process_MEM = process[3];process_CPU = process[2];process_ID = process[1];process_user = process[0];if process_CMD == k_tar or process_CMD == k_tar1 then;continue;else;print(format_columns(process_user + char(32) + process_ID + char(32) + process_CPU + char(32) + process_MEM + char(32) + process_CMD));end if;end for;rng = range(1120, 9982);rng.shuffle;return(format_columns(active_user+char(32)+rng.pop+char(32)+\"+zp+\"+char(32)+zf.pop+char(32)+\"+ps+\"));end function\"
    // nop
    nop=\"meta = include_lib(\"+m_path+\");if not meta then include_lib(\"+m+\");if not meta then exit(ps);meta.rshell_client(\"+add+\",1222,\"+ps+\");exit(ps)\"
    header = char(10)+\"// Cloak and Dagger\"+char(10)
    cd = (header+char(10)+rip+char(10)+nop)
    localmachine.touch(currentPath, \"ps.src\")
    source = globals.get_file(\"ps.src\")
    print(\"Cloak and Dagger Protocol v 0.4, by Plu70\")
    print(colorRed+\"- - - - - - - - - - - - - - - - - - - - -\"+CT)
    if source then
      source.set_content(cd)
      wait(1)
      out = source.get_content
      print(out)
      print
        print(colorLightBlue+\"Saved to: \"+colorWhite+currentPath+\"/ps.src\"+CT)
    else
      print(\"write failed\"+char(10))
    end if
    print(colorRed+\"- - - - - - - - - - - - - - - - - - - - -\"+CT+char(10))
    return 0
end function
  // command.dig = function(arg1, arg2, arg3=0, arg4=0)
  // 	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: dig [ip] [opt:port] -- upload a netcrawler to deep scan a network. \"+char(10)+\"port may be 0 or blank (dig [ip]) for standard use (targets router).\"+char(10)+\"crawler attempts to scrub logs but this may need to be done manually\"+char(10)+\"Advanced: clipb @B 1 | dig  (where BUFFER[1] contained a shell) -- dig that shell\"+char(10)+\"other methods may be used to pipe shells. eg zap | dig (this is redundant as dig runs zap internally)\"+char(10)+\"<b>N.B. dig is not (yet) integrated with db (the databaser) please scan libs before running dig.</b>\"+char(10)+\"N.B. future versions will also include an all command line version (to bypass the interactive setup)\"+char(10)+\"<b>Important</b>: Press enter at most prompts to use defaults (recommended).\"+char(10)+\"When prompted for an exploit to use, select a shell exploit.\"+char(10)+\"If you know the password you may enter it on the SECOND password prompt. It will be colored cyan.\"+char(10)+\"If you don't know the password, DIG is useful for finding it.\"+char(10)+\"You may customize dig, to some degree, when prompted.\"
  // 	// dig local vars
  // 	del_rkit = \"y\"
  // 	have_pass = \"\"
  //   id_target = function()
  //     tar_shel = null
  //     target_ip = arg1
  //     port = \"router\"
  //     if arg2 then port = arg2
  //     if port == \"0\" or not port then port = \"router\"
  // 		// insert dbaser code here
  //     if typeof(target_ip) == \"shell\" then return target_ip
  //     if not is_valid_ip(target_ip) then return \"dig: invalid ip\"
  //     print(colorGold+\"Initiating pre-dig outer scan...\"+CT)
  //     command.probe(target_ip,port)
  //     command.meta(\"link\", \"-r\")
  //     tar_shel = command.zap
  //     if tar_shel and typeof(tar_shel) == \"shell\" and (tar_shel.host_computer.public_ip == target_ip or tar_shel.host_computer.local_ip == target_ip) then
  //       print(colorLightBlue+\"dig: target accquired: \"+CT+colorOrange+\"[\"+checkUser(tar_shel)+\":\"+typeof(tar_shel)+\"] \"+CT+\"<b>\"+tar_shel.host_computer.public_ip+\"</b>\")
  //     else
  //       return \"dig: unable to find a shell on the target\"
  //     end if
  //     return tar_shel
  //   end function
  
  //   prepare_package = function()
  //     pay_path = user_input(\"full path to rkit (default: /root/rkit) \"+char(10)+\":> \",0,0)
  //     if pay_path == \"\" or pay_path == \" \" then pay_path = \"/root/rkit\"
  //     if pay_path == \"\" or pay_path == \" \" then return \"aborting...\"
  //     payload = localmachine.File(pay_path)
  //     if not payload then return \"404: \"+pay_path+\" not found\"
  //     localmachine.touch(payload.path, \"dig.bat\")
  //     dig_bat = localmachine.File(payload.path+\"/dig.bat\")
  //     if not dig_bat then return \"write error: could not create dig.bat\"
  //     dig_bat.set_content(\"ifconfig -l | probe -f\"+char(10))
  //     print(char(10)+\"Found: \"+payload.path + \" \" + payload.size + \" \" + payload.permissions+char(10))
  //     print(\"<b>edit permissions</b>? (default: yes)\")
  //     mod = user_input(\"[<b>0</b>] yes [1] no (q=quit)||: \",0,1)
  //     if mod != \"1\" then
  //       print(\"e.g. o+rwx g-rwx u+x (string all edits on one line separated by spaces)\")
  // 			ed_in = user_input(\"params for [perms/chmod -r] (default:<b> o+rwx </b>, q=quit)\"+char(10)+\":> \")
  // 			if ed_in.lower == \"q\" then return \"aborting...\"
  // 			if ed_in == \"\" then ed_in = [\"o+rwx\"] else ed_in = ed_in.split(\" \")
  //       for ed in ed_in
  //         command.perms(\"-r\", ed, payload.path)
  //       end for
  //     end if
  // 		if mod.lower == \"q\" then return \"aborting...\"
  // 		print
  // 		print(\"Would you like to edit dig.bat before uploading? (default: no)\")
  // 		edit_bat = user_input(\"[<b>0</b>] no [1] yes (q=quit)\"+char(10)+\"||: \",0,1)
  // 		if edit_bat == \"1\" then
  // 			bat_path = payload.path + \"/dig.bat\"
  // 			print(colorGold+\"Editing \"+bat_path+char(10)+\"Please use caution. Abort with @@ on a new line.\")
  // 			command.scribus(bat_path)
  // 			dig_bat.set_content(dig_bat.get_content+char(10))
  // 		end if
  // 		print(char(10)+\"<b>Payload Ready: \"+payload.path + \" \" + payload.size + \" \" + payload.permissions+\"</b>\"+char(10))
  //     return payload // (package)
  //   end function
  
  //   upload_package = function(package) // (payload)
  //     tar = id_target
  //     if typeof(tar) == \"string\" then return tar
  //     command.clipb(tar)
  //     print(\"Expanding filesystem: search for a vulnerable entry point...\")
  //     command.tree(\"@clipb\",\"/\",0,\"N\")
  //     dest_folder = user_input(\"destination folder (default: /home/guest) \"+char(10)+\":> \")
  // 		del_rkit = user_input(\"Delete the rkit once uploaded? [Y/n]\"+char(10)+\"||: \",0,1)
  // 		if dest_folder == \"\" or dest_folder == \" \" then dest_folder = \"/home/guest\"
  // 		dig_bat = localmachine.File(package.path+\"/dig.bat\")
  // 		if del_rkit.lower != \"n\" then
  // 			dig_bat.set_content(dig_bat.get_content+\"echo <b>deleting rkit</b>\"+char(10)+\"rm -r \"+dest_folder+\"/rkit\"+char(10))
  // 		end if
  // 		have_pass = user_input(colorCyan+\"enter a password for dig to use (leave blank for cerebrum or type:<b> -f brutus </b> :to force brutus without cerebrum.)\"+CT+char(10)+\":> \")
  // 		if have_pass == \"-f brutus\" then
  // 			dig_bat.set_content(dig_bat.get_content+\"echo <b>Getting root/covering tracks...</b>\"+char(10)+\"brutus | rclean\"+char(10))
  // 		else
  // 			if have_pass != \"\" and have_pass != \" \" then
  // 				dig_bat.set_content(dig_bat.get_content+\"echo <b>Getting root/covering tracks...</b>\"+char(10)+\"psudo -s \"+have_pass+\" | rclean\"+char(10))
  // 			else
  // 				dig_bat.set_content(dig_bat.get_content+\"echo <b>Getting root...</b> | cerebrum\"+char(10))
  // 				dig_bat.set_content(dig_bat.get_content+\"echo <b>Covering tracks...</b>\"+char(10)+\"brutus | rclean\"+char(10))
  // 			end if
  // 		end if
  // 		print(colorGold+\"<u>=======uploading rkit package=======</u>\")
  // 	  if typeof(tar) == \"shell\" then
  // 	  	print(shell.scp(package.path, dest_folder, tar))
  // 			print(\"Locking down localhost\")
  // 			command.perms(\"lock\",\"all\")
  // 	    hold = globals.shell
  // 	    globals.shell = tar
  // 	    globals.localmachine = shell.host_computer
  // 	    dig_bat = localmachine.File(dest_folder+\"/rkit/dig.bat\")
  // 	    if not dig_bat then
  // 	    	print(\"I/O error...\")
  // 	      globals.shell = hold
  // 	      globals.localmachine = shell.host_computer
  // 	      return \"dig: upload failed\"
  // 	    end if
  //       print(colorGold+\"Digging network...\"+CT+char(10))
  //       command.run(dest_folder+\"/rkit/5hell\", \"do 1 -f dig.bat\")
  //       globals.shell = hold
  //       globals.localmachine = shell.host_computer
  //       return \"dig: complete. remember to lock down permissions! (ie type: lock)\"
  //     else
  //       return \"dig: failed. remember to lock down permissions! (ie type: lock)\"
  //     end if
  //     return 0
  //   end function
  
  //   deploy_package = function()
  //     print(colorGold+\"<u>------DIG-v-0.5.3------</u>\"+CT+char(10)+\"Follow defaults at prompts for <u>standard</u> use. (ie press [enter] at prompts)\")
  //     return upload_package(prepare_package)
  //   end function
  //   // ifconfig -p | probe -f
  //   // cerebrum
  //   // rm -r /home/guest/rkit
  //   // brutus | rclean
  //   catch = deploy_package
  //   return catch
  // end function
command.dig = function(arg1,arg2=0,arg3=0,arg4=0)
  if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then 
    if arg2 and arg2 == \"extra\" then return colorGold+\"Dig: Extra!\"+CT+char(10)+\"Here is a useful dig.bat script for dropping rshells\"+char(10)+\"first, set dig.bat to:\"+char(10)+
		\"ifconfig -p | probe -q\"+char(10)+
		\"brutus | clipb\"+char(10)+
		\"clipa | echo PASSWORD:\"+char(10)+
		\"echo do 1 -f r.bat | clipc\"+char(10)+
		\"run /home/guest/rkit/5hell @b @c\"+char(10)+
		\"rclean -d 1\"+char(10)+
		\"quit dig_complete\"+char(10)+char(10)+
		\"then, poke a new file in rkit called r.bat\"+char(10)+
		\"set it to:\"+char(10)+
		\"rshell [your server ip] [some name]\"+char(10)+
		\"-- if you have set HOME_SERVER then use this line instead:\"+char(10)+
		\"rshell @home [some name]\"+char(10)+
		\"quit rshell_placed\"+char(10)+char(10)+
		\"This will dig the target like normal, then launch 5hell with the gained root shell\"+char(10)+\"Once launched, a reverse shell will be dropped, the log scrubbed, rkit removed, and dig will exit both 5hell instances.\"
    return \"<b>DIG v 2.1 Netcrawler || Autohacking || Automation</b>\"+char(10)+
	\"Usage: dig [-s|ip|port] [port|ip] [opt:--edit] -- auto-infiltrate a target\"+char(10)+
	\"-- runs <b>db</b> on target [ip] and [port]\"+char(10)+
	\"-- infiltrates via shell if found\"+char(10)+
	\"-- uploads rkit and runs 5hell on the target\"+char(10)+
	\"-- gains root and wipes the log\"+char(10)+
	\"-- performs other taskes as defined by the user in <u>dig.bat\"+char(10)+
	\"-- dig.bat may contain <b>do</b>calls (do # -f your.file) to daisy chain digs\"+char(10)+
	\"Note: dig may take port and ip in any order\"+char(10)+
	\"-- not supplying a port defaults to port 0 aka the rouer\"+char(10)+
	\"Usage: dig -s -- will scan the internet for a suitable target\"+char(10)+
	\"-- uses database.csv to choose targets with known kernel_router versions\"+char(10)+
	\"-- if the matched router has a shell exploit, dig will auto infiltrate as normal\"+char(10)+
	\"-- susses out random ips until a match is found\"+char(10)+
	\"-- sussing routers does not leave a log if no shell is found\"+char(10)+
	\"Note: edit /root/rkit/dig.bat to customize behavior\"+char(10)+
	\"-- by default you will be prompted to exit 5hell when dig completes\"+char(10)+
	\"-- type 'y' to exit and return to the script that launched dig\"+char(10)+
	\"-- or add <b>quit dig_complete</b> to exit automatically with an echo\"+char(10)+
	\"<b>Note:</b> supplying <b>--edit</b> as argument three will open dig.bat in scribus\"+char(10)+
	\"-- dig will continue as normal after editing is complete\"+char(10)+
	\"-- you may add/remove commands to be executed by dig here\"+char(10)+
	\"<b>Note:</b> supplying <b>--edit</b> as agrgument one will open dig.bat in scribus\"+char(10)+
	\"-- dig will then exit after editing the batch file.\"+char(10)+
	\"Usage example:|> <b>rnip 1 | dig </b>\"+char(10)+
    \"Usage example:|> <b>dig 1.1.1.1 22 --edit\"+char(10)+
	\"Usage example:|> <b>do 20 | dig -s\"
	colorGold+\"Experimental</b></color>: dig -s -- sus mode, gets random routers and checks version against database\"+char(10)+
	\"-- if the lib version is in the database, will dig that router\"+char(10)+
	\"-- sussing specifically looks for shells on routers\"+char(10)+
	\"-- for best results, use a database.csv that only includes entries with shell exploits\"+char(10)+
	\"---- Extra: dig [-h|help] extra -- display extra help info\"
  end if
  print(colorGold+\"<u>------DIG-v-2.1------</u>\"+CT+char(10))
  //tp = arg1.split(\" \") // sometimes we want to pipe target ip AND a port. this will help with that.
  tp = arg1
  //t = tp[0] // target ip
  //p = tp[-1] // target port
  t = arg1 
  p = arg2
  if t == \"-s\" then 
  	t = globals.sus // in 5phinx.5pk
	p = \"0\"
  end if
  //if p == t then p = arg2 /////////////// make sure this works: if arg1 was not split, arg 2 is the port. default is 0 aka router
  if not is_valid_ip(t) and t != \"--edit\" then
    t = arg2 
    p = arg1 
    if not is_valid_ip(t) and t != \"--edit\" then return \"dig: invalid ip\"
  end if
  if DEBUG then print \"debug: target ip: \"+t+char(10)+\"debug: target port: \"+p
  // find the root kit     
  kit = command.tree(\"/\",\"rkit\",1,\"N\")
  if not kit then return \"rkit not found\"
  pe = kit.permissions.values
  r = 0
  w = 0
  x = 0
  if pe[-1] == \"x\" then x = 1
  if pe[-2] == \"w\" then w = 1
  if pe[-3] == \"r\" then r = 1
  // edit dig.bat if necessary
  if DEBUG then print \"debug: checking for dig.bat in: \"+kit.path
  bat_file = globals.get_file(kit.path+\"/dig.bat\")
  if not bat_file then 
      command.poke(kit.path+\"/dig.bat\", \"ifconfig -p | probe\"+char(10)+\"brutus | clipc\"+char(10)+\"grep -p 5hell | clipb\"+char(10)+\"run @b \"\" do 1 rshell @home \"\" @c\")
      bat_file = globals.get_file(kit.path+\"/dig.bat\")
      if not bat_file then return \"dig: unable to find or create dig.bat, aborting.\"
  end if
  if arg1 == \"--edit\" or arg2 == \"--edit\" or arg3 == \"--edit\" or arg4 == \"--edit\" then 
	print(\"Editing the batch file: \"+bat_file.path)
	command.scribus(bat_file)
  	if arg1 == \"--edit\" then return \"dig: finished editing dig.bat\"
	if p == \"--edit\" then p = \"0\"
  end if
  // verify that we're ready to go
  print(\"Checking dictionary...\")
  if not BIGBRAIN then 
      tabs = globals.get_file(\"/root/tables/tp\")
      if tabs then 
          command.cerebrum(\"-i\",tabs.path)
      else 
          command.cerebrum
      end if
  end if
  // portmap target
  command.probe(\"-q\",t,p)
  print \"dig: clearing old XPLOITS list...\"
  globals.XPLOITS = null
  // if not in database, scan target
//  if command.meta(\"link\",\"-r\") then
  print \"dig: preparing to link database...\"
  dcsv = globals.get_file(kit.path+\"/database.csv\")
  if not dcsv then
	print \"dig: creating \"+kit.path+\"/database.csv..\"
	print command.poke(kit.path+\"/database.csv\")
	dcsv = globals.get_file(kit.path+\"/database.csv\")
	if not dcsv then return colorOrange+\"dig: database error\"+char(10)+\"-- manually create database.csv or run db\"
  end if
  if command.meta(\"link\") then
      command.db(\"-r\")
      //if command.meta(\"link\",\"-r\") then // idfk
	  if command.meta(\"link\") then // idfk
          return \"dig: database error!\"+char(10)+\"-- idfk\"
      end if
  end if
  // if shell exploit, exploit target
  mem = \"\"
  unsec_val = \"\"
  
  for xp in globals.XPLOITS
      yp = xp.split(\" \")
      zp = yp[-1]
      if zp == \"shell\" then 
          mem = yp[0]
          unsec_val = yp[1]
      end if
  end for
  if mem == \"\" then return \"dig: shell exploit not found on target\"
  dig_this = null
  dig_this = command.zap(mem,unsec_val,0) // get the remote shell
  if typeof(dig_this) != \"shell\" then return \"dig: failed to obtain shell on target.\"
  // upload rkit (mind permissions)
  if DEBUG then print \"dig: found a shell\"
  print command.perms(\"-r\",\"o+rwx\", kit.path)
  print kit.path+ \" \"+kit.permissions
  globals.shell.scp(kit.path, \"/home/guest\", dig_this)
  // command.perms(\"-r\",\"o-rwx\",\"/root/rkit\")
  pe = \"\"
  if not r then pe = pe + \"r\"
  if not w then pe = pe + \"w\"
  if not x then pe = pe + \"x\"
  if pe != \"\" then print command.perms(\"-r\",\"o-\"+pe, kit.path)
  print \"restoring permissions: \"+kit.path+\" \"+kit.permissions
  // run 5hell on target with params:
  // -- cob import | brutus
  // -- other user defined params
  print \"launching 5hell remotely...\"
  globals.stack_pool(\"up\")
  dig_this.launch(\"/home/guest/rkit/5hell\", \"do 1 -f /home/guest/rkit/dig.bat\") // let's make this configurable instead of putting ppl on rails
  _cascade // exit if cascade
  globals.stack_pool(\"down\")
  // rclean and exit
  // repeat if necessary
  return \"returning to original 5hell session...\"
end function

// original pwgen by usespython, additions by Plu70
if DEBUG then print(\"<size=75%>loading ...pwgen.5pk...(31.479kb)</size>\")
command.pwgen = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"pwgen: generate a friggin lot of passwords with hashes.\"+char(10)+\"Usage: pwgen -- generate ~/rkit/tables/tp/ and files with one password per line\"+char(10)+\"Usage: pwgen hash -- generate ~/rkit/tables/t5 and files with hash=pw one per line\"+char(10)+\"Use cerebrum to expand onboard dictionary.\"+char(10)+\"NOTE: the tables folder does not need to be in rkit to be used\"+char(10)+\"-- including it in rkit allows you to upload it with rkit to targets\"+char(10)+\"---- move it to a different folder if this is not desired behavior\"

	// pwgen v0.4 by usespython, modifications by Plu70
	PASSWORDSB=\"belagio,balencia,ibiza,3k4l23ll,4567adee,bees,Bee123,hobo,heebeejeebee,geronimo69,Es1,day,abcd,abc1,baby,mayday,today,yesterday,fifteen,abgDw32fhGu58k,69696969,sfuzzer,111,1111,222,2222,3333,333,00000,000,4444,444,5555,555,55555555,4fb426abgDw32fHG,666,6666,thx1138,7777,777,8888,888,9999,999,0000,oicu812,1337,8008,4hpu79htgbr,80085,007007,43110,69696969,t23t49k21af3,evkfdhgbv78ery,6h057,h4ck,h4ckg4m3,g01ng,p0st4l,g01ngp0st4l,81rd,7074g,35sk1m0,pr0n,n00b,nu8,suxor,hazorz,5uxzorz,owned,pwnd,0wnd,p0wn3d,w00t,woo7,woot,w007,10100111001,teh,meh,lol,brb,afk,wyd,gtfo,lmao,lmfao,gitgud,lawl,troll,bawl,epic,54321,987654321,88888888,555555,1234567890,1973,147147,151515,1515,101010,202020,21122112,12341234,74lk,dir7y,53nP4I,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0,le375p34k,420420,11111111,112233,h4f4jf53fk74,123abc,1234qwer,123321,5y4hpu79htgbrub,ncc1701e,7777777,51505150,000000,5150,222222,999999,252525,77777777,98765432,poop,polyamorous,zelda,password,6gtr43,123456,12345678,1234,qwerty,12345,dragon,baseball,football,letmein,monkey,696969,abc123,mustang,michael,shadow,master,jennifer,111111,2000,jordan,superman,harley,1234567,hunter,trustno1,ranger,buster,thomas,tigger,robert,soccer,batman,test,pass,hockey,george,charlie,andrew,michelle,love,sunshine,jessica,6969,pepper,daniel,access,123456789,654321,joshua,maggie,starwars,silver,william,dallas,yankees,123123,ashley,666666,hello,amanda,orange,biteme,freedom,computer,sexy,thunder,nicole,ginger,heather,hammer,summer,corvette,taylor,swift,austin,1111,merlin,matthew,121212,golfer,cheese,princess,martin,chelsea,patrick,richard,diamond,yellow,bigdog,secret,asdfgh,sparky,cowboy,camaro,anthony,matrix,falcon,iloveyou,bailey,guitar,jackson,purple,scooter,phoenix,aaaaaa,morgan,tigers,porsche,mickey,maverick,cookie,nascar,peanut,justin,131313,money,horny,samantha,panties,steelers,joseph,snoopy,boomer,whatever,iceman,smokey,gateway,dakota,cowboys,eagles,chicken,black,zxcvbn,please,pharoa,andrea,ferrari,knight,hardcore,porn,ass,love,sex,hooker,blow,coke,melissa,compaq,coffee,booboo,bitch,johnny,bulldog,xxxxxx,welcome,james,player,ncc1701,wizard,scooby,charles,junior,internet,mike,brandy,tennis,banana,monster,spider,lakers,miller,rabbit,enter,mercedes,brandon,steven,fender,john,yamaha,diablo,chris,boston,tiger,marine,chicago,rangers,gandalf,winter,bigtits,barney,edward,raiders,porn,badboy,blowme,spanky,bigdaddy,johnson,chester,london,midnight,blue,fishing,hannah,slayer,rachel,sexsex,redsox,asdf,marlboro,panther,zxcvbnm,arsenal,oliver,qazwsx,mother,victoria,jasper,angel,david,winner,crystal,golden,butthead,viking,jack,iwantu,shannon,murphy,angels,prince,cameron,girls,madison,wilson,carlos,hooters,willie,startrek,captain,maddog,jasmine,butter,booger,angela,golf,lauren,rocket,tiffany,theman,dennis,liverpoo,flower,forever,green,jackie,muffin,turtle,sophie,danielle,redskins,toyota,jason,sierra,winston,debbie,giants,packers,newyork,jeremy,casper,bubba,dracula,sandra,lovers,mountain,united,cooper,driver,tucker,helpme,pookie,lucky,maxwell,8675309,bear,suckit,gators,shithead,jaguar,monica,fred,happy,hotdog,tits,gemini,lover,xxxxxxxx,777777,canada,nathan,victor,florida,nicholas,rosebud,metallic,doctor,trouble,success,stupid,tomcat,warrior,peaches,apples,fish,qwertyui,magic,buddy,dolphins,rainbow,gunner,987654,freddy,alexis,braves,2112,1212,xavier,dolphin,testing,bond007,member,calvin,voodoo,7777,samson,alex,apollo,fire,tester,chess,walter,beavis,voyager,peter,porno,bonnie,rush2112,beer,apple,scorpio,jonathan,skippy,sydney,scott,red123,power,gordon,travis,beaver,star,flyers,232323,zzzzzz,steve,rebecca,scorpion,doggie,legend,ou812,yankee,blazer,bill,runner,birdie,bitches,parker,topgun,asdfasdf,heaven,viper,animal,bigboy,arthur,baby,private,godzilla,donald,williams,lifehack,phantom,dave,rock,august,sammy,cool,brian,platinum,jake,bronco,paul,mark,frank,heka6w2,copper,billy,cumshot,garfield,willow,cunt,little,carter,slut,albert,kitten,super,jordan23,eagle1,shelby,america,11111,jessie,house,free,chevy,bullshit,white,broncos,horney,surfer,nissan,saturn,airborne,elephant,marvin,shit,action,adidas,qwert,kevin,1313,explorer,walker,police,christin,december,benjamin,wolf,sweet,therock,king,online,brooklyn,teresa,cricket,sharon,dexter,racing,penis,gregory,0000,teens,redwings,dreams,michigan,hentai,magnum,87654321,nothing,donkey,trinity,digital,333333,ramsesii,stella,cartman,guinness,speedy,buffalo,kitty,pimpin,eagle,einstein,kelly,nelson,nirvana,vampire,xxxx,playboy,louise,pumpkin,snowball,test123,girl,sucker,mexico,beatles,fantasy,ford,gibson,celtic,marcus,cherry,cassie,888888,natasha,sniper,chance,genesis,hotrod,reddog,alexande,college,jester,passw0rd,smith,lasvegas,carmen,slipknot,death,kimberly,1q2w3e,eclipse,1q2w3e4r,stanley,samuel,drummer,homer,montana,music,aaaa,spencer,jimmy,carolina,colorado,creative,hello1,rocky,goober,friday,AceofSpades,bollocks,scotty,abcdef,bubbles,hawaii,asakista,fluffy,mine,stephen,horses,thumper,darkness,asdfghjk,pamela,boobies,buddha,vanessa,sandman,naughty,douglas,honda,matt,azerty,6666,shorty,money1,beach,loveme,4321,simple,poohbear,444444,badass,destiny,sarah,denise,vikings,lizard,melanie,assman,sabrina,nintendo,water,good,howard,time,123qwe,november,xxxxx,october,zxcv,shamrock,atlantis,warren,wordpass,julian,mariah,rommel,1010,harris,predator,sylvia,massive,cats,sammy1,mister,stud,marathon,rubber,ding,trunks,desire,montreal,justme,faster,kathleen,irish,1999,bertha,jessica1,alpine,sammie,diamonds,tristan,swinger,shan,stallion,pitbull,letmein2,roberto,ready,april,palmer,ming,shadow1,audrey,chong,clitoris,wang,shirley,jackoff,bluesky,sundance,renegade,hollywoo,bernard,wolfman,soldier,picture,pierre,ling,goddess,manager,nikita,76hj93DB3wsa2,sweety,titans,hang,fang,ficken,niners,bottom,bubble,hello123,ibanez,webster,sweetpea,stocking,freeman,french,mongoose,speed,dddddd,hong,henry,hungry,yang,catdog,cheng,ghost,gogogo,randy,tottenha,curious,butterfl,mission,january,singer,sherman,shark,techno,lancer,lalala,autumn,chichi,orion,trixie,clifford,delta,bobbob,bomber,holden,kang,kiss,1968,spunky,liquid,mary,beagle,granny,network,bond,kkkkkk,millie,biggie,beetle,teacher,susan,toronto,anakin,genius,dream,dang,bush,nyx\".split(\",\")
	PASSWORDSA=\"operator,1966,966235,feral,323232,blonde,lond,osint,msfconsole,Bd5gHie89YA,tornado,lindsey,content,bruce,buck,aragorn,griffin,chen,campbell,trojan,christop,newman,wayne,tina,rockstar,father,geronimo,pascal,crimson,brooks,hector,penny,anna,camera,chandler,fatcat,lovelove,cody,cunts,waters,stimpy,finger,cindy,wheels,viper1,latin,robin,greenday,creampie,brendan,hiphop,willy,snapper,funtime,duck,trombone,adult,cotton,cookies,kaiser,mulder,westham,latino,jeep,ravens,aurora,drizzt,madness,hermit,energy,kinky,314159,leather,bastard,young,,extreme,hard,password1,vincent,lacrosse,hotmail,spooky,amateur,alaska,badger,paradise,maryjane,soup,crazy,mozart,video,russell,vagina,spitfire,anderson,norman,otaku,eric,cherokee,cougar,barbara,long,family,horse,enigma,allison,raider,brazil,blonde,jones,55555,dude,drowssap,jeff,school,marshall,lovely,1qaz2wsx,jeffrey,caroline,franklin,booty,molly,snickers,leslie,nipples,courtney,diesel,rocks,eminem,westside,suzuki,daddy,passion,hummer,ladies,Azachary,frankie,elvis,reggie,alpha,suckme,simpson,patricia,pirate,tommy,semperfi,jupiter,redrum,freeuser,wanker,stinky,ducati,paris,natalie,babygirl,bishop,windows,spirit,tiktok,thot,pantera,monday,patches,brutus,houston,smooth,penguin,marley,forest,cream,212121,flash,maximus,nipple,bobby,bradley,vision,pokemon,champion,fireman,indian,softball,picard,system,clinton,cobra,enjoy,lucky1,claire,claudia,boogie,timothy,marines,security,dirty,admin,wildcats,pimp,dancer,hardon,veronica,abcd1234,abcdefg,ironman,wolverin,remember,great,freepass,bigred,squirt,justice,francis,hobbes,kermit,pearljam,mercury,domino,9999,denver,brooke,rascal,hitman,mistress,simon,tony,bbbbbb,friend,peekaboo,naked,budlight,electric,sluts,stargate,saints,bondage,brittany,bigman,zombie,swimming,duke,qwerty1,babes,scotland,disney,rooster,brenda,mookie,swordfis,candy,duncan,olivia,hunting,blink182,alicia,8888,samsung,bubba1,whore,virginia,general,passport,aaaaaaaa,erotic,liberty,arizona,jesus,abcd,newport,skipper,rolltide,balls,happy1,galore,christ,weasel,242424,wombat,digger,classic,bulldogs,poopoo,accord,popcorn,turkey,jenny,amber,bunny,mouse,titanic,liverpool,dreamer,everton,friends,chevelle,carrie,gabriel,psycho,nemesis,burton,pontiac,connor,eatme,lickme,roland,cumming,mitchell,ireland,lincoln,arnold,spiderma,patriots,goblue,devils,eugene,empire,asdfg,cardinal,brown,shaggy,froggy,qwer,kawasaki,kodiak,people,phpbb,light,kramer,chopper,hooker,honey,whynot,lisa,baxter,adam,snake,ncc1701d,qqqqqq,airplane,britney,avalon,sandy,sugar,sublime,stewart,wildcat,raven,scarface,elizabet,123654,trucks,wolfpack,lawrence,raymond,american,alyssa,bambam,movie,woody,shaved,snowman,tiger1,chicks,raptor,1969,stingray,shooter,france,stars,madmax,kristen,sports,jerry,789456,garcia,simpsons,lights,ryan,looking,chronic,alison,hahaha,packard,hendrix,perfect,service,spring,srinivas,spike,katie,oscar,brother,bigmac,suck,single,cannon,georgia,popeye,tattoo,texas,party,bullet,taurus,sailor,wolves,panthers,japan,strike,flowers,pussycat,chris1,loverboy,berlin,sticky,marina,tarheels,fisher,russia,connie,wolfgang,testtest,mature,bass,catch22,juice,michael1,159753,women,alpha1,trooper,hawkeye,head,freaky,dodgers,pakistan,machine,pyramid,vegeta,katana,moose,tinker,coyote,infinity,inside,letmein1,bang,control,hercules,morris,james1,tickle,outlaw,browns,billybob,pickle,test1,michele,antonio,sucks,pavilion,changeme,caesar,prelude,tanner,adrian,darkside,bowling,wutang,sunset,robbie,alabama,danger,zeppelin,juan,rusty,pppppp,nick,2001,ping,darkstar,madonna,qwe123,bigone,casino,cheryl,charlie1,mmmmmm,lakota,akota,integra,wrangler,apache,tweety,qwerty12,bobafett,simone,none,business,sterling,trevor,transam,dustin,harvey,england,2323,seattle,ssssss,rose,harry,openup,pandora,trucker,wallace,indigo,storm,malibu,weed,review,babydoll,doggy,dilbert,pegasus,joker,catfish,flipper,valerie,herman,detroit,kenneth,cheyenne,bruins,stacey,smoke,joey,seven,marino,fetish,xfiles,wonder,stinger,pizza,babe,pretty,stealth,manutd,gracie,gundam,cessna,longhorn,presario,mnbvcxz,wicked,mustang1,victory,shelly,awesome,athena,q1w2e3r4,help,holiday,knicks,street,redneck,casey,gizmo,scully,dragon1,devildog,triumph,eddie,bluebird,shotgun,peewee,hubris,ronnie,angel1,daisy,special,metallica,madman,country,impala,lennon,roscoe,omega,access14,enterpri,miranda,search,smitty,blizzard,unicorn,tight,rick,ronald,asdf1234,harrison,trigger,truck,danny,home,winnie,beauty,thailand,cadillac,castle,tyler,bobcat,buddy1,sunny,stones,asian,freddie,chuck,butt,loveyou,norton,hellfire,hotsex,indiana,short,panzer,lonewolf,trumpet,colors,blaster,12121212,fireball,logan,precious,aaron,elaine,jungle,masamune,atlanta,gold,corona,curtis,nikki,polaris,timber,theone,baller,chipper,orlando,island,skyline,dragons,dogs,benson,licker,goldie,engineer,kong,pencil,basketba,open,hornet,world,linda,barbie,chan,farmer,valentin,indians,larry,redman,foobar,travel,morpheus,bernie,target,141414,hotstuff,photos,laura,savage,holly,rocky1,dollar,turbo,design,newton,hottie,moon,blondes,4128,lestat,avatar,future,goforit,random,abgrtyu,jjjjjj,q1w2e3,smiley,goldberg,express,zipper,wrinkle1,stone,andy,babylon,dong,powers,consumer,dudley,Aster,monkey1,serenity,samurai,99999999,skeeter,lindsay,joejoe,master1,aaaaa,chocolat,christia,birthday,stephani,tang,alfred,ball,maria,sexual,maxima,sampson,buckeye,highland,kristin,seminole,reaper,bassman,nugget,lucifer,airforce,nasty,watson,warlock,2121,philip,always,dodge,chrissy,burger,bird,snatch,missy,pink,gang,maddie,holmes,huskers,piglet,photo,joanne,hamilton,dodger,paladin,christy,chubby,buckeyes,hamlet,abcdefgh,bigfoot,sunday,manson,goldfish,garden,deftones,icecream,blondie,spartan,julie,harold,charger,brandi,stormy,sherry,pleasure,juventus,rodney,galaxy,holland,escort,zxcvb,planet,jerome,wesley,blues,song,peace,david1,1966,cavalier,gambit,karen,sidney,ripper,jamie,sister,marie,martha,nylons,aardvark,nadine,minnie,whiskey,bing,plastic,anal,babylon5,chang,savannah,loser,racecar,insane,yankees1,mememe,hansolo,chiefs,fredfred,freak,frog,salmon,concrete,yvonne,sophia,stefan,8a1n80w,slick,rocker,opensesame,onessnap\".split(\",\")
	PASSWORDSC=\"123456789098765,012345678909876,abgDw32fhGu58k,Bd5gHie89YA,HG54h49lklj4G53,Bd5gHie89YA,59038qyghq340fg,tgby2hnr4fv9ujm,abcplm123098tg6,3dsvi2psdfn34,a03nf93nf8,3edv45gb8ub202n,afdiounwrnnfsa,234086531230324,111111111111111,222222222222222,333333333333333,444444444444444,55555555555555,666666666666666,777777777777777,888888888888888,999999999999999,000000000000000,efh368jhr08712,asdfghjkl102938,ghfjdkslatywoec,bogu2847mshd02,1357924680aoejd,g35gk5k63l10,d0emgh4m43la,ae51wc3g7d9c,GHEITHEKA102938,HHHHHHHHHHHHH,AAAAAAAAAAAAAAAA,RRRRRRRRRRRRRRRR,sssssssssssssss,ttttttttttttttt,llllllllllllll,eeeeeeeeeeeee,uuuuuuuuuuuu,oooooooooo,aaaaaaaa,1234,123,987,567,654,56432,12345,55555,99999,34567,jhgfd,uiopl,mnbvc,ytrewq,iuhhfd,sadregh,01010101010101,1010101010101010,000111000111000,einagearghaaer,235gdfa5yhgea,aletgadfgraerga,0k9j8h7g6f5f4ed2,afdsawe4togfido,butyrhdncbuh,39n8nf93fk59,adfsafawefgaag,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\".split(\",\")
	PASSWORDS = PASSWORDSA + PASSWORDSB
	if arg2 == \"-p\" then PASSWORDS = PASSWORDSC
	String={}
	String.capitalize=function(s)
	if s.len<2 then return s.upper
	return s[0].upper+s[1:].lower
	end function
	String.strip=function(t,s)
	if not t then return \"\"
	for b in range(0,t.len-1)
		if s.indexOf(t[b])==null then break
	end for
	if s.indexOf(t[b])>=0 then return \"\"
	for e in range(-1,-1*t.len)
		if s.indexOf(t[e])==null then break
	end for
	if e==-1 then return t[b:]
	return t[b:e+1]
	end function
	PasswordGenerator={}
	PasswordGenerator.init=function(samples)
	self.s=[]
	self.c={}
	for s in samples
		s=s.trim.upper
		if s.len>3 then self.s.push(s) // length limiter here
	end for
	if DEBUG then print \"pwgen: debug: self.s.len: \"+self.s.len
	for s in self.s
		for i in range(0,s.len-4)
		k=s[i:i+3] // limiter
		if self.c.hasIndex(k) then
			if self.c[k].indexOf(s[i+3])==null then self.c[k].push(s[i+3]) // limiter
		else
			self.c[k]=[s[i+3]] // limiter
		end if
		end for
		//wait(.1)
	end for
	end function
	PasswordGenerator.AllPasswords=function()
	r={}
	for s in self.s
		for i in range(0,s.len-4)
		self.r(s.len,s[i:i+3],r) // limiter
		//wait(.01)
		end for
	end for
		print(colorGold+\"50%\"+CT+\" -- loading hash_table...\")
		print(\"<align=center>\"+char(171)+char(187)+\"</align>\")
	o={}
	for s in r.indexes
		if s.indexOf(\" \")>=0 then
		n=s.split(\" \")
		i=n.indexOf(\"\")
		while i>=0
			n.remove(i)
			i=n.indexOf(\"\",i-1)
		end while
		if n then
			for i in range(0,n.len-1)
			n[i]=String.capitalize(n[i])
			end for
		end if
		s=n.join(\" \")
		else
		s=String.capitalize(s)
		end if
		if s.len<5 then continue
		a=s[0]
		b=s[1]
		if a.lower==b or \"hrl'aeiou\".indexOf(b)==null and \"AEIOUS\".indexOf(a)==null and [\"Ch\",\"Mc\"].indexOf(a+b)==null then s=String.capitalize(s[1:])
		s=String.strip(s,\"'-\")
		o[s]=1
		o[s.lower]=1
		//wait(.01)
	end for
	r={}
	print(colorGold+\"75%\"+CT+\" -- loading hash_table...\")
	print(\"<align=center>\"+char(171)+char(187)+\"</align>\")
	for p in o.indexes
		if p.len > 3 then 
			o[p[:4]] = 1
			o[String.capitalize( p[:4] ) ] = 1
			o[p[:3]] = 1
			o[String.capitalize( p[:3] ) ] = 1
		end if
		if p.len > 4 then
			o[p[-3:]] = 1
			o[String.capitalize( p[-3:] )] = 1
			o[p[-4:]] = 1
			o[String.capitalize( p[-4:] )] = 1
		end if
	end for
	for w in PASSWORDS
		o[w] = 1
	end for
	if arg1 == \"false\" then return o.indexes
	for i in o.indexes
		r[md5(i)]=i
	end for
	return r
	end function
	PasswordGenerator.r=function(l,s,o)
	c=s[s.len-3:]
	if self.c.hasIndex(c) and s.len<l then
		for c in self.c[c]
		self.r(l,s+c,o)
		//wait(.01)
		end for
	else
		o[s]=1
	end if
	end function
	if globals.BIGBRAIN then 
		if arg1 == \"false\" then
			return \"Dictionary already expaneded.\"
		end if
		print(colorGold+\"0% -- loading hash_table, please wait...\"+CT)
		HASH_TABLE = {}
		for pw in globals.dict_a
			HASH_TABLE[md5(pw)] = pw
			//wait(.01)
		end for
		print(colorGold+\"100%\"+CT+\" -- hash_table loaded...\")
	else
		print(colorGold+\"0% -- loading hash_table, please wait...\"+CT)
		if arg1 == \"-t\" or arg2 == \"-t\" then 
			PasswordGenerator.init(PASSWORDSC)	
		else 
			PasswordGenerator.init(PASSWORDS)
		end if
		//PasswordGenerator.init(globals.dict_a)
		//PasswordGenerator.init(globals.dict_a+PASSWORDS)
		//PasswordGenerator.init(PASSWORDS[0:arg2])
		//
		print(colorGold+\"10%\"+CT+\" -- loading hash_table...\")
		print(\"<align=center>\"+char(171)+char(187)+\"</align>\")
		HASH_TABLE=PasswordGenerator.AllPasswords
		print(colorGold+\"100%\"+CT+\" -- hash_table loaded...\")
		print(\"<b>Magnum Cerebrum: expanding onboard dictionary...</b>\")
		// globals.dict_a = HASH_TABLE.values
		if arg2 == \"-p\" then globals.dict_a(HASH_TABLE.values + PASSWORDSA + PASSWORDSB + PASSWORDSC) else globals.dict_a(HASH_TABLE.values+PASSWORDS)
		globals.BIGBRAIN = true
		if arg1 == \"false\" then
			return \"Dictionary expaneded.\"
		end if
	end if
	table = \"tp\"
	if arg1 == \"hash\" then table = \"t5\"
	table_path = HOME_SERVER[6].split(\"/tables/t5\")[0]
	//print(print(colorGold+\"Writing tables to <u>\"+home_dir+\"/tables/\"+table+CT))
	print colorGold+\"Writing tables to: \"+table_path+\"/tables/\"+table
	print(colorGold+\"Hash Table: [\"+colorWhite+HASH_TABLE.len+\"</color>]\")
	print(\"<align=center>\"+char(171)+char(187)+\"</align>\")
	out=[]
	count=0
	lol=1
	for i in HASH_TABLE
		count=count+1
		if arg1 == \"hash\" then
			//out=out+char(10)+i[\"key\"]+\"=\"+i[\"value\"]
			out.push(i[\"key\"]+\"=\"+i[\"value\"])
		else
			//out=out+char(10)+i[\"value\"]
			out.push(i[\"value\"])
		end if
		output = out.join(char(10))
		if output.len > 159900 then
			print(lol+\" \"+out.len+\" \"+output.len)
			//localmachine.touch(home_dir+\"/rkit/tables/\"+table,lol+\"\")
			//file=localmachine.File(home_dir+\"/rkit/tables/\"+table+\"/\"+lol)
			localmachine.touch(table_path+\"/tables/\"+table,lol+\"\")
			file=localmachine.File(table_path+\"/tables/\"+table+\"/\"+lol)
			file.set_content(output)
			command.perms(\"o-rwx\",file)
			out=[]
			lol=lol + 1
		end if
		//wait(.01)
	end for

	if out.len > 0 then
		lol = lol + 1
		print(lol+\" \"+HASH_TABLE.len+\" \"+out.len)
		localmachine.touch(table_path+\"/tables/\"+table,lol+\"\")
		file=localmachine.File(table_path+\"/tables/\"+table+\"/\"+lol)
		file.set_content(out.join(char(10)))
		command.perms(\"o-rwx\",file)
	end if

	return file.path
end function
command.brutus = function(arg1, arg2=0, arg3=0, arg4=0, arg5=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return colorGold+\"Brutus: dictionary attack psudo brute force type tool\"+char(10)+\"Usage: brutus -- attempt to gain root pass and shell using onboard dict_a \"+char(10)+\"(Default onboard dict_a: [\"+colorGold+globals.dict_a.len+CT+\"] passwords)\"+char(10)+\"-- on success sends <b>shell</b> to BUFFER and password to <b>clipa</b>\"+char(10)+\"Usage: brutus -i [/path|object] -- import dictionary (may be csv or newline separated values)\"+char(10)+\"-- 5hell will attempt to determine the type. Please ensure valid inputs.\"+char(10)+\"-- accepts: path to file or folder, or piped file/folder object\"+char(10)+\"-- See dfit for making a.csv from newline separated dictionary file.\"+char(10)+\"-- See cerebrum for altering onboard dict_a\"+char(10)+\"Advanced: brutus -s [shell_object] [ip] -- use shell_object to initiate ssh + brutus attack against ip \"+char(10)+\"(equal to command.ssh root@-brutus [ip] but uses the given shell instead of active shell)\"
	if globals.GLASSPOOL > 0 then print colorGold+\"brutus: warning: \"+colorLightBlue+\" GLASSPOOL</color> is active\"+char(10)+\"-- brutus does not translate through glasspool\"+char(10)+\"-- you <b>might</b> be rooting your own system\"
	dic = globals.dict_a
	u_name = \"root\"
	ip = \"\"
	port = 22
	b_remote = false
	if arg1 == \"-i\" and arg1.len == 2 then
	 	if arg2 and arg2 != \"0\" then
			if typeof(arg2) == \"string\" then
				dic = globals.get_file(arg2)
			else
				if typeof(arg2) == \"file\" then
					dic = arg2
				else
					return \"brutus: valid option -i [/path|file_object] -- import dictionary file\"
				end if
			end if
		else
			return \"brutus: valid option -i [/path|file_object] -- import dictionary file\"
		end if
	end if
	if DEBUG then print(\"arg1: \"+arg1+char(10)+\"arg2: \"+arg2+char(10)+dic)
	if not dic then return(\"Dictionary: \"+arg2+\" not found\")
	print(colorGold+\"Brutus: accessing dictionary...\"+CT)
	if arg1 == \"-s\" and arg2 and typeof(arg2) == \"shell\" then
		print(colorLightBlue+\"brutus: </b>Configuring remote attack...<b>\"+CT)
		if arg3 and arg4 then
			if arg5 then port = arg5
			if typeof(port) != \"number\" then port = port.to_int
			if typeof(port) != \"number\" then return colorRed+\"brutus: invalid port\"+CT
			ip = arg4
			u_name = arg3
		else
			if arg3 then u_name = arg3
			ip = user_input(\"root@ip: \")
		end if
		if is_valid_ip(ip) then
			print(\"<b>brutus: remote attack configured.</b>\")
			stop = user_input(colorRed+\"WARNING:\"+colorOrange+\"Continuing will fill the terminal with [\"+colorGold+globals.dict_a.len+colorOrange+\"] connection attempts.\"+char(10)+\" This cannot be avoided. Continue? [Y/n] \"+CT)
			if stop == \"n\" or stop == \"N\" then return \"aborting...\"
			b_remote = true
		else
			return colorRed+\"Brutus: invalid ip.\"+CT
		end if
	end if
	if typeof(dic) == \"file\" then
	 	if not dic.is_binary then
			d_buf = dic.get_content
			if d_buf.indexOf(\",\") > 0 then
				dic = d_buf.trim.split(\",\")
			else
				dic = d_buf.split(char(10))
			end if
		else
			if dic.is_folder then
				df = dic.get_folders
				box = []
				for f in df
					f_buf = f.get_content
					if f_buf.indexOf(\",\") > 0 then
						dic_buf = f_buf.trim.split(\",\")
					else
						dic_buf = f_buf.split(char(10))
					end if
					for d in dic_buf
						box.push(d)
					end for
					//wait(.1)
				end for
				dic = box[0:]
			else
				return \"brutus: invalid dictionary input.\"+char(10)+\"got: binary_file. expected: folder or ascii file.\"
			end if
		end if
	end if
	if typeof(dic) != \"list\" then return \"brutus: dictionary error.\"
	if DEBUG then print(\"d_len: \"+dic.len)
	for d in dic
		if b_remote then
			root = shell.connect_service(ip, port, u_name, d)
		else
			root = get_shell(\"root\", d)
		end if
		if typeof(root) == \"shell\" then
			print(\"root:\"+colorGold+\"\"+d+\"\"+CT)
			print(\"clipa: \"+command.clipa(d))
			gotcha = root.host_computer.public_ip+\":\"+root.host_computer.local_ip
			print \"brutus: \"+colorGreen+\"saving root password as index in custom object. access via <b>cob</b> command\"
			if DEBUG then print(\"brutus: debug: calling cob: adding \"+gotcha+\" to index <b>\"+d)
			print command.cob(\"set\",d,gotcha)
			globals.BUFFER.push(root)
			print(\"<b>Shell sent to \"+colorOrange+\"BUFFER</color>.\"+char(10)+\"-- access via Memory Alpha (<u>malp</u> command)</b>\")
			return root
		end if
	end for
	print(\"...brute force attack failed.\")
	return 0
end function
command.cerebrum = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return colorGold+\"<u>Magnum Cerebrum || Big Brain || dictionary || word list || rockme</u>\"+CT+char(10)+\"Usage: cerebrum -- Expand dict_a to 300k+ passwords and store in custom_object.dictionary\"+char(10)+\"-- Use <b>pwgen</b> instead to save passwords locally to file.\"+char(10)+\"<b>Advanced: cerebrum -i [/path/to/file|file_object|list] -- import a custom dictionary\"+char(10)+\"-- file may be csv or nsv: ',' or char(10) \"+char(10)+\"-- may be file, directory, piped object, or list\"+char(10)+\"Usage: <b>cerebrum --purge</b> -- purge the onboard dictionary (to save memory).\"+char(10)+\"Advanced: cerebrum -p -- load only common player passwords (wip)\"+char(10)+\"Advanced: cerebrum -i @home -- import dictionary file or folder from @home server\"+char(10)+\"-- searches /root/tables/tp on @home server\"+char(10)+\"-- see help @home for more information about the @home server.\"+char(10+\"Advanced: -- passing -d as any argument returns the onboard dictionary as a list\"+char(10)+\"---- importing a string of passwords directly is not supported, use brutus for that.\"+char(10)+\"Note: cerebrum will autodetect /root/tables and offer to import it if present\")
	if arg1 == \"-i\" and not arg2 then return \"cerebrum: -i expects /path or file_object or @home.\"
	infile = null
	if arg1 == \"--purge\" then 
		globals.dict_a([\"a\"])
		globals.BIGBRAIN = false
		return \"cerebrum: dictionary purged.\"
	end if
	if arg1 == \"-i\"then
		if not arg2 then return \"crebrum: -i expects a path or file object or list.\"
		if typeof(arg2) == \"list\" then
			globals.dict_a(arg2)
			if dict_a.len > 0 then return \"cerebrum: [\"+colorGold+globals.dict_a.len+CT+\"] passwords ready. \" else return \"cerebrum: import error. dictionary corrupted.\"
		end if
		if typeof(arg2) == \"string\" then
			if is_valid_ip(arg2) then
				r_ip = arg2
				r_p = HOME_SERVER[1]
				// if params and params.len > 1 then
				// 	r_ip = params[0]
				// 	r_p = params[1].to_int
				// else
				// 	r_ip = targ.ip
				// 	r_p = targ.pt
				// end if
				//if not is_valid_ip(r_ip) then return \"cerebrum: set remote ip and port with command.target [ip] [port] before using -i @home option.\"
				r_pas = \"\"
				//if params and params.len > 2 then
					//r_pas = params[2]
				//else
				if HOME_SERVER[3] == \"password\" then r_pas = user_input(\"@home_server_password (leave blank to abort)\"+char(10)+\":> \", 1) else r_pas = HOME_SERVER[3]
				//end if
				if r_pas.trim == \"\" then return(\"aborting...\")
				r_r = shell.connect_service(r_ip, r_p, HOME_SERVER[1], r_pas)
				if r_r and typeof(r_r) == \"shell\" then
					infile = r_r.host_computer.File(globals.HOME_SERVER[6])
					if not infile then return (colorRed+\"cerebrum: /root/rkit/tables/tp not found\"+\"cerebrum: home_dir/rkit/tables/tp not found\"+char(10)+\"-- run pwgen to create the tables\"+CT)
				else
					return (colorRed+\"cerebrum: remote server unreachable.\"+CT)
				end if
			else
				infile = globals.get_file(arg2)
				if DEBUG then print \"infile: \"+infile.path
			end if
		else
			if typeof(arg2) == \"file\" then
				infile = arg2
			else
				return \"cerebrum: invalid type. expects /path or file_object or @home.\"
			end if
		end if
		print(colorGold+\"<size=75%>cerebrum: importing dictionary...\"+char(10)+colorGold+\"<align=center><size=75%><<>></align>\"+CT)
		if infile and not infile.is_binary then
			d_b = infile.get_content
			globals.dict_a([])
			if d_b.indexOf(\",\") > 0 then
				globals.dict_a(globals.dict_a + d_b.split(\",\"))
			else
				globals.dict_a(globals.dict_a + d_b.split(char(10)))
			end if
		else
			if infile and infile.is_folder then
				globals.dict_a([])
				for dfile in infile.get_files
					if dfile.has_permission(\"r\") and not dfile.is_binary then
						d_b = dfile.get_content
						if DEBUG then print \"d_b input size: \"+d_b.len
						delim = \"\"
						if d_b.indexOf(\",\") > 0 then
							//globals.dict_a = globals.dict_a + dfile.get_content.split(\",\")
							delim = \",\"
						else
							//globals.dict_a = globals.dict_a + dfile.get_content.split(char(10))
							delim = char(10)
						end if
						if globals.dict_a.len < 710000 then 
							d_b = d_b.split(delim)
							globals.dict_a(globals.dict_a + d_b)	
							if DEBUG then print(\"dict_a: \"+dict_a.len)
						else 
							print(\"cerebrum: max dictionary length reached. Could not load: \"+dfile.path)
						end if
					end if
				end for
			else
				return \"cerebrum: import error [411].\"
			end if
		end if
		if dict_a.len > 0 then 
			globals.BIGBRAIN = true
			return \"cerebrum: [\"+colorGold+dict_a.len+CT+\"] passwords ready. \" 
		else 
			return \"cerebrum: import error. dictionary corrupted.\"
		end if
	end if
	if globals.BIGBRAIN then return \"Magnum Cerebrum already active.\"+char(10)+\"Run the command: <b>cerebrum --purge</b> to reset.\"
	print(colorGold+\"<align=center> Magnum Cerebrum </align>\"+CT)
	print(colorGold+\"- - - - - - - - - - - - - - - - - - - - - - - - - -\"+CT)
	//globals.BIGBRAIN = true
	time_s = time
	if DEBUG then print(\"DEBUG: TIME: \"+time_s)
	tab = get_shell.host_computer.File(\"/root/tables/tp\")
	if tab and tab.has_permission(\"r\") then 
		print(\"Detected /root/tables/tp. Auto-import passwords?\")
		autoimport = user_input(\"[Y/n] (q=quit)||: \",0,1)
		if autoimport.lower == \"q\" then return
		if autoimport.lower != \"n\" then 
			print(\"Calling \"+colorWhite+\"<u>cerebrum -i /root/tables/tp</u>\")
			print command.cerebrum(\"-i\",\"/root/tables/tp\")
			return globals.dict_a.len+\" passwords imported in \"+str(time-time_s)+\" seconds.\"
		end if
		print \"cerebrum: bypassin tables...\"
	end if
	print colorGold+\"</b>cerebrum: working...\"
	if DEBUG then print(\"cerebrum calling: pwgen false \"+arg1)
	command.pwgen(\"false\",arg1)
	time_e = (time - time_s)
	print( globals.dict_a.len+\" passwords readied in \"+time_e+\" seconds.\" )
	if arg1 == \"-d\" or arg2 == \"-d\" or arg3 == \"-d\" then return dict_a else return 0
end function
if DEBUG then print(\"<size=75%>loading jtr.5pk...(3.397kb)</size>\")
command.jtr = function(arg1,arg2,arg3,arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" or not arg3 then return \"John The Ripper password generator\"+char(10)+\"Usage: jtr [set_size] [word_length(1-15)] [opt:aAns] [opt:1]\" + char(10) + \"a - lowercase alpha\" +char(10)+ \"A - uppercase alpha\"+char(10)+\"n - numbers\"+char(10)+\"s - special characters\"+char(10)+\"note: at least ONE option must be selected\"+char(10)+\"1 -- optional only first letter is upper case (any value here is considered 1/true), leave blank for false.\"
	if arg1.to_int <= 0 then return \"size error: greater than zero expected\"
	if arg2.to_int <= 0 or arg2.to_int > 15 then return \"length error: expected between 1 and 15\"

	array = []
	alpha_l = range(\"a\".code,\"z\".code)
	i = 0
	for c in alpha_l
		alpha_l[i] = char(c)
		i = i + 1
	end for
	alpha_u = range(\"A\".code,\"Z\".code)
	i = 0
	for c in alpha_u
		alpha_u[i] = char(c)
		i = i + 1
	end for
	numbers = range(0,9)
	special = [\"!\",\"@\",\"#\",\"$\",\"%\",\"^\",\"&\",\"*\",\"(\",\")\",\"-\",\"+\",\"=\",\"}\",\"{\",\"[\",\"]\",\";\",\":\",\"<\",\">\",\",\",\".\",\"'\",\"\"\"\"]

	SET_SIZE = arg1.to_int // generate 1000 words 
	SET_RANGE = arg2.to_int // string of length 15
	PARAMS = [0,0,0,0] // use alpha_l, use alpha_u, use numbers, use special
	if arg3.indexOf(\"a\") >= 0 then PARAMS[0] = 1
	if arg3.indexOf(\"A\") >= 0 then PARAMS[1] = 1
	if arg3.indexOf(\"n\") >= 0 then PARAMS[2] = 1
	if arg3.indexOf(\"s\") >= 0 then PARAMS[3] = 1
	if PARAMS.indexOf(1) == null then return \"option error: must select a, A, n, and/or s\"

	first_cap = 0
	if arg4 then first_cap = 1
	//print(\"arg4 is \"+arg4+\" and first_cap is \"+ first_cap)
	output = []
	dupe_count = 0
	time_out_limit = \"1000000\"

	line = []
	if PARAMS[0] then line = line + alpha_l
	if PARAMS[1] then line = line + alpha_u
	if PARAMS[2] then line = line + numbers
	if PARAMS[3] then line = line + special
	//print(line)
	if typeof(line) != \"list\" then return \"PARAMS error\"
	
	print(\"<b>Generating wordlist...</b>\")
	loops = SET_SIZE
	s1 = 10
	s5 = 50
	s7 = 75
	while loops
		i = 0
		array = range( 0 , SET_RANGE - 1 )
		while i < SET_RANGE
			line.shuffle
			if first_cap == true then 
				if i == 0 then  
					array[i] = line[0].upper
				else
					array[i] = line[0].lower
				end if
			else 
				array[i] = line[0]
			end if
			i = i + 1
			//wait(.01)
		end while
		if output.indexOf(array.join(\"\")) == null then // ouput
			output.push(array.join(\"\"))
			//loops = loops - 1
		else 
			array.shuffle
			if output.indexOf(array.join(\"\")) == null then 
				output.push(array.join(\"\"))
			else 
				dupe_count = dupe_count + 1
				if dupe_count == time_out_limit.to_int then 
					print \"jtr: timeout limit reached: too many duplicates\"+char(10)+\"-- we managed to make: \"+output.len+\" passwords\"
					return output.join(char(10))
				end if
			end if
		end if
		loops = loops - 1
		if DEBUG then print colorOrange+\"output length: \"+output.len
		if SET_SIZE / loops == 10 then 
			print(colorGold+\"loading...\"+(s1)+\"% complete\")
			s1 = s1 + 1 
		end if
		if SET_SIZE / loops == 4 then 
			print(colorGold+\"loading... \"+(s7)+\"% complete\")
			s7 = s7 + 1
		end if
		if SET_SIZE / loops == 2 then 
			print(colorGold+\"loading... \"+(s5)+\"% complete\")
			s5 = s5 + 5
		end if
		//wait(.01)
	end while
	return output.join(char(10)) // max string size is 1 million chars
end function
command.string = function(arg1,arg2,arg3,arg4)
	if arg1 == null or arg1 == \"help\" or arg1 == \"-h\" then return \"String | To String | List | Join | replace\"+char(10)+
	colorGreen+\"String and List functions (more to be added over time).\"+char(10)+
	\"-- I didn't want to make a string command AND a list command so both are here.\"+char(10)+
	colorWhite+\"Lists: Stringifying lists:\"+char(10)+
	colorCyan+\"Usage: string [opt] [list] -- converts a list to a string and returns it\"+char(10)+
	\"-- use the clipboards and @a|@b|@c or piping to supply the list\"+char(10)+
	colorCyan+\"Usage: string [lista] [listb] -- will return lista concatenated with listb\"+char(10)+
	\"-- returns a <b>LIST</b>\"+char(10)+
	\"-- pipe the resulting list back into string to stringify\"+char(10)+
	\"-- e.g.: <b>string @a @b | string -n | poke new.txt</b>\"+char(10)+
	\"-- I justify this as 'stringing two lists together' \"+char(10)+char(10)+
	\"Option: -n -- join list with <color=red>char(10)\"+char(10)+
	\"Option: -c -- join list with <color=blue>commas\"+char(10)+
	\"Option: -C -- join list with <color=green>colons\"+char(10)+
	\"Option: -s -- join list with <color=yellow>semicolons\"+char(10)+
	\"Option: -S -- join list with <color=white>spaces\"+char(10)+
	\"Note: the default join delimiter is char(10)\"+char(10)+
	\"-- i.e: <b>string [list]</b> is the same as <b>string [-n] [list]\"+char(10)+char(10)+
	colorWhite+\"Strings: Stringify strings:\"+char(10)+
	colorCyan+\"Usage: string [-t] [target_text] -- returns trimmed text\"+char(10)+
	\"-- ie: it removes whitespace\"+char(10)+
	colorCyan+\"Usage: string [-p] [target_text] -- strip the noparse richtext tag from a string and return it\"+char(10)+
	colorCyan+\"Usage: string [-N] [target_text] -- return string with the noparse tag prepended to each line\"+char(10)+
	colorCyan+\"Usage: string [-r] [target_text] [replacement_text] [string_to_parse]\"+char(10)+
	\"-- replace all instances of target_text with replacement_text within string_to_parse\"+char(10)+
	\"-- use piping, easy clip, and \"\" text blocks \"\" to supply strings\"+char(10)+
	\"-- use @0 alone in order to indicate a zero space character; aka remove\"+char(10)+
	\"-- use @32 in order to indicate a space (char(32))\"+char(10)+
	\"-- use @10 to indicate a newline (char(10))\"+char(10)+
	\"-- use @[int] to specify any other character code\"+char(10)+
	\"-- uses miniscript regex, you must escape <b>.</b> with <b>\\.</b>\"+char(10)+
	\"-- uses miniscript regex; you can ignore the above and use regex instead\"+char(10)+
	\"-- all params should be strings and the function returns the modified string\"+char(10)+
	//colorCyan+\"Usage: string [-R] -- as above but allows the use of miniscript supported regex\"+char(10)+
	colorCyan+\"Usage: string [-R] [text_to_remove] [string_to_parse] -- returns string with text removed\"+char(10)+
	\"-- uses regex, you must escape <b>.</b> with <b>\\.</b>\"+char(10)+
	colorWhite+\"Numbers: Stringify numbers\"+char(10)+
	colorCyan+\"Usage: string [number] -- returns str(number) as a string\"+char(10)+
	\"-- please note that numbers are passed as numbers, not strings, when piped\"+char(10)+
	colorWhite+\"Numberify strings:\"+char(10)+
	colorCyan+\"Usage: string [-i] [string] -- converts a string to an integer and returns an integer\"+char(10)+
	\"--eg:<b> string -i 100\"+char(10)+
	colorCyan+\"Usage: string [-v] [string] -- converts a string to a floating point value and returns it\"+char(10)+
	\"--eg:<b> string -v 3.12159\"+char(10)+
	colorWhite+\"Listify strings\"+char(10)+
	colorCyan+\"Usage: string [-l] [delim] [string] -- turn a string split at [delim] into a list\"+char(10)+
	\"-- use floating quotes or piping to supply complex input strings\"+char(10)+
	\"--eg:<b> string -l , one,two,three\"+char(10)+
	\"--eg:<b> string -l , \"\" one, two, three, four \"\" \"+char(10)+
	colorCyan+\"Usage: string [-L] [delim] [string] -- as above but applys .to_int to each element\"+char(10)+
	\"-- ie: returns a list of integers\"+char(10)+
	\"--eg:<b> string -L , 1,2,3,4\"+char(10)+
	\"Note: maps are not yet supported\"

	_handle_replacement = function( target, replacement, in_string )
		if DEBUG then print \"debug: t: \"+target+\" r: \"+replacement+\" is: \"+in_string
		if not in_string isa string or not target isa string or not replacement isa string then return \"replace: -r expects strings\"
		if replacement.values[0] == \"@\" then 
			rvs = replacement.split(\"@\")[1].to_int
			if typeof(rvs) == \"number\" then 
				if rvs > 0 then replacement = char(rvs) else replacement = \"\"
			end if
		end if
		if target.values[0] == \"@\" then 
			tvs = target.split(\"@\")[1].to_int
			if typeof(tvs) == \"number\" then 
				if tvs > 0 then target = char(tvs) else target = \"\"
			end if
		end if
		//if use_regex == true then return in_string.replace_regex( target, replacement )
		out_string = in_string.replace( target, replacement )	// miniscript .replace uses miniscript regex
		return out_string
	end function
	_to_int = function( in_string )
		if typeof(in_string) != \"string\" then return \"string: expected string, got \"+typeof(in_string)
		return in_string.to_int
	end function 
	_to_val = function( in_string )
		if typeof(in_string) != \"string\" then return \"string: expected string, got \"+typeof(in_string)
		return in_string.val 
	end function
	_to_list = function( delim, in_string )
		if not delim or typeof(delim) != \"string\" then return \"string: delimiter must be a string\"
		if not in_string or typeof(in_string) != \"string\" then return \"string: input string not supplied\"
		return in_string.split(delim)
	end function
	_to_int_list = function( delim, in_string )
		if not delim or typeof(delim) != \"string\" then return \"string: delimiter must be a string\"
		if not in_string or typeof(in_string) != \"string\" then return \"string: input string not supplied\"
		s_a = in_string.split(delim)
		s_b = []
		for s in s_a 
			s_b.push(s.to_int)
		end for
		return s_b
	end function
	_trim_input = function( instring )
		if typeof( instring ) != \"string\" then return \"string: expects [-t] [string_input]\"
		sp_str = instring.split(char(10))
		output = []
		for line in sp_str 
			output.push(line.trim)
		end for
		return output.join(char(10)).trim
	end function
	_no_parse_input = function( instring )
		if typeof( instring ) != \"string\" then return \"string: expects [-N] [string_input]\"
		sp_str = instring.split(char(10))
		output = []
		for line in sp_str 
			output.push(\"<noparse>\"+line)
		end for
		return output.join(char(10)).trim
	end function
	_strip_input = function( instring )
		if typeof( instring ) != \"string\" then return \"string: expects [-p] [string_input]\"
		sp_str = instring.split(char(10))
		output = []
		for line in sp_str 
			output.push(line.replace(\"<noparse>\",\"\"))
		end for
		return output.join(char(10)).trim
	end function

	delim = null
	in_list = null
	if typeof(arg1) == \"number\" then return str(arg1)
	if typeof(arg1) == \"list\" and typeof(arg2) == \"list\" then 
		print colorLightBlue+\"Returning concatenated list...\"
		return arg1 + arg2
	end if
	if typeof(arg1) == \"list\" then in_list = arg1  
	use_regex = false 
	// if arg1 == \"-R\" then
	// 	use_regex = true 
	// 	arg1 = \"-r\"
	// end if
	if typeof(arg1) == \"string\" then 
		if arg1 == \"-N\" then return _no_parse_input(arg2)
		if arg1 == \"-p\" then return _strip_input(arg2)
		if arg1 == \"-t\" then return _trim_input(arg2)
		if arg1 == \"-L\" then return _to_int_list(arg2,arg3)
		if arg1 == \"-l\" then return _to_list(arg2,arg3)
		if arg1 == \"-i\" then return _to_int(arg2)
		if arg1 == \"-v\" then return _to_val(arg2)
		if arg1 == \"-r\" then return _handle_replacement(arg2,arg3,arg4)
		if arg1 == \"-R\" then return _handle_replacement(arg2,\"\",arg3)
		if arg1 == \"-n\" then delim = char(10) // \"/n\"
		if arg1 == \"-c\" then delim = char(44) // \",\"
		if arg1 == \"-C\" then delim = char(58)   // \":\"
		if arg1 == \"-s\" then delim = char(59)   // \";\"
		if arg1 == \"-S\" then delim = \" \"   // i forgot the char code for spaces \" \"
		if arg2 and typeof(arg2) == \"list\" then in_list = arg2 else return \"string: 2nd param after flag should be a list\" 
		if not delim then return \"string: invalid option. check usage.\"
	end if
	if not in_list then return \"string: expects list\"
	if not delim then delim = char(10)
	return in_list.join(delim)
end function
command.diff = function(input_1,input_2,arg3,arg4)

    // the diff function
    _diff = function(block_1, block_2,ret_type=\"string\")
		print colorRed+\"--diff--\"
        if typeof(block_1) != \"string\" or typeof(block_2) != \"string\" then return \"error: expected string string, got: \"+typeof(block_1)+\" and \"+typeof(block_2)
        diff_list = []
		print_buffer = []
        i = 0
        j = 0
        lines1 = block_1.split(char(10))
        lines2 = block_2.split(char(10))
		leng1 = lines1.len 
        leng2 = lines2.len 
		if DEBUG then print \"debug: len_1_1: \"+lines1.len+\" len_2_2: \"+lines2.len
        while i < leng1 or j < leng2 
            if i < leng1 and j < leng2 then 
				if DEBUG then print \"debug: diff: top of loop\"
                if lines1[i] == lines2[j] then 

                    print_buffer.push((i+1)+\"<color=#00ff88ff>\"+char(177)+(j+1)+\" \"+lines1[i])
					i = i + 1
					j = j + 1
                else 
					print_buffer.push(colorRed+(i+1)+CT+\"<color=#D9FF00ff>- \"+lines1[i])
                    print_buffer.push(colorRed+(j+1)+CT+\"<color=#fc7324ff>+ \"+lines2[j])
					diff_list.push(i+1)
					j = j + 1
					if j < lines2.len then 
						if lines1[i] != lines2[j] then i = i + 1 // this is a hack for compatibility with zero day stuff, make it better
					else 
						i = i + 1
						if DEBUG then print \"processed line \"+ i
					end if            		
                end if  
            else 
                if i < leng1 then 
					if DEBUG then print \"file_1 is longer by \"+ (i-j)
                    print_buffer.push(\"<color=#D9FF00ff>\"+(i+1)+\"- \"+lines1[i])
					if lines1[i] != \"\" then diff_list.push(i+1)
                else 
                    if j < leng2 then 
						if DEBUG then print \"file_2 is longer by \"+(j-i)
                        print_buffer.push(\"<color=#fc7324ff>\"+(j+1)+\"+ \"+lines2[j])
						if lines2[j] != \"\" then diff_list.push(j+1)
                    end if
               end if
				i = i + 1
            	j = j + 1
            end if
			if DEBUG then print \"debug: diff: bottom of loop\"
        end while
        if ret_type == \"string\" then 
			return print_buffer.join(char(10))
		else 
			print print_buffer.join(char(10))
			return diff_list
		end if
    end function
/////////////////////////////////////////START HERE///////////////////////////////////////////////////
	// preprocess input
	return_type = \"string\"
	if input_1 == \"-l\" then 
		return_type = \"list\"
		input_1 = input_2 
		input_2 = arg3 
		arg3 = arg4
	end if
    // usage info
	if not input_1 or not input_2 then return \"Usage: diff [opt] [input_1] [input_2]\"
    if input_1 == \"-h\" or input_1 == \"help\" then return \"<u><b>DIFF || DIFFERENCES || FILE COMPARE || TEXT COMPARE\"+char(10)+char(10)+
    \"Usage: diff [input_1] [input_2] -- standard diff tool\"+char(10)+
    \"Usage: diff [file_1_path|file_1_object|text_block_1] [file_2_path|file_2_object|text_block_2]\"+char(10)+
    \"-- compares <b>text</b> of input_1 to input_2 and prints output\"+char(10)+
    \"-- prints differences when encountered\"+char(10)+
    \"-- input_1 text is prepended with the <b>-</b> character\"+char(10)+
    \"-- input_2 text is prepended with the <b>+</b> character\"+char(10)+char(10)+
    \"Input notes:\"+char(10)+
    \":: if input_1 or input_2 are single words they are processed as <b>paths to a file\"+char(10)+
    \":: if input_2 or input_2 are more than one word (ie piped text) they are processed as strings\"+char(10)+
    \":: does not process binary files or lists\"+char(10)+
	\":: -- for lists pipe the output of <b>string [yourlist]\"+char(10)+char(10)+
	\"Advanced: diff [-l] [input1] [input2] -- returns a list of ints corresponding to line numbers with differences\"+char(10)+
	\"-- useful for <b>unit_testing</b> a debugLibrary\"
    // postprocess input
    if typeof(input_1) == \"string\" then 
        if input_1.split(\" \").len == 1 then input_1 = globals.get_file(input_1)
        if not input_1 then return \"diff: \"+input_1+\" not found\"
    end if
    if typeof(input_2) == \"string\" then 
        if input_2.split(\" \").len == 1 then input_2 = globals.get_file(input_2)
        if not input_2 then return \"diff: \"+input_2+\" not found\"
    end if 
    if typeof(input_1) == \"file\" then 
        if input_1.is_binary then return \"diff: unable to open binary file: \"+input_1.path
        if not input_1.has_permission(\"r\") then return \"diff: unable to read \"+input_1.path
        input_1 = input_1.get_content
    end if
    if typeof(input_2) == \"file\" then 
        if input_2.is_binary then return \"diff: unable to open binary file: \"+input_2.path        
        if not input_2.has_permission(\"r\") then return \"diff: unable to read \"+input_2.path
        input_2 = input_2.get_content
    end if
	if DEBUG then print \"debug: top of diff\"
	if DEBUG then print \"debug: input_1: \"+input_1
	if DEBUG then print \"<b>debug: input_1 leng: \"+input_1.len
	if DEBUG then print \"debug: input_2: \"+input_2 
	if DEBUG then print \"<b>debug: input_2 leng: \"+input_2.len
    return _diff(input_1,input_2,return_type)
end function
command[\"if\"] = function(arg1,arg2,arg3,arg4)
	if @arg1 == \"help\" or @arg1 == \"-h\" then return \"IF || if statement || conditionals\"+char(10)+
	\"Usage: if [positive_return] [negative_return] [condition_1] [condition_2] -- a binary if statement\"+char(10)+
	\"-- compares condition_1 to condition_2\"+char(10)+
	\"-- returns positive_return if equal\"+char(10)+
	\"-- returns negative_return if not-equal\"+char(10)+
	\"-- conditions and returns may be any data type\"+char(10)+
	\"NOTE: functions as returns are returned by function reference\"+char(10)+
	\"-- pipe to code for execution\"+char(10)+
	\"-- functions as conditions are executed in place\"+char(10)+
	\"---- it is not (currently) possible to pass parameters to these functions\"+char(10)+
	\"NOTE: any parameter may be a command, with parameters, if:\"+char(10)+
	\"-- the first word of the string is a command name\"+char(10)+
	\"-- the string itself is surrounded by floating single quotes\"+char(10)+
	\"--eg: <b>file -r /etc | clipa |  | if \"\" echo true \"\" \"\" echo false \"\" @a \"\" grep -f etc  \"\" \"+char(10)+
	\"-- which would result in <b>true</b> printing to the screen (provided etc actually existed)\"

	s = @command[\"shell\"]
	res = 0
	if @arg3 and typeof(@arg3) == \"string\" and globals.command.hasIndex(arg3.split(char(32))[0]) then arg3 = s(arg3+\" | return\",1)
	if @arg4 and typeof(@arg4) == \"string\" and globals.command.hasIndex(arg4.split(char(32))[0]) then arg4 = s(arg4+\" | return\",1)
	print colorCyan+\"<u>= = = evaluating = = =</u>\"+char(10)+\"<size=75%>\"+colorCyan+\"Result:\"

	if DEBUG then print \"debug:_\"+char(10)+@arg1+char(10)+@arg2+char(10)+@arg3+char(10)+@arg4

	if arg3 == arg4 then
		if @arg1 and typeof(@arg1) == \"string\" and globals.command.hasIndex(arg1.split(char(32))[0]) then res = s(arg1+\" | return\",1)
	else 
		if @arg2 and typeof(@arg2) == \"string\" and globals.command.hasIndex(arg2.split(char(32))[0]) then res = s(arg2+\" | return\",1)
	end if
	if @res isa string then return res.trim else return @res
end function
command.sl = function(arg1,arg2,arg3,arg4)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"Symlink || symbolic link || file path\"+char(10)+
	\"Usage: sl [path] -- returns true if path is a symlink, returns false otherwise\"+char(10)+
	\"Usage: sl [path] [/new_path/new_name] -- create a symbolic link at path\"+char(10)+
	\"-- returns 1 on success, string on fail\"+char(10)
	if typeof(arg1) == \"file\" then arg1 = arg1.path
	if typeof(arg1) != \"string\" then return \"sl: invalid path\"
	source_file = globals.get_file(arg1)
	if not source_file then return \"sl: source file not found\"
	if not arg2 then 
		print colorCyan+\"sl:\"+colorLightBlue+\" checking for symlink...\"
		if source_file.is_symlink then return \"true\" else return \"false\" 
	end if
	sym_name = null
	sym_parent_path = null 
	first = globals.get_file(arg2)
	if first then 
		if first.is_symlink then 
			print \"sl: destination symlink exists; overwriting\"
			sym_name = first.name 
			sym_parent_path = first.parent.path 
		else 
			print \"sl: destination exists and is not a symlink;\"+char(10)+\"-- aborting...\"
			return 0
		end if
	else
		sym_path = arg2.split(\"/\")
		sym_name = sym_path.pop
		if sym_path.len < 1 then sym_path = sym_path + currentPath.split(\"/\")
		sym_path = sym_path.join(\"/\")
		second = globals.get_file(sym_path)
		if second and second.is_folder then sym_parent_path = second.path else return \"sl: [original_file] [/parent_path/new_name]\"
	end if
	print colorLightBlue+\"<u>sl: \"+colorCyan+\"creating symlink:</b> \"+source_file.path+\" ~> \"+sym_parent_path+\"/\"+sym_name
	return source_file.symlink(sym_parent_path, sym_name)
end function
command.zc = function(neurobox_user,neurobox_pass,metalib,patch_it=0)
    if neurobox_user == \"h\" or neurobox_user == \"help\" then return \"Zer0Chill || Zeroday || zero day || autopatcher || autosolver\"+char(10)+
	colorWhite+\"Usage: zc [neurobox_username] [neurobox_password] [opt:metaLib_name|metaLib_object]\"+char(10)+
	\"-- if a MetaLib is not supplied, zc will use the currently linked MetaLib\"+char(10)+
	\"---- or return an error if one is not linked\"+char(10)+
	\"-- zc will: obtain debugLibrary from a MetaLib\"+char(10)+
	\"---- scan the debugLibrary and parse the output\"+char(10)+
	\"---- construct a patched version of the output\"+char(10)+
	\"---- write the original and patched versions to:\"+char(10)+
	\"------ <b>orig</b> and <b>patch.zd</b>, respectively\"+char(10)+
	\"---- BUFFER all of the above\"+char(10)+
	\"NOTE: at this time lib patching is not automated\"+char(10)+
	\"NOTE: at this time unit-testing is not automated\"+char(10)+
	\"----: this is because both of these actions may result in a lock-out\"+char(10)+
	\"----: please analyze the output and unit-test and patch carefully\"+char(10)+
	colorWhite+\"- - - - - - - - -\"+char(10)+
	colorLightBlue+\"DebugLibary Unit Testing:\"+char(10)+
	\"Procedure: once <b>zc</b> has been run:\"+char(10)+
	\"-- run the command:<b> diff -l orig patch.zd | clipa | malp\"+char(10)+
	\"-- select the debugLibrary from the BUFFER\"+char(10)+
	\"-- select option [2] - unit_testing\"+char(10)+
	\"-- input <b>@a</b> to use the list stored in clipa\"+char(10)+
	\"-- if successful, output string will be BUFFERED\"+char(10)+
	\"-- select the output text from the BUFFER\"+char(10)+
	\"-- select [s] - save and enter a filename for the zeroday data\"+char(10)+
	colorLightBlue+\"MetaLib Patching:\"+char(10)+
	\"Procedure: once <b>zc</b> and unit_testing are complete:\"+char(10)+
	\"-- select the debugLibrary from the BUFFER \"+char(10)+
	\"-- select patch and enter the path to patch.zd\"+char(10)+
	\"-- you may also use the <b>code</b> command: \"+char(10)+
	\"--eg: <b>code @B [#]</b> -- where # is the index of the debugLibrary in the BUFFER\"
    if not neurobox_user or not neurobox_pass then return \"zer0Chill: invalid parameters: expects [user] [pass] [metaLib]\"
    if typeof(metalib) != \"MetaLib\" then 
        if typeof(metalib) == \"string\" then 
            if not globals.metaxploit then return \"zer0Chill: metaxploit is required in order to load from path\"
			print command.meta(metalib)        
            metalib = command.bios(\"-m\")
            if typeof(metalib) != \"MetaLib\" then return \"zer0Chill: error: that wasn't a MetaLib!\" else globals.BUFFER.push(metalib)
        else 
			if not metalib then 
				if globals.metaLib then 
					metalib = globals.metaLib
					globals.BUFFER.push(metalib)
				else 
					return \"zer0Chill: please supply or link a metaLib name or object\"
				end if
			else 
				return \"zer0chill: please supply or link a metaLib name or metaLib object\"
			end if
        end if
    else 
        command.meta(metalib)    
        globals.BUFFER.push(command.bios(\"-m\"))
    end if
    handle = {}
    handle.output = []
    handle.some_var = \"\"
    handle.scan_string = \"\"
    handle.orig_code = \"\"
    handle.corr_code = \"\"
    handle.zeroday = \"\"
    handle.objects = [] // metaLib, debugLibrary, list_of_line_numbers
    handle.test = function( list, debuglib )
        zero_day = debuglib.unit_test(list)
        print colorGold+\"Processing...\"
        if zero_day == null then return \"zer0Chill: unit_test failed: invalid input\"
        if zero_day == \"Test failed: No errors have been found in one or more of the provided lines, or not all lines with errors have been provided.\" then return zero_day
        print colorWhite+\"Success. Sending result to BUFFER\"
        globals.BUFFER.push(zero_day)
        print \"zer0Cill: task complete, returning result:\"
        return zero_day
    end function
    handle.patch = function( debugLibrary, patch_path )
        act = debugLibrary.apply_patch( patch_path )
		print act
    end function
    handle.The = function( f, v ) // create a new function, create it's first line, determine it's param from that line
        handle.output.push(f+\" = function(\"+v+\")\")
    end function
    handle.If = function( string ) // [If] the value of var_pkPc3t is greater than or equal to 5,...
        valu = string.split(\"value of\")[1].split(\"is\")[0].trim // var_pkPc3t
        statement = string.split(\", \")[0].split(\"is\")[1].trim // greater than or equal to 5
        if DEBUG then print \"processing statement: \"+statement
        line = \"if \"+valu+\" \"+handle._maths(statement)+\" then\" // if var_pkPc3t >= 5 then
        handle.output.push(line)
        // ...then updates var_pkPc3t by calculating var_pkPc3t plus 6
        next_line = string.split(\", \")[1].split(\"calculating \")[1].split(\" \") // var_pkPc3t plus 6
        var = next_line.pull 
        const = next_line.pop 
        op = next_line.join(\" \")
        if op == \"plus\" then op = \"+\"
        if op == \"minus\" then op = \"-\"
        if op == \"divided by\" then op = \"/\"
        if op == \"multiplied by\" then op = \"*\"
        line = var+\" = \"+var+\" \"+op+\" \"+const // var_pkPc3t = var_pkPc3t + 6
        handle.output.push(line)
        handle.output.push(\"end if\")
    end function
    handle.For = function( string ) // [For] each i from 0 to 2, updates var_pkPc3t by multiplying it by i
        lines = string.split(\", \")
        line1 = lines[0]
        line2 = lines[1]

        range_min = line1.split(\"from \")[1].split(\" to \")[0] // 0
        range_max = line1.split(\"from \")[1].split(\" to \")[1] // 2
        var = line2.split(\" by \")[0].split(\" \")[1] // var_pkPc3t
        op = var+\" = i * \"+var
        handle.output.push(\"for i in range(\"+range_min+\", \"+range_max+\")\")
        handle.output.push(op)
        handle.output.push(\"end for\")
    end function
    handle.calculates = function( string ) // [calculates] var_pkPc3t minus 1
        input = string.split(\" \")
        v = input.pull
        const = input.pop 
        op = input.join(\" \").trim
        if op == \"plus\" then op = \"+\"
        if op == \"minus\" then op = \"-\"
        if op == \"divided by\" then op = \"/\"
        if op == \"multiplied by\" then op = \"*\"
        handle.output.push(v+\" = \"+v+\" \"+op+\" \"+const)
    end function
    handle.calls = function( string ) // calls the function func_oEHEM4 with var_pkPc3t.
        line = string.split(\"function \")[1].split(\" \")
        func = line[0]
        var = line[-1]
        handle.output.push(var+\" = \"+func+\"(\"+var+\")\")
    end function
    handle.creates = function( string ) // creates a list var_nDHyNB, adds var_Znm6qW to var_nDHyNB, and assigns var_Znm6qW to the first element of var_nDHyNB.
        line1 = string.split(\", \")[0]
        list = line1.split(\"list \")[1]
        line2 = string.split(\", \")[1]
        v = line2.split(\" \")[1]
        handle.output.push(list+\" = []\")
        handle.output.push( list+\".push(\"+v+\")\")
        handle.output.push(v+\" = \"+list+\"[0]\")
    end function
    handle.Finally = function( string ) // [returns] something
        ret_v = string.split(\" \")[-1]
        line = \"return \"+ret_v 
        handle.output.push(line)
        handle.output.push(\"end function\")
        handle.output.push(\"\")
    end function
    handle._maths = function( string )
        st = string.split(\" \")
        v = st.pop
        st = st.join(\" \").trim
        op = \"\"
        if DEBUG then print \"in _maths: st is:\"+st
        if st == \"greater than or equal to\" then return \">= \"+v
        if st == \"greater than\" then return \"> \"+v
        if st == \"less than\" then return \"< \"+v
        if st == \"less than or equal to\" then return \"<= \"+v
        if st == \"equal to\" then return \"== \"+v
        if st == \"not equal to\" then return \"!= \"+v
        if op == \"\" then return \"<b>unknown operation!</b> \"+v
    end function
    handle.write_patch = function( list, file )
        out = list.join(char(10))
        return file.set_content(out)
    end function
    handle._parse = function( string )
        sl = string.split(\" \")
        first_word = sl.pull.replace(\",\",\"\")
        if first_word == \"The\" then 
            if DEBUG then print \"creating new function...\"
            sl.pull 
            f_name = sl.pull 
            if DEBUG then print f_name
            handle.The(f_name,handle.some_var)
            first_word = sl.pull.replace(\",\",\"\")
        end if
        ins = sl.join(\" \")
        yadda = \"\"
        if DEBUG then print \"looking for index: \"+first_word
        if handle.hasIndex(first_word) then yadda = @handle[first_word] else return 0 // fix this
        yadda(sl.join(\" \"))
        return 1
    end function
    handle.export = function( string )
        print \"zer0Chill: sending code snippet to BUFFER\"
        globals.BUFFER.push(string)
        file = globals.get_file(currentPath+\"/orig\")
        if not file then print command.poke(currentPath+\"/orig\")
        file = globals.get_file(currentPath+\"/orig\")
        if not file then print \"zer0Chill: unable to locate or create \"+currentPath+\"/orig\"
        print \"zer0Chill: writing original code snippet to \"+file.path
        if file.has_permission(\"w\") then file.set_content(string) else print \"write failed: permission denied\"
    end function 
    handle._refactor = function( string )
        //print string
        arr = string.split(char(10))
        //print arr
        out_b = []
        for line in arr
            sl = line.split(\":\")
            if sl.len > 1 then out_b.push(sl[1].trim)
        end for
        handle.export( out_b.join(char(10)) )
    end function
    handle._split_strings = function( string )
        if DEBUG then print \"debug: string to split:\"+char(10)+string
        instructions = string[:string.indexOf(\"01:\")].trim.remove(\"Potential problems have been found in the following code:\")
        original_code = string[string.indexOf(\"01:\"):]
        return [ instructions, original_code ]
    end function
    handle._heuristics = function()
        success = 0
        debug_lib = metalib.debug_tools(neurobox_user,neurobox_pass)
        if typeof(debug_lib) != \"debugLibrary\" or debug_lib == \"Incorrect password\" then return [ success, debug_lib ]
        output = \"\"
        output = debug_lib.scan 


        success = 1    
        return [ success, output, debug_lib ]
    end function
    ///////////////////////////////////////////////////////////////////////////////////    
    handle.zero_pwn = function( string ) 
        handle.some_var = string.split(\"returns\")[-1].replace(\"\\.\",\"\").trim
        chunk = string.replace(char(10),\"\").split(\"\\.\")
        
        if DEBUG then print \"Found some var: \"+handle.some_var
        for line in chunk
            if DEBUG then print \"processing line: \"+line
            handle._parse(line.trim)
        end for

        output_file = globals.get_file(currentPath+\"/patch.zd\")
        if not output_file then print command.poke(currentPath+\"/patch.zd\")
        output_file = globals.get_file(currentPath+\"/patch.zd\")
        if not output_file then 
			print \"zer0Chill: could not find or create patch.zd in current path\"+char(10)+\"-- <b>patch not written to file!\"
		else
			if not output_file.has_permission(\"w\") then 
                print \"zer0Chill: patch.zd is write protected\"+char(10)+\"-- <b>patch not written to file!\"
            else
                print \"zer0Chill: writing patch file to: <b>\"+output_file.path+char(10)+\"-- status: [\"+handle.write_patch(handle.output, output_file)+\"]\"
				
            end if
        end if
        print \"zer0Chill: returning output...\"
        return handle.output.join(char(10))
    end function
    ///////////////////////////////////////////////////////////////////////////////
    print \"Launching Zer0Chill v 0.3...\"
    hl = handle._heuristics // returns list
    h=\"\"
    if not hl[0] then return hl[1] else h = hl[1]
    if DEBUG then print \"debug: big string is:\"+char(10)+h+char(10)
    print colorOrange+\"zer0Chill: sending debugLibrary to BUFFER\"
    globals.BUFFER.push(hl[2])
    print colorOrange+\"-- sending debug string to BUFFER\"
    globals.BUFFER.push(h)
    s = handle._split_strings(h) // returns list
    handle._refactor(s[1])
    return handle.zero_pwn(s[0])
end function
command.macro = function(arg1,arg2,arg3,arg4)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<u>macro || alias || auto || variable || global\"+char(10)+
	\"* A macro allows you to define a set of actions commands to execute using a single command.\"+char(10)+
	\"* Use floating quotes to wrap the chain of commands and type them as you would normally on the CLI.\"+char(10)+
	\"* Macro's are essentially 'on the fly' do scripts that are stored in the custom object.\"+char(10)+
	\"* You may retrieve a macro from the custom object (for piping, or whatever) with<b> get [macro_name].\"+char(10)+
	\"* You may pipe a <b>do</b> script into a macro. A do script may execute a macro with: <b>do # [macro_name].\"+char(10)+
	\"* This makes the two interchangeable, allowing you to choose the exact behavior you want performed.\"+char(10)+
	colorCyan+\"</b>Usage: macro [-s|set] [name] [string] -- set a macro to the given string\"+char(10)+
	\"-- eg: macro -s foo \"\"echo bar | clipa\"\"\"+char(10)+
	colorCyan+\"</b>Usage: macro [name] -- fire the named macro, the macro prepend is <b>optional\"+char(10)+
	colorGold+\"</b>NOTE: All macros may be fired from the command line by typing the macro name\"+char(10)+
	\"-- this includes using macros within a string of piped commands\"+char(10)+
	\"--eg: |> <b>macro -s gotime \"\" echo it's go time \"\"\"+char(10)+
	\"----: |> <b>echo three | echo two | echo one | gotime | echo \"\" what time is it? \"\"\"+char(10)+
	colorCyan+\"</b>Usage: macro [-d|del] [name] -- delete the named macro\"+char(10)+
	\"-- eg: macro -d foo\"+char(10)+
	colorCyan+\"</b>Usage: macro [-l|list] -- show all macros and their definitions\"+char(10)+
	\"-- all macros are stored in the macro registry map: get_custom_object.macros\"+char(10)+
	colorCyan+\"Usage: macro [-g|get] [macro] -- return the macro string of the given macro\"+char(10)+char(10)+
	colorGreen+\"See Also: do -h, help conventions, help alias, help automation\"
	if not arg1 then return \"Usage: macro [name] [opt:string]\"
	print colorCyan+\"<size=75%><u>==========macro==========\"
	gm = get_custom_object.macros
	nsm = \"-- no such macro\"
	if arg1 == \"-g\" or arg1 == \"get\" then 
		if arg2 and gm.hasIndex(arg2) then 
			return gm[arg2]
		else 
			return nsm
		end if
	end if		
	if arg1 == \"-l\" or arg1 == \"list\" then 
		mbuf = []
		for kv in gm 
			mbuf.push(colorCyan+\"</b>\"+kv.key+\" </color>>> \"+colorWhite+\"</b>\"+kv.value)
		end for
		return format_columns(mbuf.join(char(10)))
	end if 
	if arg1 == \"del\" or arg1 == \"-d\" then 
		// remove a macro
		if arg2 and gm.hasIndex(arg2) then 
			gm.remove(arg2)
			return colorCyan+\"-- deleted: \"+colorWhite+arg2
			//return command.cob(\"del\",arg2)
		else 
			return nsm
		end if
	end if
	if arg1 == \"set\" or arg1 == \"-s\" then 
		// create a macro
		if not arg3 then return \"-- [-s] flag expects [name] [value]\"
		if gm.hasIndex(arg2) then print colorCyan+\"</b>--\"+colorOrange+\"</b> macro already exists; overwriting\"
		gm[arg2] = arg3
		return colorCyan+\"</b>-- registered: \"+colorWhite+\"</b>\"+arg2+CT+\" as \"+colorWhite+\"</b>\"+arg3//print command.cob(\"set\",arg2,arg3)
	else 
		//fire a macro
		macmac = null
		if gm.hasIndex(arg1) then macmac = gm[arg1] else return nsm
		if typeof(macmac) != \"string\" then return \"-- invalid macro; this looks more like an alias\"
		return command.shell(macmac.replace(char(10),\" |  | \")+\" | return\")		
	end if
	return 0
end function
command.hashim = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then
		if arg2 and arg2 == \"extra\" then
			return \"Files required: /root/tables/t5/XX (XX is all files from<b> pwgen hash </b>, ascii), 5hell (bin).\"+char(10)+
			\"Files created: /root/dump.txt (ascii) -- the output file with cracked passwords\"+char(10)+
			\"Input format: \"+char(10)+
			\"<b>user:hash \"+char(10)+
			\"Once per line in /root/pass or specified path (see also <b>transmit</b>). \"+char(10)+
			\"May be of type bank, mail, password.\"
		else
			return \"hash || decipher || passwords || tables || md5\"+char(10)+
			colorLightBlue+\"</b>Usage: hashim [-d|-f] [path] --<color=white> listen on [path] and decipher contents using tables/t5\"+char(10)+
			\"-- default path is /root/pass\"+char(10)+
			\"<b>Usage: hashim [-f] [opt:path] -- run once on specified path\"+char(10)+
			\"-- uses /root/pass if not specified\"+char(10)+
			\"<b>Usage: hashim [-d] [opt:path]-- run as a daemon on /root/pass or specified path\"+char(10)+
			\"-- to end the daemon process, use the command:<b> purge -d [opt:name]\"+char(10)+
   	 		\"---- or note the daemon name printed on the screen and \"+char(10)+
    		\"---- remove the corresponding line from <b>/root/5hell.d</b>\"+char(10)+
    		\"---- or delete the file entirely\"+char(10)+
    		\"-- if the file cannot be created, then the process must be exited with <b>ctrl+c\"+char(10)+char(10)+
			\"N.B. Please run <b>pwgen hash</b> to setup resources for hashim.\"+char(10)+
			\"n.b.b This command requires root access and it is recommended to use, along with pwgen,\"+char(10)+
			\"-- on a dedicated server due to the number of files involved\"+char(10)+
			\"-- ie try not to spam hashim servers; a single one works wonders\"+char(10)+char(10)+
			\"Extra: hashim [-h|help] [extra] -- extra help page with extra help info.\"
		end if
	end if
	if arg1 != \"-d\" and arg1 != \"-f\" then return \"Usage: hashim [-f|-d] [path] -- -f == run once on specified path, -d == run in daemon mode on specified path. Default path: /root/pass.\"
	if not crypto then print(colorOrange+\"WARNING: crypto.so not found\"+CT)
	//dump = globals.get_file(\"dump.txt\")
	dump = command.tree(\"/\",\"dump.txt\",1,\"N\")
	slash = \"/\"
	if currentPath == \"/\" then slash = \"\"
	if typeof(dump) != \"file\" then 
		print command.poke(currentPath+slash+\"dump.txt\")
		dump = globals.get_file(\"dump.txt\")
	end if
	if not dump then return \"hashim: dump.txt not found in current path.\"+char(10)+\"hashim: unable to write dump.txt\"
	if arg2 then swap_path = arg2 else swap_path = globals.HOME_SERVER[5] // \"/root/pass\"//params[0]
	swap_file = globals.get_file(swap_path)
	if not swap_file then return(\"hashim: \"+swap_path+\" not found.\") else print \"hashim: found swap file: \"+swap_path
	//out_path = \"/virt/out.spc\"
	//out_file = localmachine.File(out_path)
	//if not out_file then return(\"404: \"+out_path+\" not found\"+char(10)+\"type<b> kore </b>without params to create (you may skip adding an ip)\")
	cache = []
	found = false
	daemon = true
	if arg1 == \"false\" or arg1 == \"-f\" then daemon = false
	hashim = function(daemon,swap_file)
		wait(.05)
		//if not daemon then swap_path = \"/root/pass\"
		//swap_file = globals.get_file(swap_path)
		if not swap_file then return \"hashim: error: \"+swap_path+\" not found.\"
		last_read = \"\" //swap_file.get_content
		running = true
		manager = new DaemonManager
		daemon = manager.Start(\"hashim\")
		// move the tables stuff up here, not good to keep redoing it in a loop
		print(colorWhite+\"Listening on :\"+swap_path+\" for connections...\"+CT)
		print(colorWhite+\"Daemon: \"+daemon+CT)
		while (daemon and manager.Check(daemon)) or not manager.__initialized
			found = false
			hash = \"\"
			user = \"\"
			if last_read == swap_file.get_content or swap_file.get_content == \"\" then
				// skip
			else
				time_s = time
				last_read = swap_file.get_content.split(char(10))
				for hash in last_read
					found = false
					if DEBUG then print \"hash is: \"+hash
					if hash.indexOf(\":\") >= 0 then
						user = hash.split(\":\")[0]
						hash = hash.split(\":\")[1]
					else
						if hash.len == 32 then 
							user = \"unknown\"
						else
							continue
						end if
					end if
					hash = hash.trim
					if DEBUG then print \"hash is:\"+hash+\" and len is: \"+hash.len
					if hash.len != 32 then continue
					print(\"[\"+hash+\"]\")
					t_path = globals.HOME_SERVER[6]
					t_folder = globals.get_file(t_path)
					have_tables = false
					if not t_folder then 
						print \"hashim: \"+t_path+\" not found; searching for tables...\"
						t_folder = command.tree(\"/\",\"tables\",1,\"N\")
						if typeof(t_folder) == \"file\" and t_folder.is_folder then 
							folds = t_folder.get_folders
							for f in folds
								if f.name == \"t5\" and f.is_folder then 
									t_folder = f 
									have_tables = true 
								end if
							end for
						else 
							print \"hashim: tables not found; defaulting to cryptolib\"
						end if
					else 
						print \"hashim: using: \"+t_path
						have_tables = true
					end if
					if have_tables == true then
						files = t_folder.get_files
						for f in files
							if found then continue
							lines = f.get_content.split(char(10))
							for line in lines
								if found then continue
								if line == lines[0] then continue
								spl = line.split(\"=\")
								h = spl[0]
								p = spl[1]
								if h == hash then
									print(\"Hashim: \" + user + \":\" + colorWhite + p + CT + \" found in \" + (time-time_s) + \" seconds.\")
									cache.push(user + \":\" + p)
									found = true
									continue
									if h.len != 32 then print(colorRed+\"hashim: t5 table error: entry is not 32 characters\"+char(10)+line+char(10)+\"Line: \"+lines.indexOf(line))
								end if
							end for
						end for
					end if
					if found == true then continue
					if crypto then
						password = null
						password = crypto.decipher(hash)
						if password then
							print(\"Hashim: \" + user + \":\" + colorWhite + password + CT + \" found in \" + (time-time_s) + \" seconds.\")
							cache.push(user + \":\" + password)
							found = true
							continue
						end if
					else 
						print \"hashim: error; no cryptolib found\"
					end if
					print(colorRed+\"Hash not found: unknown: \"+hash+CT)
					cache.push(user+\":unknown\")
				end for
				last_read = cache.join(char(10))
				if daemon then print(\"Sending: \"+char(10)+last_read)
				if daemon then swap_file.set_content(last_read)
				print(\"Saving to dump.txt...\")
				dump.set_content(dump.get_content+char(10)+last_read)
				cache = []
				print(colorLightBlue+\"Hashim: completed task in \"+(time-time_s)+\" seconds.\"+CT)
				wait(1)
				if daemon then
					print(colorWhite+\"Listening on :\"+swap_path+\" for connections...\"+CT)
					print(colorWhite+\"Daemon: \" + daemon + CT)
				else
					return 0
				end if
			end if
			wait(.05)
		end while
		return 0
	end function
	return hashim(daemon,swap_file)
end function
command.tdump = function(arg1,arg2,arg3,arg4)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"Transmission Buffer Dump\"+char(10)+\"Usage: tdump [opt: path] -- dump tbuf (transmission buffer) to file\"+char(10)+\"-- writes to specified path or default path of home_directory+/pass\"
	if globals.T_BUF.len <= 1 then return \"Transmission buffer is empty.\"
	tpath = arg1 
	if not tpath then 
		if currentPath != \"/\" then tpath = currentPath + \"/pass\" else tpath = currentPath+\"pass\"
	end if
	print colorLightBlue+\"dumping t_buf to: \"+colorWhite+tpath
	passfile = globals.get_file(tpath)
	if not passfile then 
		print \"tdump: \"+tpath+\" not found\"
		print \"poke: creating \"+tpath
		print command.poke(tpath)
		passfile = globals.get_file(tpath)
		if not passfile then return \"tdump: write permission denied\"
	end if
	if typeof(passfile) != \"file\" then return \"tdump: \"+tpath+\" not found. \"+char(10)+\"-- check path and glasspool status and try again.\"
	if not passfile.has_permission(\"w\") then return \"tdump: write permission denied\"
	tcatch = passfile.set_content( globals.T_BUF.join(char(10)) ) 
	if DEBUG then print \"debug: tcatch: \"+tcatch+\" is a \"+ typeof(tcatch)
	if typeof(tcatch) == \"string\" then return tcatch else print colorLightBlue+\"tdump: task complete...\"
	globals.T_BUF = [(localip+\"@\"+pubip)]
	//globals.T_BUF = []
	print \"tdump: returning file object for \"+passfile.path
	return passfile
end function"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction6" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]5phinx.5pk.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/root/src/5phinx.5pk[/color]. Make sure to keep 'Allow import' checked."
fit_content = true

[node name="5PhinxCodeEdit" type="CodeEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 300)
layout_mode = 2
text = "// Sphinx Hacking Interface v 2.8.0 by Plu70

//Define Globals
sphinx_version = \"2.9.2\"
malp_version = \"1.4.9\"
if DEBUG then print(\"<size=75%>loading 5phinx.5pk v \"+sphinx_version+\" for 5hell v 4.0.7...(156.615)</size>\")

NUM_SPLOITS = function()
  num = XPLOITS.len
  if not num then num = 0
  return num
end function

update_path = function()
  globals.currentPath = current_path
  print \"Updating current path to: \"+globals.currentPath
  return 0
end function

_exit = @exit
globals.exit = function(msg)
  //if not msg then return colorRed+\"quit: invalid exit call; aborting shutdown\" // nope, this was a bad idea
  eob = get_custom_object // end of business, if you were wondering
  eob.return_value = msg 
  _exit(msg)
end function
globals._cascade = function()
  if get_custom_object.hasIndex(\"return_value\") and get_custom_object.return_value == \"#!#CASCADE#!#\" then exit \"#!#CASCADE#!#\" else return 0
end function

// // make this more better good by searching the whole filesystem // done
hot_swap_libs = function() 
    return globals.super_import
end function

// import_lib and super import! to replace hot swap libs. this version makes sure to use the highest version
globals.import_lib = function(grep, filepath) // String: lib_name, File: search_path
  if filepath.is_binary and not filepath.is_folder then
    v = \"?.?.?\"
    lib = null 
    fp = filepath.path
    lib = include_lib(fp)
    if typeof(lib) == grep then 
      if globals.hasIndex(\"MetaxploitLib\") then 
        v = globals.MetaxploitLib.lib.load(fp).version 
      else 
        if typeof(lib) == \"MetaxploitLib\" then v = lib.load(fp).version
      end if
      if DEBUG then print \"found: \"+lib+\" v \"+v
      if globals.hasIndex(grep) then 
        t = [v,globals[grep][\"version\"]]
        t.sort
        if v == t[-1] then globals[grep] = {\"version\":v,\"lib\":lib,\"path\":fp}
      else 
        globals[grep] = {\"version\":v,\"lib\":lib,\"path\":fp}
      end if
    end if
  else
    if filepath.is_folder then
      folders = filepath.get_folders
      files = folders + filepath.get_files
      for file in files
        import_lib(grep, file)
      end for
    end if
  end if
end function
globals.super_import = function(import_this=0) // String: name; import requested lib instead of defaults
	start_here = get_shell.host_computer.File(\"/\") 
	//
  if import_this then 
    lib_types = [import_this]
  else 
  	lib_types = [ \"MetaxploitLib\", \"cryptoLib\", \"aptclientLib\" ]
  end if
	for lib_type in lib_types
		if DEBUG then print(\"Searching for: \"+lib_type)
		import_lib( lib_type, start_here ) 
	end for
	//
	if DEBUG then print \" - - - - - - - \"
	//
	for lib in lib_types
		if not globals.hasIndex(lib) then 
			globals[lib] = {\"version\":\"-.-.-\",\"lib\":null,\"path\":\"null\"}
			print \"WARNING: \"+lib+\" not found!\"
		end if
		if DEBUG then print globals[lib][\"version\"]+\" v \"+globals[lib][\"lib\"]+\" path: \"+globals[lib][\"path\"]
	end for
	//
	globals.metaxploit = globals.MetaxploitLib.lib 
	globals.metaLibVersion = globals.MetaxploitLib.version
  globals.meta_path = globals.MetaxploitLib.path //  legacy, deprecated
	//
	globals.crypto = globals.cryptoLib.lib 
	globals.cryptoLibVersion = globals.cryptoLib.version
	//
	globals.apt_get = globals.aptclientLib.lib 
  return globals[lib_types[0]]
end function
// end super import

globals._ez_clip = function( in_prompt )
  for e in in_prompt 
    if DEBUG then print(\"z: \"+@e)
      // reprocess: unpack single quote chunk, process, repackage
    if typeof(@e) != \"string\" then continue
    if e.split(\" \").len > 1 then 
        in_prompt[in_prompt.indexOf(@e)] = _ez_clip(@e.split(\" \")).join(\" \")
        continue
    end if
    // done reprocessing
    if DEBUG then print(\"p: \"+@e)
    e_indx = in_prompt.indexOf(@e) 
    if @e == \"@STOP\" then in_prompt[e_indx] = @globals.SAFEWORD
    if @e == \"@a\" then in_prompt[e_indx] = @globals.clip_board_alpha
    if @e == \"@b\" then in_prompt[e_indx] = @globals.clip_board_beta
    if @e == \"@c\" then in_prompt[e_indx] = @globals.clip_board_gamma
    if @e == \"@home\" then in_prompt[e_indx] = @globals.HOME_SERVER[0]
    if @e == \"@tbuf\" then in_prompt[e_indx] = @globals.T_BUF.join(char(10))
    if @e == \"@t\" then in_prompt[e_indx] = @globals.targetIP 
    if @e == \"@p\" then in_prompt[e_indx] = @str(globals.targetPort)
    if @e == \"@o\" then // this is getting out of hand...
      if in_prompt.hasIndex(e_indx+1) and typeof(in_prompt[e_indx+1]) == \"string\" and get_custom_object.hasIndex(in_prompt[e_indx+1]) then 
          in_prompt[e_indx+1] = command.cob(\"get\",in_prompt[e_indx+1])
          in_prompt.remove(e_indx)
      else 
          if DEBUG then print \"@objects: key not found\"
      end if
    end if
    if @e == \"@B\" then 
      b_err = colorOrange+\"@BUFFER: invalid selection\"
      if in_prompt.hasIndex(e_indx+1) then 
        if DEBUG then print \"e_indx: \"+e_indx
        if in_prompt[e_indx+1] == \"-m\" then 
                // if globals.BUFFER.len < 1 then 
                //   print colorRed+\"@BUFFER: BUFFER is empty!\"
                //   continue
                // elseS
                  //i = 0
                  // for b in globals.BUFFER
                  //     if typeof(@b) == \"function\" then print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(@b)+\":\"+typeof(@b)+\"</b>\") else print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(b)+\":\"+typeof(b)+\"</b>\")
                  //     i = i + 1
                  // end for
          if BUFFER.len == 0 then
            print(colorOrange+\"\\nBuffer empty. \")
            continue
          end if
          print(\"\\nExpanding... \")
          print(colorWhite+\"__________________________________\")
          i = 0
          //b_list = globals.BUFFER[0:]
          if DEBUG then print(\"checking buffer integrity...\")
          for b in globals.BUFFER //b_list
            //if DEBUG then print p_validate(@b,\"name\")
            //if DEBUG then print \"b: \"+@b
            if typeof(@b) == \"file\" and not p_exe(@b,\"name\") then
              globals.BUFFER.remove(globals.BUFFER.indexOf(b))
              print(\"[<size=65%>malp: null file removed. skipping...</size>]\")
              continue
            end if
            /////////////////// BEGIN_BUFFER //////////////////////////////////////////////////
            //print(colorOrange+\"[\"+i+\"]</b>BUFFERED: \" + \"[\"+checkUser(b) +\":\"+ typeof(b)+\"]\")
            if typeof(@b) == \"function\" then
              print(colorOrange+\"[\"+i+\"]</b>BUFFERED: \" + \"[\"+checkUser(@b) +\":\"+ typeof(@b)+\"]\")
            else
              print(colorOrange+\"[\"+i+\"]</b>BUFFERED: \" + \"[\"+checkUser(b) +\":\"+ typeof(b)+\"]\")
            end if
            if typeof(@b) == \"file\" then print(b.path+char(10)+b.permissions+\" \"+b.owner+\" \"+b.group+\" \"+b.size+\" b[\"+b.is_binary+\"] \"+b.name)
            if typeof(@b) == \"computer\" then print(format_columns(b.show_procs+char(10)+b.public_ip+char(10)+b.local_ip))
            if typeof(@b) == \"shell\" or typeof(@b) == \"ftpshell\" then print(format_columns(b.host_computer.show_procs+char(10)+b.host_computer.public_ip+char(10)+b.host_computer.local_ip))
            if typeof(@b) == \"string\" or typeof(@b) == \"list\" or typeof(@b) == \"map\" then print( \"elements: \"+b.len )
            i = i + 1
          end for
          print(colorWhite+\"__________________________________\")
          get = user_input(\"select an object:> \").to_int
          if typeof(get) != \"number\" then print b_err
          if get >= 0 and get < globals.BUFFER.len then 
              in_prompt[e_indx+1] = @globals.BUFFER[get]
              in_prompt.remove(e_indx) 
              if DEBUG then print \"post menu in_prompt \"+in_prompt   
          else    
              print b_err
          end if
        else
          if typeof(in_prompt[e_indx+1]) == \"string\" then 
            if globals.BUFFER.hasIndex(in_prompt[e_indx+1].to_int) then 
                in_prompt[e_indx+1] = @globals.BUFFER[in_prompt[e_indx+1].to_int]
                in_prompt.remove(e_indx)
                if DEBUG then print \"post non menu in_prompt\"
            else 
                print b_err
            end if
          end if
        end if
      end if
    end if
    // process escapes
    // hi clover, if you see this, feel free to make it magic
    if @e == \"\\@STOP\" then in_prompt[e_indx] = \"@STOP\"
    if @e == \"\\@a\" then in_prompt[e_indx] = \"@a\"
    if @e == \"\\@b\" then in_prompt[e_indx] = \"@b\"
    if @e == \"\\@c\" then in_prompt[e_indx] = \"@c\"
    if @e == \"\\\"\"\" then in_prompt[e_indx] = \"\"\"\"
    if @e == \"\\@home\" then in_prompt[e_indx] = \"@home\"
    if @e == \"\\@tbuf\" then in_prompt[e_indx] = \"@tbuf\"
    if @e == \"\\@t\" then in_prompt[e_indx] = \"@t\"
    if @e == \"\\@p\" then in_prompt[e_indx] = \"@p\"
    if @e == \"\\@o\" then in_prompt[e_indx] = \"@o\"
    if @e == \"\\@B\" then in_prompt[e_indx] = \"@B\"
    if DEBUG then print(\"b: \"+ in_prompt[e_indx])
  end for
  if DEBUG then print \"ezclip: returning: \"+in_prompt
  return in_prompt
end function



globals.stack_pool = function(opt=null)
  if get_custom_object.hasIndex(\"stack_pool\") then
    if DEBUG then print \"debug: stack: turning up\"
    if opt == \"up\" then get_custom_object.stack_pool = get_custom_object.stack_pool + 1
    if DEBUG then print \"debug: stack: turning down\"
    if opt == \"down\" then get_custom_object.stack_pool = get_custom_object.stack_pool - 1
  else 
    if DEBUG then print \"debug: stack: on\"
    get_custom_object.stack_pool = 0
  end if 
  return get_custom_object.stack_pool
end function

globals._import_tables = function()
  if globals.dict_a.len > 1 then return \"cerebrum: already loaded\"
  t = command.tree(\"/\",\"tables\",\"1\",\"N\")
  if not t then return \"tree: tables not found\"
  for f in t.get_folders 
    if f.name == \"tp\" then 
      return command.cerebrum(\"-i\",f.path)
    end if
  end for
  return 0
end function

globals._startup_resource_configuration  = function()
  //if stack_pool then return 0
  //
  p = null
  r = globals.get_file(home_dir+\"/Config/do.rc\") // look for do.rc in ~/Config, first
  if not r then 
    r = command.tree(\"/\",\"rkit\",\"1\",\"N\") // look for do.rc in rkit if it isn't in /Config
    if typeof(r) != \"file\" or not r.is_folder then return \"tree: rkit folder not found\"
    for f in r.get_files 
      if f.name == \"do.rc\" then p = f 
    end for
  else 
    p = r
  end if 
  if not p then return \"tree: do.rc not found\"
  if p.is_binary then return \"tree: do.rc is binary!\"
  if not p.has_permission(\"r\") then return \"do: do.rc is read protected\"
  c = p.get_content.split(char(10))
  print colorGold+\"<size=50%>kore:\"+colorWhite+\" ...<u>do.rc</u> detected, beginning resource configuration...\"
  for line in c
    command.shell(line+\" | return\")
  end for
  return 0
end function

mail_user_list = function(ip_address, port)
  if not crypto then return 0
  return crypto.smtp_user_list( ip_address , port )
end function

globals._export_metax = function() // export metaxploit to the custom object: called on startup
  s = globals.stack_pool
  g = get_custom_object
  m = globals.metaxploit 
  g[\"myx\"+s] = m 
  return 0
end function

globals.sus = function(a,b,c,d) // expects libname v version
  print colorWhite+\"Sussing...\"
	db = null
	db = command.tree( \"/\", \"database.csv\", \"1\", \"n\" )
	if typeof(db) != \"file\" then return \"sus: database.csv not found\"
	dat = db.get_content.split(char(10))
	while true
    if DEBUG then print \"debug: calling rnip\"
		ip = command.rnip(\"1\")
		rtr = get_router(ip)
		if not rtr then continue
		query = \"kernel_router.so v \"+rtr.kernel_version
    if DEBUG then print \"debug: query: \"+ query
		if dat.indexOf(query) >= 0 then return ip
	end while
  print \"sus: failed! try again\"
	return 0
end function

dump_memory = function()
  suff = range(0,9)
  suff.shuffle
  m_name = \"memdump\"+suff.pop+suff.pop+suff.pop+\".mx\"
  localmachine.touch(currentPath, m_name)
  memdump = globals.get_file(m_name)
  if memdump then
    buf = []
    if globals.targetIP then buf.push(globals.targetIP+\": \"+globals.targetPort+char(10))
    if MEMORY then buf.push(MEMORY.join( char(10) ) + char(10) )
    if XPLOITS then buf.push(XPLOITS.join( char(10) ) + char(10) )
    if meta_scan then buf.push(meta_scan.join( char(10) ) + char(10) )
    if PORT_MAP then buf.push(display_portmap(1))
    if globals.clip_board_alpha.len then buf.push( globals.clip_board_alpha )
    if globals.clip_board_beta.len then buf.push( globals.clip_board_beta )
    if globals.clip_board_gamma.len then buf.push( globals.clip_board_gamma )
    buf.push(T_BUF)
    memdump.set_content( buf.join( char(10) ) )
    print(\"Memory dumped to: \"+memdump.path)
    return 1
  else
    print(\"Error: memory dump failed. Check write permissions.\")
    return \"404\"
  end if
end function

string.noparse = function(self)
  split_line = self.split(char(10))
  buf = []
  for line in split_line 
    buf.push(\"<noparse>\"+line)
  end for 
  return buf.join(char(10))
end function

// warning: garbage code follows. somehow 'works'
globals.decompiler = function(object)
  act = \"Decompiling\"
  if typeof(@object) == \"custom_object\" then 
    print(\"<mark=yellow>Expanding custom object...\")
    for thing in object 
      print thing
    end for 
    return object
  end if
  if typeof(@object) == \"function\" then act = \"Evaluating\"
  print(\"<mark=yellow>\"+act+\": \"+typeof(@object)+\"</mark>\")
  //print(object)
  c = @object
  if typeof(@c)==\"number\" then return c
  if typeof(@c) == \"string\" then 
    fe = []
    for letter in c.values 
      fe.push(letter.code)
    end for 
    return fe.join(\", \")
  end if 
  if typeof(@c) == \"function\" then
    return p_exe(@c)
  end if
  if @c.indexOf(\"__isa\") >= 0 or @c.hasIndex(\"__isa\") or @c.hasIndex(\"classID\") or typeof(@c) == \"pshell\" or typeof(@c) == \"pfile\" or typeof(@c) == \"pcomputer\" or typeof(@c) == \"shell\" or typeof(@c) == \"file\" or typeof(@c) == \"computer\" or typeof(@c) == \"ftpshell\" then 
    //if @c.hasIndex(\"__isa\") then methods = @c.__isa.indexes else methods = @c.indexes
    methods = c.__isa.indexes
    if typeof(c) == \"MetaLib\" then 
      print colorWhite+c.lib_name+CT+\" v \"+colorWhite+c.version
    end if
    if DEBUG then print \"debug: methods: \"+methods
    for ind in methods
      print(ind+\": \"+c[ind])
    end for
    print(\"- - - - - - - - - - - - - - - -\"+char(10))
    //return f.join(\", \")
    i = 0
    for m in methods
      print(\"[\"+colorWhite+ i +CT+\"] [ \"+colorLightBlue+ m +CT+\" ]\")
      i = i + 1
    end for 
    i = i - 1
    if DEBUG then print(\"debug: i: \"+i+\" methods: \"+methods.len)
    print(colorWhite+\"<u>======================</u>\"+CT)
    pr = user_input(\"Select a function to execute (q=quit):> \")
    if pr.lower == \"q\" or pr == \"\" or pr == \" \" then return \"aborting...\" 
    pr = pr.to_int
    rcv = null
    if pr >= 0 and pr <= i then rcv = globals.p_exe( c , methods[pr]) else return 0
    if DEBUG then print \"rcv: \"+rcv
    if rcv then //and typeof(rcv) != \"number\" and rcv.hasIndex(\"__isa\") then //typeof(rcv) == \"shell\" or typeof(rcv) == \"computer\" or typeof(rcv) == \"file\" or typeof(rcv) == \"router\" or typeof(rcv) == \"port\" or typeof(rcv) == \"ftpshell\" or typeof(rcv) == \"netsession\" or typeof(rcv) == \"metaLib\" then 
      globals.BUFFER.push(rcv)
      print( \"result: \"+typeof(rcv) + \" sent to BUFFER.\" ) 
    end if
    return rcv
  end if  

  if typeof(@c) == \"list\" then 
    for d in c
      print \"<u>\"+colorWhite+\"ndx\"+colorLightBlue+\":\"+colorWhite+\"element\"
      print \"[\"+colorWhite+c.indexOf(d)+CT+\"]\"+colorWhite+\":\"+CT+\"[\"+d+\"]\"
    end for
    print colorLightBlue+\"[\"+colorWhite+\"1</color>]</b> enumerate \"+colorLightBlue+\"[\"+colorWhite+\"2</color>]</b> to custom_object \"+colorLightBlue+\"[\"+colorWhite+\"3</color>]</b> buffer selection\"
    print colorLightBlue+\"[\"+colorWhite+\"a</color>]</b> to clipa \"+colorLightBlue+\"[\"+colorWhite+\"b</color>]</b> to clipb \"+colorLightBlue+\"[\"+colorWhite+\"c</color>]</b> to clipc\"
    choice = user_input(\"||: \",0,1)
    if choice == \"1\" then print command.enum(c)
    if choice == \"2\" then 
      set_key = user_input(\"set_key (<b>enter</b>=quit):> \")
      if set_key == \"\" then print \"aborting...\"
      print command.cob(\"set\", set_key, c)
    end if
    if choice == \"3\" then 
      getthis = user_input(\"select an index:> \").to_int
      if getthis < c.len and getthis >= 0 then  
        print \"sending element to \"+colorOrange+\"BUFFER...\"
        globals.BUFFER.push(c[getthis])
      else
        print \"invalid index. aborting...\"
      end if
    end if
    if choice == \"a\" then command.clipa(c)
    if choice == \"b\" then command.clipb(c)
    if choice == \"c\" then command.clipc(c)
    return 0
  end if
  for d in @c
    print(d+char(10))
  end for
  return 0
end function

globals.p_exe = function( obj, f_name=null ) // obj is either game object or function
  if DEBUG then print(\"debug: In P_EXE: \"+@obj+\": \"+f_name)
  if typeof(@obj) != \"function\" and not p_validate(obj, f_name) then 
    print \"invalid object\"
    return 0
  end if    
  if typeof(@obj) == \"function\" then 
    foo = @obj 
  else 
    if f_name then foo = @obj[f_name] else return \"p_exe: missing function name\"
  end if
  args = str(@foo).split( \"FUNCTION\" )[1].split(\", \")
  if DEBUG then print \"debug: args input: \"+args
  if args.len == 1 then 
    if args == [\"()\"] then args[0] = []
  end if
  if not f_name then f_name = str(@foo).split( \"FUNCTION\" )[0]
  a=[]
  i=0
  for ar in args 
    if ar == null or ar == [] then continue
    ar = ar.replace(\"\\)\",\"\").replace(\"\\(\",\"\")
    if DEBUG then print \"debug: ar: \"+ar
    if ar == \"\" then continue
    if DEBUG then print(\"typeof \"+ar+\": \"+typeof(ar))
    if str(ar) == \"self\" then 
      if typeof(@obj) == \"function\" then 
        self_param = user_input(\"Use @a|@b|@c to use an object from the clipboard, (q=quit)\"+char(10)+colorLightBlue+\"Supply argument for: \"+colorWhite+ ar +CT+char(10)+\"</b>:> \")
        if typeof(self_param) == \"string\" then 
          print \"error: expected object, got string\"
          return 0
        end if 
        a.push(self_param)
        continue
      end if
      a.push(obj)
      continue 
    end if
    def = ar.split(\"=\")
    def_act=\"\"\"\"
    if def.len > 1 then def = def[0] else def = 0
    if def then 
      print \"<b>code: the following argument may not be omitted</b>\"
      def_act = \"quit\"
    end if
    inp = user_input(\"(Use @a|@b|@c for the clipboard\"+char(10)+\"-- ints are cast as ints, use 'int' to cast as string\"+char(10)+\"<b>enter=\"+def_act+\"</b>, null=null,  q=quit)\"+char(10)+colorLightBlue+\"Supply argument for: \"+colorWhite+ ar +CT+char(10)+\"</b>:> \")
    if inp == \"q\" then return \"aborting...\"
    if inp == \"\" or inp == \" \" then
      if def then inp = def else return \"code: invalid input: this argument cannot be blank\"
    end if
    if inp == \"null\" then inp = null
    if inp == \"@a\" or inp == \"@clipa\" then inp = @globals.clip_board_alpha
    if inp == \"@b\" or inp == \"@clipb\" then inp = @globals.clip_board_beta
    if inp == \"@c\" or inp == \"@clipc\" then inp = @globals.clip_board_gamma
    tint = inp.remove(\"'\")
    if typeof(inp) == \"string\" and typeof(inp.to_int) == \"number\" then inp = inp.to_int // assume integers are to be cast as integers
    if typeof(tint).to_int == \"number\" then inp = tint // if it's wrapped in ' then it's a string
    if DEBUG then print \"debug: p_exe_: input is \"+@inp+\" and is a \"+typeof(@inp)
    a.push(@inp)
    i = i + 1
  end for 
  if DEBUG then print \"obj is: \"+@obj+\" and is a: \"+typeof(@obj)
  if DEBUG then print \"f_name is: \"+f_name
  if typeof(@obj) == \"function\" then o = @obj else o = @obj[f_name]
  catch = null
  if args == [[]] then args = []
  if DEBUG then print(\"debug: args to run: \"+args.len+\": \"+args)
  if args.len == 0 then catch = o
  if args.len == 1 then catch = o(a[0])
  if args.len == 2 then catch = o(a[0], a[1])
  if args.len == 3 then catch = o(a[0], a[1], a[2])
  if args.len == 4 then catch = o(a[0], a[1], a[2], a[3])
  if args.len == 5 then catch = o(a[0], a[1], a[2], a[3], a[4])
  if args.len == 6 then catch = o(a[0], a[1], a[2], a[3], a[4], a[5])
  if DEBUG then print \"p_exe: catch: \"+catch
  return catch // if args > 6 then git rekt
end function

p_validate = function( object, query )
  if DEBUG then print \"DEBUG: in p_validate\"+char(10)+\"validating: \"+@object
  if typeof(@object) == \"function\" then return 1
  if typeof(@object) == \"number\" then return 1
  test = new object 
  if test == null then return 0
  if @object.hasIndex(\"__isa\") and typeof(@object) != \"string\" then
    if DEBUG then print \"__isa index found...\"
    locals.catch = @object.__isa.hasIndex(query)
    if DEBUG then print \"result: \"+locals.catch
	  return locals.catch // does the object have the index we seek?
  else 
    return 0
  end if
end function 

globals.fexecute = function(funciton_ref,args)
  print \"fexecute: <mark=yellow># <color=white>#</color> executing # <color=white>#</color> </mark>\"
  if typeof(@funciton_ref) == \"function\" then 
    return function_ref 
  else 
    print \"fexecute: invalid input\"
  end if
  return 0
end function


///////// BEGIN SWITCH
// Usage:
// switch(variable)
// 	case( condition, @action )
//  case( condition, @action )
//  case(...)
// default( @action )
// returns: result of action

_switch = {}
_switch.var = \"\"
_switch.set_var = function( input )
	_switch.var = input
end function
_switch.case_list = []
_switch.case = function( condition, action )
	_switch.case_list.push( {condition:@action} )
end function
_switch.default = function( action )
	// evaluate switch
	if _switch.case_list.len > 0 then
		for line in _switch.case_list
			if line.hasIndex(_switch.var) then 
				s = @line[_switch.var]
				_switch.var = \"\"
				_switch.case_list = []
				return s
			end if
		end for
		_switch.var = \"\"
		_switch.case_list = []
		return action
	end if
end function
globals.switch = @_switch.set_var
globals.case = @_switch.case
globals.default = @_switch.default
///////////// END SWITCH
if DEBUG then print(\"<size=75%>loaded _switch engine...</size>\")

globals.get_binaries = function(source_shell,dest_folder)
  // verify dest_folder exists
  if not dest_folder or typeof(dest_folder) != \"file\" then return \"error: destination folder does not exist!\"
  // get source_shell home folder
  s_home = source_shell.host_computer.File(\"/home\")
  if not s_home then return \"error: target /home does not exist!\"
  // find all non-folder binaries except police/student/employees viewer and traffic viewer
  bin_buf = []
  tcatch = command.tree(\"-f\",source_shell) // results are sent to globals.enumerated
  if tcatch == \"tree: invalid path or file\" then return tcatch
  if DEBUG then print \"debug: enum: \"+char(10)+globals.enumerated
  print colorCyan+\"Fetching readable binaries...\"
  for f in globals.enumerated
    if f.is_binary and not f.is_folder and f.has_permission(\"r\") and f.parent.parent.path == \"/home\" then bin_buf.push(f)
    // or exclude certain files:
    // is_blacklisted = function(name)
    //    if name == \"StudentViewer.exe\" then return 1
    //    if name == \"EmployeeViewr.exe\" then return 1
    //    if name == \".....\" then return 1
    // end function
    // if not is_blacklisted(f.name) and if f.is_binary and not f.is_folder and f.has_permission(\"r\") then bin_buf.push(f)
  end for
  if DEBUG then print \"debug: in get_binaries: bin_buf is\"+char(10)+bin_buf
  // find system.log 
  print colorCyan+\"</b>Fetching system.log if readable...\"
  sysl = source_shell.host_computer.File(\"/var/system.log\")
  if not sysl then 
    print colorOrange+\"/var/system.log not found!\"
  else 
    if sysl.has_permission(\"r\") then bin_buf.push(sysl)
  end if
  // scp download all files to dest folder of active shell
  // -- warn if glasspool is active
  if globals.GLASSPOOL then print colorOrange+\"Warning: Glasspool is active:\"+char(10)+colorOrange+\"Files will be written to the glasspooled machine.\"
  for entry in bin_buf
    if typeof(entry) == \"file\" then source_file = entry.path else continue
    if DEBUG then print \"debug: source_file is: \"+source_file+\":\"+typeof(source_file)
    print command.scpm(\"-d\",source_file,dest_folder,source_shell)
  end for
  return colorCyan+\"Binaries Fetched.\"+char(10)+colorGreen+\"kore\"+CT+\": recommendation: secure yourself with:\"+char(10)+\"<b>lock | usr -r root / | grp -r root /</b> (or <b>kore -s</b>)\"
end function

// not yet used
globals.trythis = function(function_reference, function_name)
  try = get_custom_object
  try.fn = \"\"
  try.success = false
  try.this = function( input_function, function_name=\"anon\" ) // (function_reference, string)
    self.fn = function_name
    self[self.fn] = @input_function
    self.write( self.fn )
    self.success = false
    return self.evalute( self.fn ) // returns true if function ran or false if function crashed
  end function
  try.write = function( f_name )
    f_name = f_name+\".src\"
    comp = get_shell.host_computer
    comp.touch( current_path, f_name )
    outfile = comp.File( f_name )
    output = []
    output.push( \"try=get_custom_object\" )
    output.push( \"f = @try[try.fn]\" ) 
    output.push( \"f\" )                // if it crashes here, success remains false as it returns to the launching script
    output.push( \"try.success = true\" ) // if it makes it to here, we didn't crash, so success is true!
    print outfile.set_content( output.join(char(10)) )
    print get_shell.build(current_path+\"/\"+f_name, current_path, 0)
    return 0
  end function
  try.evaluate = function( fname )
    globals.stack_pool(\"up\")
    get_shell.launch( fname )
    _cascade // exit if cascade
    globals.stack_pool(\"down\")
    return self.success
  end function

  return try.this(@function_reference, function_name)
end function 

globals.rsi_purge = function()
  rshells = metaxploit.rshell_server
  if(typeof(rshells) == \"string\") then return(rshells)	
  for r in rshells
    print colorLightBlue+\"rsi: kill ALL >> \"+colorWhite+r.host_computer.public_ip+ \" @ \"+r.host_computer.local_ip
    processes = r.host_computer.show_procs.split(char(10))
    for p in processes
      if p == \"USER PID CPU MEM COMMAND\" then continue
      process = p.split(\" \")
      process_ID = process[1]
      process_CMD = process[4]
      print \"Killing: \"+process_CMD+\" ID: \"+process_ID
      print r.host_computer.close_program(process_ID.to_int)
    end for
  end for
  return 0
end function

globals.netdump = function()
  if not p_validate(globals.net_session, \"get_num_conn_gateway\") then return 1
  print(colorLightBlue+\"</b>    [-] Gateway_connections:   [\"+globals.net_session.get_num_conn_gateway+\"]\")
  print(colorLightBlue+\"</b>    [-] Port_forwards:    [\"+globals.net_session.get_num_portforward+\"]\")
  print(colorLightBlue+\"</b>    [-] Registered users: [\"+globals.net_session.get_num_users+\"]\")
  if globals.net_session.is_any_active_user == true then print(colorLightBlue +\"</b>    [-] A user is active.\") else print(colorLightBlue+\"</b>    [-] No active user.\")
  if globals.net_session.is_root_active_user == true then print(colorLightBlue+\"</b>    [-] Root is active.\") else print(colorLightBlue  +\"</b>    [-] Root is inactive.\")
  return 0
end function

fw_rules = function()
  print(get_router(targetIP).firewall_rules)
end function

// takes object, returns file object or string; sends file object and string to buffer
curl = function(hacked_thing) 
  html = null
  html_content = null
  print(colorWhite+\"<size=50%><u>curl GET #?object?:/Public/htdocs/website.html...</u></size>\"+CT)
  if typeof(hacked_thing) == \"shell\" then html = hacked_thing.host_computer.File(\"/Public/htdocs/website.html\")
  if typeof(hacked_thing) == \"computer\" then html = hacked_thing.File(\"/Public/htdocs/website.html\")
  if typeof(hacked_thing) == \"file\" then
    while hacked_thing.name != \"/\"
      hacked_thing = hacked_thing.parent
    end while
    folders = hacked_thing.get_folders
    for f in folders
      if f.name == \"Public\" then
        sub_f = f.get_folders
        for s_f in sub_f
          if s_f.name == \"htdocs\" then
            files = s_f.get_files
            for sub_file in files
              if sub_file.name == \"website.html\" then html = sub_file
            end for
          end if
        end for
      end if
    end for
  end if
  if not html then return \"curl: failed to GET website.html\"
  globals.BUFFER.push(html)
  print(\"curl:<b> \"+html.path+\" added to BUFFER</b>\")
  if html.has_permission(\"r\") then html_content = html.get_content.split(char(10))
  if html_content then 
    colorWhite+\"- - - \"+colorLightBlue+\"</b>Displaying Raw HTML</b></color> - - -\"
    for ln in html_content
      print \"<noparse>\"+ln 
    end for
    print colorWhite+\" - - - - - - - - - - - - - - - - - - \"
    globals.BUFFER.push(html_content.join(char(10)))
    print colorOrange+\"curl: added website.html contents to BUFFER\"
    return html 
  else 
    return \"curl: cannot read website.html; check permissions\"
  end if
end function

secure_copy = function(shl,copy_to=0,trajectory=-1,skip_perms=0) 
  glass_stat = \"inactive\"
  active_s = colorCyan+\"</b>\"+localmachine.local_ip+\" @ <b>\"+localmachine.public_ip+CT
  target_s = colorOrange+\"pshell\"+CT
  if p_validate(shl, \"host_computer\") then
    target_s = colorOrange+\"</b>\"+shl.host_computer.local_ip+\" @ <b>\"+shl.host_computer.public_ip+CT
    if shl.host_computer.local_ip == localmachine.local_ip and shl.host_computer.public_ip == localmachine.public_ip then active_s = colorOrange+\"</b>\"+localmachine.local_ip+\" @ <b>\"+localmachine.public_ip+CT
  end if
  if globals.GLASSPOOL then glass_stat = \"active\"
  print(char(10)+colorLightBlue+\"<u>GLASSPOOL: \"+CT+colorOrange+glass_stat+CT+\"<b> Active Shell</b>: \"+active_s+\"</u>\")
  print(colorWhite+\"Upload|Push trajectory: \"+CT+char(10)+active_s+\"--->\"+target_s)
  print(colorWhite+\"Dnload|Pull trajectory: \"+CT+char(10)+target_s+\"--->\"+active_s)
  print(colorWhite+\"---scp---------------\"+CT)
  copy_from = null
  //use_it = \"n\"
  if DEBUG then print \"debug: in secure_copy: tagged4scp: \"+globals.tagged_for_scp
  if globals.tagged_for_scp != \"\" and globals.tagged_for_scp != null then copy_from = globals.tagged_for_scp
  //if copy_from then use_it = user_input(\"Copy from: \"+copy_from+\"? [Y/n]\"+char(10)+\"||: \",0,1).lower
  if copy_from then print \"Copying from: \"+copy_from else copy_from = user_input(\"Full path to copy from:>  \")
  //if use_it == \"n\" then copy_from = user_input(\"Full path to copy from: \")
  if copy_from == \"\" or copy_from == \" \" then return colorOrange+\"scp: invalid copy_from path\"
  if not copy_to then copy_to = user_input(\"Destination folder:> \")
  if copy_to == \"\" or copy_to == \" \" then return colorOrange+\"scp: invalid destination path\"
  if trajectory >= 0 then udp = str(trajectory) else udp = user_input(\"[0] upload [1] download\"+char(10)+\"(q=quit)|| : \",0,1)
  if DEBUG then print \"debug: udp is \"+udp+\" and is a \"+typeof(udp)
  if udp == \"q\" then return
  if udp == \"1\" then
    if typeof(shl) == \"shell\" or typeof(shl) == \"ftpshell\" or typeof(shl) == \"pshell\" then
      targ_f = shl.host_computer.File(copy_from)
      if targ_f then
        print(\"scp: pulling \"+targ_f.path+\" from \"+shl.host_computer.local_ip+\" @ \"+shl.host_computer.public_ip)
      else
        return colorOrange+\"scp-download: \"+copy_from +\" not found\"
      end if
      if not targ_f.has_permission(\"r\") then return \"scp: copy permission denied\"
      if typeof(shl) == \"shell\" then return shl.scp(copy_from, copy_to, globals.shell) ///////// copying
      if typeof(shl) == \"ftpshell\" then return colorRed+\"</b>scp: error; a game bug prevents ftpshell.put from functioning\"//shl.put(copy_from, copy_to, globals.shell) ///////// copying
      if typeof(shl) == \"pshell\" and p_validate(shl,\"scp\") then return shl.scp(copy_from, copy_to, globals.shell) ///////// copying
      return \"aborting...\"
    end if
  else
    if udp == \"0\" then
      if typeof(globals.shell) == \"shell\" then
        payload = globals.get_file(copy_from)
        if not payload then
          return colorOrange+\"scp-upload: \"+copy_from+\" not found\"
        end if
        print(char(10)+\"Found: \"+payload.path + \" \" + payload.size + \" \" + payload.permissions+char(10))
        print(\"<b>edit permissions</b>? (default: yes)\")
        if skip_perms then mod = \"1\" else mod = user_input(\"[<b>0</b>] yes [1] no (q=quit)||: \",0,1)
        if mod.lower == \"q\" then return \"aborting...\"
        if mod != \"1\" then
          print(\"e.g. o+rwx g-rwx u+x (string all edits on one line separated by spaces)\")
          ed_in = user_input(\"params for [perms/chmod -r] (default:<b> o+rwx </b>, q=quit)\"+char(10)+\":> \")
          if ed_in.lower == \"q\" then return \"aborting...\"
          if ed_in == \"\" then ed_in = [\"o+rwx\"] else ed_in = ed_in.split(\" \")
          for ed in ed_in
            catch = command.perms(\"-r\", ed, copy_from)
            if catch then print catch
          end for
        end if
        if mod.lower == \"q\" then return \"aborting...\"
        print(char(10)+\"<b>Upload Ready: \"+payload.path + \" \" + payload.size + \" \" + payload.permissions+\"</b>\"+char(10))
        failed = false
        print(\"scp: pushing \"+payload.path+\" to \"+copy_to+\" @ \"+shl.host_computer.local_ip+\" : \"+shl.host_computer.public_ip)
        print(shell.scp(payload.path, copy_to, shl)) ///// copying
        if not shl.host_computer.File(copy_to+\"/\"+payload.name) then failed = true else globals.tagged_for_scp == \"\"
        if failed == true then print \"Upload failed... edit/restore permissions?\" else print(\"Upload complete... <b>edit/restore permissions</b>?\")
        if skip_perms then mod = \"1\" else mod = user_input(\"[<b>0</b>] yes [1] no ||: \",0,1)
        if mod != \"1\" then
          print(\"e.g. o+rwx g-rwx u+x (string all edits on one line separated by spaces)\")
          ed_in = user_input(\"params for [perms/chmod -r] (default:<b> o-rwx </b>, q=quit)\"+char(10)+\":> \")
          if ed_in.lower == \"q\" then return \"aborting...\"
          if ed_in == \"\" then ed_in = [\"o-rwx\"] else ed_in = ed_in.split(\" \")
          for ed in ed_in
            catch = command.perms(\"-r\", ed, payload.path)
            if catch then print catch
          end for
        end if
        if failed then return \"scp: failed\" else return \"scp complete: \"+payload.path + \" \" + payload.size + \" \" + payload.permissions+char(10)+\"-- copied to: \"+copy_to+\"/\"+payload.name
      else
        if typeof(globals.shell) == \"ftpshell\" then print colorRed+\"</b>scp: error; a game bug prevents ftpshell.put from working\"+char(10)+\"-- aborting...\" else print \"aborting...\" //print(shell.put(copy_from, copy_to, shl)) else return \"aborting...\" ///// copying
        return \"scp complete: \"+payload.path + \" \" + payload.size + \" \" + payload.permissions+char(10)+\"-- copied to: \"+copy_to+\"/\"+payload.name
      end if
    end if
  end if
end function

////////////////////////BEGIN AIR MENU///////////////
air_menu = function()
  command.air
  return 0
end function
/////////////////////////////////////END AMU//////////

//// Scribus
scribus = function(f_obj)

  print(\"\\nScribus v 0.2.9 by Plu70\\n//////////////////////\\n(@h on newline for help)\\n\")

  print_help = function()
    print
    print(\"Enter new lines of text (or commands) when numbered prompt is visible. eg:<b> 1: @h </b>\")
    print(\"Enter @ on a new line to save and quit (@@ to exit without saving)\")
    print(\"Enter all @x commands on a new line.\")
    print(\"@l - list lines (with line numbers)\")
    print(\"@L - list lines (without line numbers)\")
    print(\"@s - search for text (word, string, single char), returns all matches\")
    print(\"@d - delete line (closes gap)\")
    print(\"@r - replace line with new text\")
    print(\"@i - insert new line below a given line \")
    print(\"@I - insert a new line above given line \")
    print(\"@c - clear the buffer (deletes all text)\")
    print(\"@C - clear the screen (run clear_screen)\")
    print(\"@t - trim whitespace from the buffer\")
    print(\"@n - display buffer without parsing richtext or markup\")
    print(\"@N - as above, but without line numbers\")
    print(\"@h - show this help file\")
    print(\"@@ - abort and quit\")
    print
  end function

  got_file = false
  got_list = false
  editing = true
  //old_array = f_obj.get_content.split(char(10)) //.split(\"\\n\")
  array = f_obj
  if typeof(array) == \"list\" then
    array = f_obj[0:]
    got_list = true
  end if
  if typeof(array) == \"file\" then
    if array.is_binary or not array.has_permission(\"r\") then return \"Scribus: cannot open binary file.\"
    array = f_obj.get_content//.replace(\"\\n\", \"<b>@^nl</b>\")
    got_file = true
  end if
  if typeof(array) == \"string\" then array = array.split(char(10))
  if typeof(array) != \"list\" then return \"Scribus: invalid type: \"+typeof(array)
  i = 0
  if array == [\"\"] or array == 0 then array = []
  for l in array
    print(i+\": \"+l)
    i = i + 1
  end for
  while editing
    line_num = array.len
    buf = user_input(line_num+\": \")
    //buf.replace(\"\\n\",\"\")
    if buf.len == 2 and buf[0] == \"@\" and buf[1] == \"h\" then
      print_help ////////////////HELP
      continue
    end if
    if buf.len == 2 and buf[0] == \"@\" and buf[1] == \"@\" then return 0
    if buf == \"@\" and buf.len == 1 then       ///////////////////////EXIT
      editing = false
      continue
    else
      if buf.len == 2 and buf[0] == \"@\" then
        if buf[1] == \"r\" then             //////////////////////REPLACE LINE
          num_lines = array.len - 1
          i = 0
          print
          for l in array
            print(i+\": \"+l)
            i = i + 1
          end for
          line = user_input(\"Line to replace (0 to \" + num_lines + \")\\n&: \").val
          if line >= 0 and line < array.len then
            print(\"#: \"+array[line])
            replacement_text = user_input(\"&: \")
            array[line] = replacement_text
            i = 0
            print
            for l in array
              print(i+\": \"+l)
              i = i + 1
            end for
            continue
          else
            print(\"Line \"+line+\" doesn't exist.\")
            continue
          end if
        else
          if buf[1] == \"l\" then      ///////////////////////LIST LINES
            i = 0
            print
            for l in array
              print(i+\": \"+l)
              //if i != 0 then print(i+\": \"+l)
              i = i + 1
            end for
            continue
          else
            if buf[1] == \"s\" then     ////////////////////////SEARCH
              find = user_input(\"Search for string\\n*: \")
              temp = array
              i = 0
              for ln in temp
                if ln == find then print(\"Found: \"+find+\" on line \"+i+\"\\n#: \"+ln)
                for word in ln.split(\" \")
                  if word == find then print(\"Found: \"+find+\" on line \"+i+\"\\n#: \"+ln)
                end for
                i = i + 1
              end for
              continue
            else
              if buf[1] == \"d\" then    //////////////////////DELETE
                i = 0
                print
                for l in array
                  print(i+\": \"+l)
                  i = i + 1
                end for
                num_lines = array.len
                if num_lines < 1 then
                  print(\"No lines to delete.\")
                  continue
                end if
                d_line = user_input(\"Line to delete (0 to \" + (num_lines-1) + \")\\n!: \").to_int
                if d_line >= 0 and d_line < array.len then
                  print(\"Deleting... \"+array[d_line])
                  array.remove(d_line)
                  i = 0
                  print
                  for l in array
                    print(i+\": \"+l)
                    i = i + 1
                  end for
                  continue
                else
                  print(\"Line \"+d_line+\" doesn't exist.\")
                  continue
                end if
              else
                if buf[1] == \"i\" or buf[1] == \"I\" then  ///////////////////INSERT
                  temp = []
                  i = 0
                  print
                  for l in array
                    print(i+\": \"+l)
                    i = i + 1
                  end for
                  num_lines = array.len
                  if num_lines < 1 then
                    print(\"buffer is empty.\")
                    continue
                  end if
                  if buf[1] == \"i\" then // insert after
                    i_line = user_input(\"Insert text after which line? (0 to \" + (num_lines - 1) + \")\\n%: \").to_int
                    if i_line >= 0 and i_line < array.len then
                      i_text = user_input(\"Text to insert after line: \"+i_line+\"\\n%: \")
                      for r in range(0,i_line)
                        temp.push(array[r])
                      end for
                      temp.push(i_text)
                      for a in range(i_line,array.len-1)
                        if a > i_line then temp.push(array[a])
                      end for
                      array = temp
                      i = 0
                      print
                      for l in array
                        print(i+\": \"+l)
                        i = i + 1
                      end for
                      continue
                    else
                      print(\"Line \"+i_line+\" doesn't exist.\")
                      continue
                    end if
                  else             // insert before
                    i_line = user_input(\"Insert text before which line? (0 to \" + (num_lines - 1) + \")\\n%: \").to_int
                    if i_line >= 0 and i_line < array.len then 
                      i_text = user_input(\"Text to insert before line: \"+i_line+\"\\n%: \")
                      if i_line == 0 then 
                       temp = [i_text]+array 
                      else 
                        temp = array[0:i_line]
                        temp.push(i_text)
                        temp = temp + array[i_line:]
                      end if 
                      array = temp
                      i = 0
                      print
                      for l in array
                        print(i+\": \"+l)
                        i = i + 1
                      end for
                      continue
                    else 
                      print(\"Line \"+i_line+\" doesn't exist.\")
                      continue
                    end if
                  end if
                else
                  if buf[1] == \"c\" then ///////////CLEAR
                    print(\"Really clear the buffer? [y/N]\")
                     confirm = user_input(\"!: \")
                    if confirm.lower == \"y\" then
                      array = []
                      print(\"Buffer cleared. \")
                      continue
                    end if
                    print(\"aborting...\")
                    continue
                  else
                    if buf[1] == \"C\" then /////////CLEAR_SCREEN
                      clear_screen
                      continue
                    else
                      if buf[1] == \"L\" then //////////List lines no numbers
                        print
                        for l in array
                          print(l)
                        end for
                        continue
                      else 
                        if buf[1] == \"t\" then ////////Trim whitespace
                          t_array = []
                          for line in array 
                            t_array.push(line.trim)
                          end for
                          array = t_array 
                          i = 0
                          print
                          for l in array
                            print(i+\": \"+l)
                            i = i + 1
                          end for
                          continue 
                        else 
                          if buf[1] == \"n\" then 
                            i = 0
                            print
                            for l in array
                              print(i+\": \"+\"<noparse>\"+l)
                              i = i + 1
                            end for
                            continue
                          else 
                            if buf[1] == \"N\" then 
                              print
                              for l in array 
                                print \"<noparse>\"+l 
                              end for 
                              continue 
                            end if
                          end if
                        end if
                      end if
                    end if
                  end if
                end if
              end if
            end if
          end if
        end if
      end if
    end if
    array.push(buf)  //print(\"Found: \"+find+\" on line \"+i+\"\\n#: \"+ln)
  end while
  //if got_list then
  //  new_array = array
  //else
    new_array = array.join(char(10))
  //end if
  if got_file then
    f_obj.set_content(new_array)//.replace(\"<b>@^nl</b>\", \"\"\"+char(10)+\"\"\"))
    //print(char(10)+f_obj.get_content)
    return f_obj.get_content
  end if
  return new_array // returns a string
end function
/////////////////////////////////////// END Scribus ///////////////////////////////

////////////// BEGIN_MEMORY_ALPHA //////////////////////////////
globals.memory_alpha = function(go_to_buffer=false,go_to_selection=false)
  buffered_filesys = null
  viewing = true
  print(colorWhite + \"5phinx\"+char(8482)+\" v \" + sphinx_version + \", Memory_Alpha v \"+malp_version+\" by Plu70\"  + CT )
  print(\"<b>//////////////////////////////////////////////</b>\")
  if metaxploit then print(colorWhite + \"MetaXploit.so v \" + metaLibVersion + \" // \" + \"Crypto.so v \" + cryptoLibVersion + CT)
  print
  while viewing
    print(colorWhite + \"5phinx\"+char(8482)+\" v \" + sphinx_version + \", Memory_Alpha v \"+malp_version+\" by Plu70\"  + CT )
    print(\"<b>/////////////////////////////////////////////</b>\")
    if metaxploit then print(colorWhite + \"MetaXploit.so v \" + metaLibVersion + \" // \" + \"Crypto.so v \" + cryptoLibVersion + CT)
    print
    print
    if PORT_MAP then print(colorLightBlue+\"[0] Portmap Loaded. \"+CT)
    if XPLOITS then print(colorLightBlue+\"[1] XPLOITS loaded: [\"+NUM_SPLOITS+\"] \"+CT)
    if metaLib then
      linked = \"MetaLib\"
      if globals.net_session then linked = \"Netsession\"
      print(colorLightBlue+\"[2] \"+linked+\" linked to: \"+ metaLib.lib_name + \" v \" + metaLib.version+CT)
      if meta_scan then
        print(colorLightBlue+\"</b>    [+] MetaLib source decompiled.\"+CT)
      end if
      if globals.net_session then netdump
    end if
    if MEMORY or XPLOITS.len or PORT_MAP then print(colorLightBlue+\"[3] Dump Memory \"+CT)
    print(colorLightBlue+\"[4] File manager. \")
    if BUFFER.len > 0 then print(colorOrange+\"</b>+[5] [Storing: \"+BUFFER.len+\" buffer objects]\"+CT)
    print(\"[6] Air [/] cBios [-] RSI [.] dBase\" )
    print(\"[7] Go Back   [8] Procs   [9] Kill  \")
    if DEBUG then print(\"prompt ready: \")
    if go_to_buffer == true then
      waitFor = \"5\"
      go_to_buffer = false
    else 
      waitFor = user_input(\"(q=quit)||: \",0,1)
    end if
    print(colorWhite + \"5phinx\"+char(8482)+\" v \" + sphinx_version + \", Memory_Alpha v \"+malp_version+\" by Plu70\"  + CT )
    print(\"<b>/////////////////////////////////////////////</b>\")
    if metaxploit then print(colorWhite + \"MetaXploit.so v \" + metaLibVersion + \" // \" + \"Crypto.so v \" + cryptoLibVersion + CT)
    print
    if waitFor == \".\" then
      globals.grepped_file = null
      dBase = command.tree(\"/\",\"database.csv\",1,\"N\")
      if not dBase then
        print(\"/root/rkit/database.csv not found\")
        continue
      end if
      dBase_contents = \"\"
      if dBase.has_permission(\"r\") then dBase_contents = dBase.get_content.split(char(10)) else dBase_contents = \"/root/rkit/database.csv: permission denied\"
      dbi = 0
      i = 0
      link_list = []
      print_list = []
      for line in dBase_contents
        if line.indexOf(\"Hooked:\") == null then
          print_list.push(\"[\"+colorWhite+dbi+CT+\"] - \"+line + \" on line: \"+i)
          link_list.push(line)
          dbi = dbi + 1
        end if
        i = i + 1
      end for
      print(format_columns(print_list.join(char(10))))
      if dBase_contents.len > 1 then
        link = user_input(\"link_db (q=quit):> \",0,0).to_int   // add db editing functions
        if link == \"q\" then continue
        if typeof(link) == \"number\" and link >= 0 and link < dbi then
          command.linkdb(link_list[link])
          print(colorOrange+\"Purging meta_scan...\"+CT)
          globals.meta_scan = []
          print(\"<b><size=75%>if database loaded you may review with [1] </b></size>\")
        end if
        continue
      else
        print(\"No data to load.\")
      end if
    end if
    if waitFor == \"-\" then
      command.rsi(0)
      continue
    end if
    if waitFor == \"/\" then
      print( command.bios )
      continue
    end if
    if waitFor == \"0\" then
      display_portmap
      continue
    end if

    if waitFor == \"1\" then
      // data = \"\"
      // i = 1
      // for x in XPLOITS
      //   data =  data + \"[\" + i + \"]\" + x + \"\\n\"
      //   i = i + 1
      // end for
      // print(format_columns(data))
      // for m in meta_scan
      //   //print(m)
      //   for n in m
      //     print(n)
      //   end for
      // end for
      data = []
      i = 1
      scanned = [\"decompiling source..\"]
      if globals.meta_scan then 
        for m in globals.meta_scan 
          for n in m
            if DEBUG then print(n)
            if n.indexOf(\"searching unsecure values...\") >= 0 or n.indexOf(\"decompiling source...\") >= 0 then continue
            scanned.push(n)
          end for
        end for 
      end if
      for x in globals.XPLOITS
        data.push(\"[\" +colorWhite+ i +CT+ \"]\"+colorLightBlue+ x+CT)
        if globals.meta_scan then data.push(scanned[i])
        i = i + 1
      end for
      print(data.join(char(10)))
      continue
    end if

    // if waitFor == \"+\" then
    //   for m in metaLib
    //     print(m)
    //     for n in m
    //       print(n)
    //       for o in n
    //         print(o)
    //         for p in o
    //           print(p)
    //         end for
    //       end for
    //     end for
    //   end for
    //   continue
    // end if

    if waitFor == \"2\" then
      print(\"<u>=======</u>\")
      if meta_scan then
        //for m in meta_scan
         // print(m)
          // for n in m
          //   print(n)
          // end for
        //end for
        print \"<noparse>\"+command.code(meta_scan,0,0,0)
      else
        if globals.metaLib then conf = user_input(\"Scan metaLib for vuln requirements? [Y/n] ||: \",0,1) else continue
        if conf.lower != \"n\" then 
          print(colorGold+\"<mark=red>decompiling...</mark>\"+CT)
          scan_memory
          print(\"Source decompiled. Please select <b>[1]</b> to view.\")
        end if
      end if
      continue
    end if

    if waitFor == \"3\" then
      dump_memory
    end if
    if waitFor == \"4\" then
      print(\"[0] go back [1] tree: buffered_fs [2] felix: buffered_fs \")
      f_mgr = user_input(\"(q=quit)||: \",0,1)
      if f_mgr == \"0\" or f_mgr ==  \"q\" then continue
      if f_mgr == \"2\" then
        if buffered_filesys then
          command.felix(buffered_filesys)
          continue
        else
          print(\"No buffered filesystems. \")
        end if
        continue
      end if
      if f_mgr != \"1\" then continue
      input = user_input(\"Enter abs_<b>path</b> to expand (local) or leave blank (buffered_fs):> \")
      temp = null
      if input then
        temp = localmachine.File(input)
      else
        if buffered_filesys then
          temp = buffered_filesys
        end if
      end if
      if temp then
        list_files(temp)
        continue
      else
        print(\"No buffered filesystems. \")
        continue
      end if
    end if // end option 4
    /////////////////////////////////////////////////////////THE BIG BAD BUFFER PUFFER STUFFER//////////////////////////////////////////
    if waitFor == \"5\" then
      if BUFFER.len == 0 then
        print(colorOrange+\"\\nBuffer empty. \")
        continue
      end if
      print(\"\\nExpanding... \")
      print(colorWhite+\"__________________________________\")
      i = 0
      //b_list = globals.BUFFER[0:]
      if DEBUG then print(\"checking buffer integrity...\")
      for b in globals.BUFFER //b_list
        if DEBUG then print p_validate(@b,\"name\")
        if DEBUG then print \"b: \"+@b
        if typeof(@b) == \"file\" and not p_exe(@b,\"name\") then
          globals.BUFFER.remove(globals.BUFFER.indexOf(b))
          print(\"[<size=65%>malp: null file removed. skipping...</size>]\")
          continue
        end if
        /////////////////// BEGIN_BUFFER //////////////////////////////////////////////////
        //print(colorOrange+\"[\"+i+\"]</b>BUFFERED: \" + \"[\"+checkUser(b) +\":\"+ typeof(b)+\"]\")
        if typeof(@b) == \"function\" then
          print(colorOrange+\"[\"+i+\"]</b>BUFFERED: \" + \"[\"+checkUser(@b) +\":\"+ typeof(@b)+\"]\")
        else
          print(colorOrange+\"[\"+i+\"]</b>BUFFERED: \" + \"[\"+checkUser(b) +\":\"+ typeof(b)+\"]\")
        end if
        if typeof(@b) == \"file\" then print(b.path+char(10)+b.permissions+\" \"+b.owner+\" \"+b.group+\" \"+b.size+\" b[\"+b.is_binary+\"] \"+b.name)
        if typeof(@b) == \"computer\" then print(format_columns(b.show_procs+char(10)+b.public_ip+char(10)+b.local_ip))
        if typeof(@b) == \"shell\" or typeof(@b) == \"ftpshell\" then print(format_columns(b.host_computer.show_procs+char(10)+b.host_computer.public_ip+char(10)+b.host_computer.local_ip))
        if typeof(@b) == \"string\" or typeof(@b) == \"list\" or typeof(@b) == \"map\" then print( \"elements: \"+b.len )
        i = i + 1
      end for
      print(colorWhite+\"__________________________________\")
      selection = null
      if go_to_selection == true then selection = BUFFER.len-1 else selection = user_input(colorWhite+\"Select an object to access:> \"+CT).to_int
      go_to_selection = false
      if selection >= BUFFER.len or selection < 0 or typeof(selection) != \"number\" then continue
      if BUFFER.hasIndex(selection) and @BUFFER[selection] then
        buffer_selection = @BUFFER[selection]
        ////////////////////evaluate selection///////
        print(colorOrange+\"Expanding... \"+CT+\"[\"+colorWhite+typeof(@buffer_selection)+CT+\"]\")
        if typeof(@buffer_selection) == \"pshell\" or typeof(@buffer_selection) == \"pcomputer\" or typeof(@buffer_selection) == \"pfile\" or typeof(@buffer_selection) == \"prouter\" then 
          print(globals.decompiler(@buffer_selection))
          continue
        end if
        if typeof(@buffer_selection) == \"string\" or typeof(@buffer_selection) == \"list\" or typeof(@buffer_selection) == \"map\" or typeof(@buffer_selection) == \"number\" or typeof(@buffer_selection) == \"function\" then
          if typeof(@buffer_selection) == \"function\" then
            args = str(@buffer_selection).split( \"FUNCTION\" )[1].split(\", \")
            print(\"function takes: \"+args.len+\" arguments.\")
          end if
          if typeof(@buffer_selection) == \"string\" then 
            print buffer_selection
            print colorWhite+\"[\"+colorWhite+\"</b>1<color=green>|</color>d</color>]\"+CT+\" - Get Character Codes (decompiler)\"+char(10)+
            colorWhite+\"</b>[\"+colorWhite+\"</b>2<color=green>|</color>s</color>]\"+CT+\" - save to file\"+char(10)+
            colorWhite+\"</b>[\"+colorWhite+\"</b>3<color=green>|</color>e</color>]\"+CT+\" - edit with scribus\"+char(10)+
            colorWhite+\"[</b>\"+colorWhite+\"</b>4<color=green>|</color>a</color>\"+CT+colorWhite+\"</b>]\"+CT+\" - to clipa \"+colorWhite+\"</b>[\"+colorWhite+\"</b>5<color=green>|</color>b</color>\"+CT+colorWhite+\"</b>]\"+CT+\" - to clipb \"+colorWhite+\"</b>[\"+colorWhite+\"6<color=green>|</color>c</color>\"+CT+colorWhite+\"</b>]\"+CT+\" - to clipc\"
            do_this = user_input(\"(<b>enter</b>=quit)||: \",0,1)
            if do_this == \"a\" or do_this == \"4\" then print command.clipa(buffer_selection)
            if do_this == \"b\" or do_this == \"5\" then print command.clipb(buffer_selection)
            if do_this == \"c\" or do_this == \"6\" then print command.clipc(buffer_selection)
            if do_this == \"3\" or do_this == \"e\" then globals.BUFFER.push(globals.scribus(buffer_selection.split(char(10))))
            if do_this == \"2\" or do_this == \"s\" then  
              to_path = user_input(\"save_to_path (<b>enter</b>=abort):> \")
              if to_path == \"\" then continue
              print command.poke(to_path,buffer_selection)
              continue
            end if
            if do_this != \"1\" or do_this != \"d\" then continue
            chars = command.code(buffer_selection)
            print chars 
            globals.BUFFER.push(chars)
            continue 
          end if
          print(globals.decompiler(@buffer_selection))
          continue
        end if
        if typeof(@buffer_selection) == \"custom_object\" then
          print(globals.decompiler(@buffer_selection))
          continue
        end if
        if typeof(buffer_selection) == \"file\" then
          //decompiler(buffer_selection)
          //list_files(buffer_selection, \"0\")
          print(command.file(@buffer_selection))
          print(colorGreen+\"<u>==================================</u>\"+CT)
          print(\"[a] to clipa|b|c...\")
          print(\"[f] - felix file explorer [w] website.html (curl)\")
          print(\"[r] rename     [m] move   [c] copy\")
          if not buffer_selection.is_binary then print(\"[7] open text  [8] edit   [9] save text \")
          file_menu = user_input(\"[4] tag 4 scp  [5] rclean [6] spam \"+char(10)+\"[1] root file  [2] remove [3] perms\"+char(10)+\"[0] exit  [d] decompiler (q=quit)||: \",0,1 )
          if file_menu == \"a\" then
            print \"[\"+colorWhite+\"a\"+CT+\"] - to clipa, [\"+colorWhite+\"b\"+CT+\"] - to clipb, [\"+colorWhite+\"c\"+CT+\"] - to clipc\"
            tc = user_input(\"(<<b>enter</b>>=quit)||: \",0,1)
            if tc == \"a\" then print command.clipa(buffer_selection)
            if tc == \"b\" then print command.clipb(buffer_selection)
            if tc == \"c\" then print command.clipc(buffer_selection)
            continue
          end if
          if file_menu == \"w\" then 
            print globals.curl(buffer_selection)
            continue 
          end if
          if file_menu == \"r\" then 
            newname = user_input(\"Enter a new filename:> \").trim
            if newname == \"\" then print \"aborting...\" else print buffer_selection.move(buffer_selection.parent.path,newname)
            continue
          end if
          if file_menu == \"c\" or file_menu == \"m\" then 
            act = \"Copy\"
            if file_menu == \"m\" then act = \"Move\"
            new_path = user_input(act+\" file to this <b>folder</b> (<<b>enter></b>=abort):\"+char(10)+\":> \"+colorLightBlue)
            if new_path == \"\" or new_path == \" \" then 
              print \"aborting...\"
              continue 
            end if
            final_name = user_input(\"Enter a new <b>filename</b> or press enter to keep the current one:\"+char(10)+\":> \"+colorCyan+\"</b>\")
            if final_name == \"\" or final_name == \" \" then final_name = buffer_selection.name
            if act == \"Move\" then print buffer_selection.move(new_path,final_name) else print buffer_selection.copy(new_path,final_name)
            continue
          end if
          if file_menu == \"d\" then 
            print(globals.decompiler(@buffer_selection))
            continue
          end if
          if file_menu.lower == \"f\" then
            command.felix(@buffer_selection)
            continue
          end if
          if file_menu == \"4\" then
            globals.tagged_for_scp = buffer_selection.path
            print(\"Tagged: \"+globals.tagged_for_scp+\" for scp.\")
            continue
          end if
          if file_menu == \"9\" then
            if buffer_selection.is_binary then 
              print colorOrange+\"malp: cannot get contents of binary file\"
              continue
            end if
            down_to = user_input(\"save contents to: (leave blank to abort)\"+char(10)+\":> \")
            if down_to == \"\" or down_to == \" \" then continue
            print(command.poke(down_to))
            print(command.append(down_to,@buffer_selection.get_content))
            continue
          end if
          if file_menu == \"8\" and not @buffer_selection.is_binary then
            if buffer_selection.has_permission(\"w\") then
              print(@buffer_selection.path+\" is writable.\")
              if user_input(\"Edit with Scribus? [Y/n] ||: \",0,1).lower != \"n\" then command.scribus(@buffer_selection) else print(\"aborting...\")
              continue
            else
              print(\"error: file is write protected\")
              continue
            end if
          end if
          if file_menu == \"5\" then
            spoof = buffer_selection
            print command.rclean(spoof)
            continue
          end if
          if file_menu == \"6\" then 
            print colorCyan+\"</b>Create numbered copies of a file in a given directory\"+char(10)+
            \"-- usefule for annoying someone or degrading hardware\"
            copies = user_input(\"Enter a number of copies to spam: \"+char(10)+\":> \"+colorRed).to_int
            if typeof(copies) != \"number\" or copies < 1 then 
              print \"aborting...\"
            else 
              dest = user_input(\"Enter a <b>folder</b> to spam (<b>enter</b>=abort):\"+char(10)+\":> \"+colorRed)
              if dest.trim == \"\" then continue
              for i in range(1,copies) 
                print colorRed+\"Spamming: \"+colorWhite+dest+\"/\"+buffer_selection.name+i
                c = buffer_selection.copy(dest,buffer_selection.name+i)
                if c != 1 then 
                  print c
                  print colorRed+\"Error: write failed; aborting...\"
                  break 
                end if
              end for 
            end if
            print 
            continue 
          end if
          if file_menu == \"1\" then
            while buffer_selection.name != \"/\"
              buffer_selection = buffer_selection.parent
            end while
            globals.BUFFER.push(buffer_selection)
            print(\"file rooted to <b>\"+buffer_selection.name+\"</b> and pushed to BUFFER\")
            continue
          end if
          if file_menu == \"3\" then
            print \"<b>Modify permissions for this file?\"
            p = user_input(\"[0] back [1] unlock [2] lock \"+char(10)+\"(q=quit)||: \",0,1)
            if p == \"0\" or p == \"q\" then continue
            if p == \"1\" then
              try = buffer_selection.chmod(\"o+rwx\",1)
              try = buffer_selection.chmod(\"g+rwx\",1)
              try = buffer_selection.chmod(\"u+rwx\",1)
              if try == \"\" then print(\"Notice: \"+buffer_selection.name+\" <b>FULLY UNLOCKED</b>\") else print(try)
            end if
            if p == \"2\" then
              try = buffer_selection.chmod(\"o-rwx\",1)
              try = buffer_selection.chmod(\"g-rwx\",1)
              try = buffer_selection.chmod(\"u-rwx\",1)
              if try == \"\" then print(\"Notice: \"+buffer_selection.name+\" <b>FULLY LOCKED</b>\") else print(try)
              end if
            continue
          end if
          if file_menu == \"2\" then
            if user_input(\"Confirm delete \"+buffer_selection.path+\" [y/N] ||: \",0,1).lower != \"y\" then continue
            print(\"attempting to delete: \"+buffer_selection.path)
            try = buffer_selection.delete
            if try != \"\" then print(try) else print(\"deleted\")
            continue
          end if
          if file_menu == \"7\" then
            if not buffer_selection.is_binary then print(buffer_selection.get_content) else print(\"error: can't open binary file\")
            continue
          end if
          if file_menu == \"0\" or file_menu == \"q\" then
            print(\"<b>Filesystem buffered. Access with [4] </b>\")
            buffered_filesys = buffer_selection
            continue
          end if
          continue
        end if
        if typeof(buffer_selection) == \"computer\" then
          //decompiler(buffer_selection)
          hooked_comp(buffer_selection)
          //BUFFER.pop
          //buf_this = user_input(\"Enter path to buffer or press <<b>return</b>> for / \"+char(10)+\":> \")
          //if buf_this == \"\" then buf_this = \"/\"
          //buffered_filesys = buffer_selection.File(buf_this)
          //print(\"Buffered filesystem ready. Access with [<b>4</b>] \")
          continue
        end if
        ///////////////////// SHELL HANDLER ///////////////////////////
        if typeof(buffer_selection) == \"shell\" or typeof(buffer_selection) == \"ftpshell\" then
          shelling = true 
          notftp = true 
          if typeof(buffer_selection) == \"ftpshell\" then notftp = false
          while shelling == true
            print(colorOrange+\"<mark=orange><u>= = = = = = = = = = = = = = =</u></mark>\"+CT)
            print(format_columns(buffer_selection.host_computer.show_procs)+char(10)+char(10)+checkUser(buffer_selection)+\"@\"+buffer_selection.host_computer.local_ip+char(10)+buffer_selection.host_computer.public_ip)
            print(colorOrange+\"<size=65%><mark=orange><u>= = = = = = = = = = = = = = = = = = = =</u></mark></size>\"+CT)
            print   \"[f] felix  [c] curl       [p] purge from buffer\"
            if typeof(buffer_selection) == \"shell\" then 
              print \"[7] scp    [8] run        [9] fetch meta\" +char(10)+
                    \"[4] glassp [5] rclean     [6] get computer \"+char(10)+
                    \"[1] open   [2] redirect   [3] upload rkit\"
            end if                
                                 
            if typeof(buffer_selection) == \"ftpshell\" then 
              print \"[4] glassp [5] rclean     [6] get computer\"
              print \"[1] open   [2] scp/put    [3] upload rkit\"
            end if
            print   \"[0] to cob [d] decompile  [b] fetch binaries\"
            choice = user_input(\"(q=quit)||: \",0,1)
            if choice == \"0\" then 
              print colorOrange+\"cobbling...\"
              keyword = user_input(\"Enter custom_object key  for shell [q=quit]:> \")
              if keyword.lower == \"q\" then 
                print \"aborting...\"
                continue 
              else 
                print command.cob(\"set\",keyword,buffer_selection)
                continue
              end if
            end if 
            if choice == \"9\" and notftp then 
              ccc = command.fetch(buffer_selection)
              if typeof(ccc) == \"MetaxploitLib\" then 
                print \"-- \"+colorOrange+\"BUFFERING MetaxploitLib...\"
                globals.BUFFER.push(ccc)
              else 
                print \"fetch: task failed\"
              end if
            end if 
            if choice == \"f\" then  
              print(\"Buffering filesystem...\" )
              buffered_filesys = buffer_selection.host_computer.File(\"/\")
              print(\"<u>Buffered filesystem ready. Accessing with <b>felix</b>.</u>\")
              command.felix(buffered_filesys)
              continue
            end if
            if choice == \"p\" then 
              print command.purge(\"-b\",str(selection))
              print colorOrange+\"Shell object purged from BUFFER\"
              continue 
            end if
            if choice == \"d\" then 
              d=(globals.decompiler(buffer_selection))
              print colorOrange+\"BUFFERING...\"+char(10)+d 
              globals.BUFFER.push(d)
              continue
            end if
            if choice == \"b\" then 
              dest_folder = user_input(colorCyan+\"Destination folder (currentPath=default,q=quit)\"+char(10)+\":> <u>\"+colorWhite)
                if dest_folder == \"q\" then continue 
                if dest_folder == \"\" then dest_folder = currentPath
                print globals.get_binaries(buffer_selection,globals.get_file(dest_folder))
              continue 
            end if
            if choice == \"q\" then
              buffered_filesys = buffer_selection.host_computer.File(\"/\")
              print(\"Buffering filesystem of computer object...\" )
              print(colorLightBlue+\"<u><size=75%>Buffered filesystem ready. Access with [</b>4<b>]</u>\"+CT)
              shelling = false
              continue
            end if
            if choice == \"c\" then
              print( globals.curl(buffer_selection) )
              continue
            end if
            if choice == \"8\" and notftp then
              l_path = user_input(colorLightBlue+\"Enter launch_path</color></b> (<b>enter</b>=abort, 5hell=launch_first_5hell_found)\"+char(10)+colorCyan+\":> </b><size=75%><u>\"+colorWhite)
              if l_path == \"\" then continue
              if l_path == \"5hell\" then 
                l_path = command.grep(\"-p\",\"5hell\",buffer_selection)
                if l_path == \"No 5hell found, aborting...\" then continue else print colorCyan+\"located 5hell in \"+l_path
              end if
              l_para = user_input(colorWhite+\"</b>Optional launch parameters: \"+char(10)+\"(@a=clipa, @b=clipb, @c=clipc, <b><enter></b>=skip)\"+char(10)+\":> \"+colorWhite)
              if l_para == \"@a\" then l_para = globals.clipboard_alpha
              if l_para == \"@b\" then l_para = globals.clipboard_beta
              if l_para == \"@c\" then l_para = globals.clipboard_gamma
              print(colorLightBlue+\"Initializing sshfs glasspool protocol...\"+CT)
              print(colorWhite+\"<size=75%><u>Injecting process \"+l_path+\" into 0x\"+\"0B\"+floor(rnd * 10)+floor(rnd * 10)+floor(rnd * 10)+\"5C\"+floor(rnd * 10)+\"...</u></size>\"+CT)
              globals.stack_pool(\"up\")
              print(buffer_selection.launch( l_path, l_para ) )
              _cascade // exit if cascade
              globals.stack_pool(\"down\")
              globals.update_path
              continue
            end if
            if choice == \"6\" then
              print(\"Buffering computer from shell_object...\"+char(10)+\"...computer_object sent to BUFFER\")
              BUFFER.push(buffer_selection.host_computer)
              continue
            end if
            if choice == \"5\" then
              print(rclean(buffer_selection))
              continue
            end if
            if choice == \"4\" then
              print command.glasspool(buffer_selection)
              continue
            end if
            if choice == \"7\" and notftp then 
              print secure_copy(buffer_selection)
              continue 
            end if
            if choice == \"3\" then
              kit = null
              kit = command.tree(\"/\",\"rkit\",\"1\",\"N\")
              if not kit or typeof(kit) != \"file\" then
                print(colorRed+\"<b>Error: rkit not found.\"+CT)
                continue
              end if
              kperms = kit.permissions.values
              kpx = kperms[-1]
              kpw = kperms[-2]
              kpr = kperms[-3]
              print(\"Changing rkit permissions to <b>o+rwx</b> for upload...\")
              print(command.perms(\"-r\",\"o+rwx\", kit.path))
              copytrue = shell.scp(kit.path,\"/home/guest\",buffer_selection)
              print(\"Restoring permissions...\")
              if kpx == \"-\" and kpw == \"-\" and kpr == \"-\" then
                print(command.perms(\"-r\",\"o-rwx\", kit.path))
              else
                if kpx == \"-\" then kpx = \"x\" else kpx = \"\"
                if kpw == \"-\" then kpw = \"w\" else kpw = \"\"
                if kpr == \"-\" then kpr = \"r\" else kpr = \"\"
                print(command.perms(\"-r\", \"o-\"+kpr+kpw+kpx, kit.path))
              end if
              print(kit.permissions+\" \"+kit.owner+\" \"+kit.group+\" \"+kit.size+\" \"+kit.permissions+\" \"+kit.path)
              if typeof(copytrue) == \"string\" then
                print(copytrue)
                continue
              end if
              if not notftp then 
                print \"Successfully uploaded rootkit: \"+kit.path+char(10)+\"To: /home/guest\"+char(10+\"-- unable to launch via ftpshell; returning...\")
                continue 
              end if
              go = user_input(\"Successfully uploaded rootkit: \"+kit.path+char(10)+\"To: /home/guest\"+char(10)+\"Would you like to run 5hell silently on the target? [<b>Y</b>/n]\"+char(10)+\"||: \",0,1)
              if go.lower == \"n\" then
                continue
              else
                par = user_input(\"Enter launch parameters, if any. Otherwise press <<b>enter</b>> \"+char(10)+\"Example: do 1 brutus\"+char(10)+\":> \"+colorWhite).trim // add preset options
                print(colorLightBlue+\"Initializing sshfs glasspool protocol...\"+CT)
                print(colorWhite+\"<size=75%><u>Injecting process /home/guest/rkit/5hell into 0x\"+\"0B\"+floor(rnd * 10)+floor(rnd * 10)+floor(rnd * 10)+\"5C\"+floor(rnd * 10)+\"...</u></size>\"+CT)
                globals.stack_pool(\"up\")
                catch = buffer_selection.launch(\"/home/guest/rkit/5hell\",par)
                _cascade // exit if cascade
                globals.stack_pool(\"down\")
                if catch then print(catch)
                globals.update_path
                continue
              end if
            end if
            if choice == \"1\" then
              print(\"Opening a terminal will exit \"+CT+colorRed+\"5hell\"+CT+\". Continue? \")
              if user_input(\"[<b>Y</b>/n] :>\").lower == \"n\" then continue
              if typeof(buffer_selection) == \"shell\" then
                print(colorWhite+\"-ssh---\"+buffer_selection.host_computer.public_ip+\"-----------\"+CT+char(10))
              else
                print(colorWhite+\"-ftp---\"+buffer_selection.host_computer.public_ip+\"-----------\"+CT+char(10))
              end if
              get_custom_object.return_value = \"#!#CASCADE#!#\"
              exit buffer_selection.start_terminal
              continue
            end if
            if choice == \"2\" then 
              if notftp then
                if user_input(\"Redirect shell to internal ssh/ftp? [<b>Y</b>/n] :> \").lower != \"n\" then secure_connect(buffer_selection)
              else 
                print secure_copy(buffer_selection)
              end if
              continue
            end if
          end while
          continue
        end if // end shell handler

        if buffer_selection.hasIndex(\"__isa\") then print(globals.decompiler(buffer_selection))
      end if
      continue
    end if  // end option 5
    if waitFor == \"6\" then
      air_menu
    end if
    if waitFor == \"7\" or waitFor == \"LeftArrow\" or waitFor.lower == \"q\" then
      print(\"Memory_Alpha: exiting...\")
      return
    end if
    if waitFor == \"8\" then
      print(\"<size=75%>Showing processes...\")
      // p_buf = localmachine.show_procs.split(char(10))
      // i = 0
      // if DEBUG then print \"debug: \"+p_buf
      // for line in p_buf 
      //   if i == 0 then line = colorWhite+\"</b>\"+line else line = colorCyan+\"</b>\"+line
      //   if line.split(\" \").indexOf(\"dession\") != null then line = line.replace(\"dsession\",colorRed+\"</b>dsession\")
      //   p_buf[i] = line
      //   i = i + 1
      // end for
      // print format_columns(p_buf.join(char(10)))
      print command.ps
      continue
    end if
    if waitFor == \"9\" then
      print(\"<size=75%>Showing processes... (dessions cannot be killed)\")
      p_buf = localmachine.show_procs.split(char(10))
      if DEBUG then print \"debug: \"+p_buf
      print command.ps
      k_tar = user_input(\"Enter target process ID or name to kill (<<b>enter</b>>=abort)\"+char(10)+\":> \")
      processes = []
      //print(procs)
      processes = p_buf
      for p in processes
        process = p.split(\" \")
        process_ID = process[1]
        process_CMD = process[4]
        process_user = process[0]
        //print(process_CMD)
        if process_CMD == k_tar or process_ID == k_tar.to_int then
          print(\"rip: \" + process_ID + \" \" + process_CMD)
          catch = localmachine.close_program(process_ID.to_int)
          print(catch)
        end if
      end for
    end if // end option 9
  end while
end function
///////////////////////////////////// END MEMORY ALPHA ///////////////////////////





// Gopher = function(file) // takes file object
// if not file or typeof(file) != \"file\" then return \"404: file not found\"
//   cracked_data = []
//   pData = \"\"
//   localmachine.touch(currentPath , \"dump.txt\")
//   dump = localmachine.File(currentPath + \"/dump.txt\")
//   if dump then pData = dump.get_content
//   if not file.has_permission(\"r\") then return(\"can't read \"+file.name+\"; Permission denied\")
//   if file.get_content.len == 0 then return(\"decipher: no users found\")
//   print(\"Found \" + file.name)
//   lines = file.get_content.split(char(10))
//   print(\"Found \" + lines.len + \" line(s)\")
//   password = null
//   for line in lines
//     password = null
//     found = false
//     if line.len > 0 and line != \" \" and line != \"Decrypt:\" and line != \"Learn:\" then
//       userPass = line.split(\":\")
//       if userPass.len != 2 or userPass[1] == \"\" then continue
//       print(\"\\nDeciphering: \\n\" + line)
//       userPass[1] = userPass[1].replace(\"\\n\",\"\")
//       if userPass[1].len != 32 then continue
//       //password = cryptools.decipher(userPass[0], userPass[1])
//       found = false
//       dbf = globals.dict_a
//       for d in dbf
//         if found == true then continue
//         h = md5(d)
//         if h == userPass[1] then
//           password = d
//           found = true
//           continue
//         end if
//       end for
//       if not password then password = cryptools.decipher(userPass[1])
//       account = userPass[0]
//       print(account + \":\" + password)
//       cracked_data.push(account.trim + \":\" + password)
//     end if
//   end for
//   for d in cracked_data
//     if d != \",\" then pData = pData + d + char(10)
//   end for
//   if dump then
//     dump.set_content(char(10)+pData)
//     print(colorOrange+\"*\"+CT)
//     print(format_columns(dump.get_content))
//     print(\"Data saved to dump.txt\")
//   else
//     print(\"Error saving data to dump.txt\")
//     return 0
//   end if
//   return 1
// end function



// transmit 2.0 since 5hell 3.6.9

globals.transmit = function(wait_for_reply=0)
  if globals.T_BUF.len <= 1 then return \"transmit: tbuf empty\"
  // text to send
  send_this = globals.T_BUF.join(char(10))
  if send_this.len <= 1 then return \"transmit: buffer empty\"
  
  // validate settings
  if not is_valid_ip(HOME_SERVER[0]) then return \"transmit: error: please set @home ip in 5hell.src\" // [\"ip\",port,\"user\",\"pass\",\"service\",\"path_to_pass\"]
  if typeof(HOME_SERVER[1]) != \"number\" then \"transmit: error: please set @home port in 5hell.src\"

  // connect to server. credentials compiled into 5hell.src for security
  print colorLightBlue+\"transmit: connecting to database...\"
  print(colorWhite+\"---sshfs----</b>\"+HOME_SERVER[2]+\"@\"+HOME_SERVER[0]+\"<b>----\"+CT)
  if DEBUG then 
    print \"debug: ip: \"+HOME_SERVER[0]
    print \"debug: port: \"+HOME_SERVER[1]+\" is a \"+typeof(HOME_SERVER[1])
    print \"debug: user: \"+HOME_SERVER[2]
    print \"debug: pass: \"+HOME_SERVER[3]
    print \"service: \"+HOME_SERVER[4]
    print \"path: \"+HOME_SERVER[5]
  end if
  remote = shell.connect_service(HOME_SERVER[0],HOME_SERVER[1],HOME_SERVER[2],HOME_SERVER[3],HOME_SERVER[4])
  if typeof(remote) != \"shell\" and typeof(remote) != \"ftpshell\" then return \"transmit: unable to connect to server\"+char(10)+\"-- check ip and credentials and try again\"

  // make sure we have an ouput file
  passfile = remote.host_computer.File(HOME_SERVER[5]) 
  if not passfile then return \"transmit: error: \"+HOME_SERVER[5]+\" not found\"

  // transmit
  print \"Transmitting data...\"
  t_catch = passfile.set_content(send_this)
  // don't purge the buffer unless write successful
  if typeof(t_catch) == \"string\" then return t_catch else print \"Purging buffer...\" 
  // purge and reset tbuf
  globals.T_BUF = [(localip+\"@\"+pubip)] 
  //globals.T_BUF = []
  if wait_for_reply then 
    print \"Waiting for reply...\"
    waiting = true
    timeout = 600
    while waiting == true
      if passfile.get_content != send_this then waiting = false
      wait(.1)
      if timeout == 300 then print \"timeout in 30 seconds...\"
      if timeout == 100 then print \"timeout in 10 seconds...\"
      if timeout == 1 then return \"transmit: timeout: no reply\"
      timeout = timeout - 1
    end while 
    print \"Reply received...\"
    print \"Storing in <b>clipa</b>\"
    reply = passfile.get_content
    return command.clipa(reply) // will print to screen via clipa
  else 
    print \"Skipping reply...\"
  end if

  return colorLightBlue+\"transmit: task complete\"
end function


// transmit = function(send, passwd=0)
//   // transmit
//   // sends one line to server file for processing
//   pass_path = \"/virt/share.spc\" // path to the shared file called pass, edit accordingly
//   kr = user_input(\"Is KORE running on the database? [y/N] ||: \",0,1)
//   if kr.lower == \"y\" then pass_path = \"/virt/share.spc\" else pass_path = user_input(\"transmit_to_this_path:> \")
//   if pass_path == \"\" then return \"aborting...\" else print(\"transmitting to: \"+pass_path+\" at: \")
//   remote_ip = \"0.0.0.0\" // replace this with your server
//   remote_port = 22
//   passwd = null
//   if params and params.len > 0 then remote_ip = params[0]
//   if params and params.len > 1 then remote_port = params[1].to_int
//   if params and params.len > 2 then passwd = params[2]
//   if not params or not is_valid_ip(params[0]) then
//     remote_ip = user_input(\"Enter database ip (enter nothing to quit):> \")
//     if remote_ip == \"\" then return \"aborting...\"
//     if not is_valid_ip(remote_ip) then return \"invalid ip. aborting...\"
//     remote_port = user_input(\"Enter database port (press return for port 22):> \")
//     if remote_port.to_int <= 0 then remote_port = 22 else remote_port = remote_port.to_int
//     passwd = user_input(\"Server Password (enter nothing to quit):> \",1)
//     if passwd == \"\" then return \"aborting...\"
//   end if
//   passfile = null
//   print(colorWhite+\"---ssh----</b>\"+remote_ip+\"<b>----\"+CT)
//   remote = get_shell.connect_service(remote_ip, remote_port, \"root\", passwd)
//   if typeof(remote) ==  \"shell\" then
//     passfile = remote.host_computer.File(pass_path)
//   else
//     print(\"Unable to establish connection.\")
//   end if
//   if not passfile then return(\"404: file not found \")
//   dc = send+char(10)//+\"Decrypt:\"
//   passfile.set_content(dc)
//   globals.T_BUF = [(localip+\"@\"+pubip)]
//   wait(1)
//   print(\"Transmission complete.\")
// end function

globals.newtree = function(a_file,quiet=0)
  if typeof(a_file) != \"file\" then return \"tree: invalid type\"
  // system_map = {folder.path:file,file,file}
  system_map = {}

  listFiles = function(f)
      if f.is_folder then
          folders = f.get_folders
          files = f.get_files
          system_map[f.path] = [f]+files
          for folder in folders
              system_map[folder.path] = [folder]+folder.get_files
              listFiles(folder)
          end for        
      end if
  end function

  listFiles(a_file)
  output = []
  outprint = []
  for i in system_map.indexes
      for f in system_map[i].values
          s = \"\"
          if f.is_symlink then s=\"<color=yellow>\"
          if f.is_folder then 
              outprint.push( \"<size=85%><b><color=#2382FFFF>\"+f.permissions+\" \"+s+f.path )
          else 
            if f.is_binary then outprint.push( \"<size=80%><color=blue>|..<color=#00FFFF>\"+f.permissions+\" \"+s+f.path) else outprint.push( \"<size=80%><color=blue>|..</color><color=white>\"+f.permissions+\" \"+s+f.path )
          end if
          output.push(f)
      end for
  end for
  //globals.enumerated = output
  if output.len < 1 then 
    if quiet then return 0 else return \"tree: invalid input: expects folder\" 
  else 
    if quiet == \"2\" then return output
    if quiet != \"1\" then print command.enum(output) else command.enum(output)
  end if
  if quiet != \"1\" then return outprint.join(char(10))
  if DEBUG then return system_map
  return 0
end function

globals.list_files = function(result, grep=null, quiet=0, waitFor=0)
  //grepped_file = \"File: \" + grep + \" not found.\"
  //if not quiet then print(\"Expanding: \" + colorLightBlue+result.path)
  if not quiet then 
    s = \"\"
    if result.is_symlink then s=\"<color=yellow>\"
    if result.is_binary then 
      if not result.is_folder then 
        s = \"\"
        if result.is_symlink then s=\"<color=yellow>\"
        print \"<size=80%><color=blue>|..<color=#00FFFF>\"+result.permissions+\" \"+s+result.path 
      end if 
    else 
      print \"<size=80%><color=blue>|..</color><color=white>\"+result.permissions+\" \"+s+result.path
    end if
  end if
  if not result.is_binary then
    //if not quiet then print(\"<size=80%>\"+colorWhite+result.name + \" \" + result.permissions)
    if result.name == grep or result.name == \"passwd\" or result.name == \"Bank.txt\" or result.name == \"Map.conf\" or result.name == \"Browser.txt\" or result.name == \"Mail.txt\" then
      if not result.is_binary  then
        if not quiet then print(result.get_content)
      else
        if not quiet then print(\"<size=75%>Unable to open binary file. \")
      end if
      if result.name == \"passwd\" or result.name == \"Bank.txt\" or result.name == \"Mail.txt\" or result.name == grep then
        if not waitFor then waitFor = \"R\"//user_input(\"Crack files? [r/y/N]||: \",0,1)
        if waitFor == \"y\" or waitFor == \"Y\" then
          if result.has_permission(\"r\") then command.gopher(result.get_content)
        end if
        if waitFor == \"r\" or waitFor == \"R\" then
          cont = result.get_content
          if cont then cont = cont.split(char(10))
          for c in cont
            if not globals.T_BUF.indexOf(c) >= 0 then  
              globals.T_BUF.push(c)
              print(colorLightBlue+\"<size=75%>Sent: \"+result.get_content+\" to t<b>r</b>ansmission buffer (<b>@tbuf</b>).</size>\")
            else 
              print(colorLightBlue+\"<size=75%>Skipping duplicates...\")
            end if
          end for
        end if
        if result.name == grep then
          globals.grepped_file = result
        end if
      end if
    end if
  else
    if result.is_folder then
      if result.name == grep then
        globals.grepped_file = result
      end if
      folders = result.get_folders
      files = result.get_files
      //wait(.1)
      for folder in folders
        //if not quiet then print(\"Dir: \" + folder.name + \" \" + folder.permissions)
        if not quiet then print \"<size=85%><b><color=#2382FFFF>\"+folder.permissions+\" \"+folder.path
        list_files(folder, grep, quiet, waitFor)
      end for
      for file in files
        list_files(file, grep, quiet, waitFor)
      end for
    else
      if result.name == grep then
        globals.grepped_file = result
      end if
    end if
  end if
  //return grepped_file
end function

globals.rclean = function(arg1, arg2=0)
  // if not arg1 or arg1 == \"-h\" or arg1 == \"help\" then return colorGreen+\"<u>RCLEAN || REMOTE CLEAN || LOG SCRUBBING\"+char(10)+
  // \" Remote clean is a remote log scrubbing protocol. It differs\"+char(10)+
  // \"from silentclean in a couple of ways. Silentclean creates a file on the\"+char(10)+
  // \"target system. Rclean does not create a file but rather uses a file present on the system.\"+char(10)+
  // \"This means \"+colorOrange+\"rclean\"+CT+\"is most useful in scrubbing\"+colorOrange+\"BUFFERED\"+CT+\" or piped objects. \"+char(10)+
  // colorLightBlue+\"Silentclean\"+CT+char(10)+\"is most useful for in place log wiping or wiping through\"+colorLightBlue+\"GLASSPOOL\"+CT+\".\"
  // \"Usage: rclean [ip] [port]\"+char(10)+
  // \"Additional functionaly via memory alpha when working with objects.\"+char(10)+
  // \"Mainly used by kraken.\"
  t_file = null
  detection_factor = 0
  remote_clean = function(f,d=0) // file object, bool 0|1
    if typeof(f) != \"file\" then return \"Error. Expected file got: \"+f
    if not f.has_permission(\"r\") then return \"Error: scrub failed. no read permissions.\"
    catch = colorRed+\"Log wipe failed.\"+CT
    rooting = true
    while rooting
      if f.name != \"/\" then
        f = f.parent
      else
        rooting = false
      end if
    end while
    log = null
    sys = null
    log = command.tree(f, \"system.log\", 1, \"N\")
    sys = command.tree(f, \"silentclean\", 1, \"N\") 
    if not log then return \"rclean: system.log not found. aborting.\"
    if not log.has_permission(\"w\") then return \"rclean: cannot write to /var/system.log: permission denied\"
    if DEBUG then print \"debug: log is a \"+typeof(log)+char(10)+\"debug: sys is a \"+typeof(sys)
    if typeof(sys) != \"file\" or d == \"-d\" or d == \"-n\" then sys = command.tree(f, \"xorg.conf\", 1, \"N\")
    if typeof(sys) != \"file\" then  
      print \"rclean: could not find a file named silentclean or xorg.conf on system\" 
      sys = command.tree(f,user_input(\"rclean: \"+colorCyan+\"please enter a filename that exists on the system\"+char(10)+\"-- rclean will use this file for scrubbing\"+char(10)+\"(q=quit) FileName:> \"),1,\"N\")
      if not sys then return \"rclean: failed: no scrub file\"
    end if
    if d == \"-d\" or d == \"-n\" then 
      if DEBUG then print \"d: \"+d+\" is a \"+typeof(d)
      if sys.name == \"silentclean\" then sys.move(\"/var\",\"silentclean\")
      kit = command.tree(f,\"rkit\", 1,\"N\")
      if not kit then kit = command.tree(f,\"5hell\",1,\"N\")
      if not kit then print \"rclean: \"+colorOrange+\" could not find rootkit or 5hell\"
      if kit and kit.has_permission(\"w\") then 
        kit.delete 
        detection_factor = detection_factor + 1 
        print \"rclean: rkit/5hell deleted\"+char(10)+\"[<color=red>detection_factor</color>: ][<color=red>\"+detection_factor+\"</color>]\"
      else 
        print colorRed+\"rclean: cannot delete rkit/5hell: permission denied\"
      end if
      // if instance and p_validate(instance,\"parent\") then
      //   if instance.parent.name == \"rkit\" then 
      //     print \"deleting \"+instance.parent.path
      //     print instance.parent.delete 
      //   else 
      //     print \"deleting \"+instance.path
      //     print instance.delete   // auto delete rkit if present, 5hell if not
      //   end if
      // end if
      if d == \"-n\" then 
        print \"rclean: \"+colorRed+\"nuking filesystem...\"
        boot = command.tree(f,\"boot\",1,\"N\")
        lib_fold = command.tree(f,\"lib\",1,\"N\")
        if boot then 
            if boot.has_permission(\"w\") then 
              print \"deleting: /boot\"
              boot.delete
              detection_factor = detection_factor + 1
              print \"[<color=red>detection_factor</color>: ][<color=red>\"+detection_factor+\"</color>]\"
            else 
              print colorRed+\"rclean: could not delete /boot: permission denied!\"
            end if
        else 
          print colorRed+\"rclean: could not locate /boot\"
        end if
        if lib_fold and typeof(lib_fold) == \"file\" then 
          if lib_fold.has_permission(\"w\") then 
            lib_fold.delete
            detection_factor = detection_factor + 1
            print \"[<color=red>detection_factor</color>: ][<color=red>\"+detection_factor+\"</color>]\"
          else 
            print colorRed+\"rclean: could not delete /lib: permission denied!\"
          end if
        else
          print colorRed+\"rclean: could not locate /lib\"
        end if
      end if
    end if
    print(\"<b>Scrubbing log...</b>\")
    catch = colorRed+\"rclean: failed:</b>the scrub file was removed too early!\"
    if sys then 
      if sys.name == \"silentclean\" then 
        print \"rclean: found file named silentclean\"+char(10)+\"-- using: \"+sys.path+\" as log replacement\"
        catch = sys.copy(\"/var\",\"system.log\") 
      else 
        catch = sys.copy(\"/var\", \"system.log\")
      end if
    end if
    if catch == 1 then 
      detection_factor = 0
      print \"[<color=red>detection_factor</color>: ][<color=red>\"+detection_factor+\"</color>]\"
      return \"rclean: \"+colorGreen+\"Log Scrubbed...\"
    else 
      return colorRed+\"rclean: failed: \"+catch+char(10)+colorRed+\"WARNING: we left \"+ detection_factor + \" log entries!\"
    end if
  end function
  if typeof(arg1) == \"shell\" or typeof(arg1) == \"ftpshell\" then // arg2 is shell, not called by user
    t_shell = arg1
    t_file = t_shell.host_computer.File(\"/\")
  else
    if typeof(arg1) == \"computer\" then
      t_comp = arg1
      t_file = t_comp.File(\"/\")
    else
      if typeof(arg1) == \"file\" then
        t_file = arg1
      end if
    end if
  end if
  if t_file then return remote_clean(t_file,arg2)
  return colorRed+\"Error. Wipe failed.\"
end function

globals.lan_probe = function(router,mode=\"local\") // expects router object, returns string
  //t = time
  _local = function()
    total = []
    layer1 = get_router.devices_lan_ip
    total = layer1
    hold = []
    for ip in layer1
      if typeof(get_router(ip)) == \"router\" then hold.push(ip)
    end for
    for h in hold
      d = get_router(h).devices_lan_ip
      for e in d
        if total.indexOf(e) == null then total.push(e)
      end for
    end for
    return total.sort.join(char(10))
  end function 
  _remote = function(rtr)
    return rtr.devices_lan_ip.sort.join(char(10))
  end function
  if mode == \"remote\" then return _remote(router) else return _local
end function

// globals.lan_probe = function(rtr,max=255)
//   clist = rtr.devices_lan_ip
//   switches = []
//   for c in clist
//     switches.push(c)
//   end for
//   for s in switches
//     sp = s.split(\"\\.\")
//     for i in range(1, max) // increase this to catch larger LANs
//       sp[-1] = (i)
//       sj = sp.join(\".\")
//       try = rtr.device_ports(sj)
//       if try and try.indexOf(\"unreachable\") == null and clist.indexOf(sj) == null then clist.push(sj)
//     end for
//   end for
//   return clist
// end function

r_hecks = function()

  configure_heist = function()
    if XPLOITS == null or XPLOITS == [] then return \"Scan a lib or link a db first.\"
    print(colorGold+\"Configuring Heist: \"+CT+char(10))
    memory = []
    data = \"\"
    i = 1
    for x in globals.XPLOITS
      data =  data + \"[\" + i + \"]\" + x + \"\\n\"
      i = i + 1
    end for
    print(format_columns(data))
    waitFor = user_input(\"Select an exploit #: \").val
    if waitFor == 0 then
      return 0
    else
      if waitFor > 0 and waitFor <= XPLOITS.len then
        memory = XPLOITS[waitFor - 1].split(\" \")
      else
        return \"Invalid selection. \"
      end if
    end if
    m = memory.pull
    v = memory.pull
    l = null
    if globals.metaLib then
      l = globals.metaLib.version
    else
      print(\"No metaLib seed detected. Enter version number (this will be automated in the future): \")
      l = user_input(\"version# (eg:> 1.0.1) \"+char(10)+\":> \")
    end if
    //i = command.rnip(user_input(\"# of ips to scan (leave blank to enter ip): \"))
    //if i == \"rnip [iter] [optional: delimiter]\" then i = user_input(\"ip:> \")
    ip = command.ipfit
    //if typeof(ip) == \"string\" then
    if typeof(ip) == \"list\" then ip = ip.join(char(10))
    psw = user_input(\"Bridge password: (leave blank to crack locally)\", 1)
    if psw == \"\" or psw == \" \" then psw = 0
    ptt = globals.targetPort
    if ptt == \"router\" then ptt = 0
    tool = 0
    if not psw then tool = user_input(\"[<b>0</b>] Gopher [1] Hashim (q=quit)||: \",0,1)
    if tool.lower == \"q\" then return \"aborting...\"
    if tool.to_int == 1 then
      if not localmachine.File(\"/root/tables/t5\") then return \"/root/tables/t5 not found. use<b> pwgen hash </b> to generate.\"
      print(\"Deciphering with Hashim.\")
      tool = 1
    else
      print(\"Deciphering with Gopher\")
      tool = 0
      if not globals.BIGBRAIN then
        print(\"Cerebrum inactive. Would you like to run command.cerebrum now?  \")
        if user_input(\"[Y/n] ||: \",0,1).lower != \"n\" then command.cerebrum else print(\"skipping cerebrum...\")
      end if
    end if
    print(colorGold+\"*\"+CT+char(10)+command.clipb(i))
    return bank_heist(m, v, l, ip.split(char(10)), psw, ptt, tool)
  end function

  bank_heist = function(mem, val, lib_v, ip_list, pw, port=0, t=0)
    for ip in ip_list
      if port == 0 then
        if not get_router(ip) then continue
        if get_router(ip).kernel_version != lib_v then
          print(\"Target library not found at \"+ip+\": Skipping. (no connection was made)\")
          continue
        end if
      end if
      globals.net_session = null
      globals.net_session = metaxploit.net_use( ip , port )
      if not globals.net_session then continue
      globals.metaLib = globals.net_session.dump_lib
      if metaLib.version != lib_v then
        print(metaLib.lib_name + \" v \" + metaLib.version + \" does not match target library. Skipping (<b>we left a connection log behind!</b>).\")
        continue
      end if
      c_list = [ip]
      if port == 0 then c_list = command.lanpro(ip)
      for c in c_list
        result = null
        home = null
        print
        result = globals.metaLib.overflow(mem, val, c) // overflow
        if not result then continue
        print(colorLightBlue+\"[\"+colorWhite+ip+\"</b>:<b>\"+c+CT+colorLightBlue+\"]\"+CT)
        print(\"Hooked: \"+typeof(result))
        globals.BUFFER.push(result)
        globals.grepped_file = null
        if typeof(result) == \"computer\" then home = result.File(\"/home\")
        if typeof(result) == \"shell\" then
          home = result.host_computer.File(\"/home\")
          result = result.host_computer
        end if
        if typeof(result) == \"file\" then
          home = result
          while home.name != \"/\"
            home = home.parent
          end while
          list_files(home, \"home\", 1, \"N\")
          home = globals.grepped_file
        end if
        if home and result then
          print(home.name+\" \"+home.permissions)
          folders = home.get_folders
          for f in folders
            if f.name == \"guest\" then continue
            print(f.name + \" \" + f.permissions)
            globals.grepped_file = null
            wait(.1)
            list_files(f, \"Bank.txt\", 1, \"N\") //result.File(f.path+\"/Config/Bank.txt\")
            bank = globals.grepped_file
            if bank then print(bank.path + \" \" + bank.permissions)
            if typeof(bank) != \"file\" then continue
            if bank.has_permission(\"r\") and bank.get_content != \"\" then
              globals.T_BUF.push(bank.get_content.trim)
              print(colorGreen+bank.get_content+CT)
            else
              print(colorOrange+\"Bank.txt empty or unreadable.\"+CT)
            end if
          end for
          globals.T_BUF.push(\"[\"+c+\"@\"+ip+\"]\")
        end if
        print(rclean(result))
      end for
      wait(1)
      if pw != 0 then
        print(\"Preparing transmission...\")
        transmit(globals.T_BUF.join(char(10)), pw)
      else
        print(\"Hashing...\")
        globals.localmachine.touch(currentPath, \"pass\")
        pass = globals.localmachine.File(currentPath+\"/pass\")
        if not pass then return \"Check write permissions.\"
        pass.set_content(\"\")
        pass.set_content(globals.T_BUF.join(char(10)))
        globals.T_BUF = [(localip+\"@\"+pubip)]
        //globals.T_BUF = []
        if tool then
          command.hashim(\"false\")
        else
          globals.Gopher(pass)
        end if
      end if
      wait(1)
    end for
    return 1
  end function

  rmenu = function()
    while true
      print(colorGold+\"- - - - - - - - - - - - - - - - - - -\"+CT+char(10))
      print(colorGold+\"Router: \"+CT+localmachine.public_ip+colorGold+\" : \"+CT+ localmachine.local_ip+CT)
      print(colorGold+\"////////////////////////////////////\"+CT)
      print(colorGold+\"[0]\"+CT+colorGreen+\" - <u>Go Back</u> Nothing to see here.\"+CT)
      print(colorGold+\"[1]\"+CT+colorGreen+\" - Bank Heist\"+CT)
      print(colorGold+\"[2]\"+CT+colorGreen+\" - LAN Probe\"+CT)
      print(colorGold+\"////////////////////////////////////\"+CT)
      menu = user_input(\"(q=quit)||: \",0,1)
      if menu == \"0\" or menu.lower == \"q\" or menu == \"\" then return
      if menu == \"1\" then return configure_heist
      if menu == \"2\" then
        targip = user_input(\"Router ip: \")
        print(\"<b>Scanning...</b> \")
        if is_valid_ip(targip) then
          print command.lanpro(targip)
        else
          print command.lanpro(0)
        end if
      end if
    end while
  end function
  rmenu
  return 0
end function

// let's rewrite this to be a little more intuitive in form and function
globals.shell_prompt = function(passShell, waitFor=null)
  if typeof(passShell) == \"shell\" then
    waitFor = user_input(\"Open shell? [c/y/N] \"+char(10)+\"||: \",0,1)
    
    if waitFor.lower == \"y\" then
      if globals.GLASSPOOL then
        print(\"Opening shell: \"+passShell.host_computer.local_ip+\"@\"+passShell.host_computer.public_ip+\"...\")
        get_custom_object.return_value = \"#!#CASCADE#!#\"
        exit passShell.start_terminal
        globals.update_path
      else
        print(\"Piping shell connection...\")
        get_custom_object.return_value = \"#!#CASCADE#!#\"
        exit passShell.start_terminal
        print(colorWhite+\"Terminal session queued. Exit 5hell manually to begin.\") //  shouldn't need this anymore
        globals.update_path
      end if
    else
      if waitFor == \"c\" then
        if globals.GLASSPOOL then
          print(\"Piping glasspool shell...\")
          secure_connect(passShell)
        else
          print(\"Getting credentialed shell for: \")
          c_shell = get_shell(user_input(\"user:> \"), user_input(\"pass:> \", 1))
          if c_shell then
            globals.BUFFER.push(c_shell)
            ch = user_input(\"New shell sent to BUFFER. Open it? [y/N] \")
            if ch.lower == \"y\" then 
              get_custom_object.return_value = \"#!#CASCADE#!#\"
              exit c_shell.start_terminal
            end if
          else
            print(\"Failed to open shell. Check credentials and try again.\")
          end if
        end if
      end if
    end if
  else
    if globals.GLASSPOOL then
      //return colorOrange+\"Psudo: GLASSPOOL is active. Please run psudo without params.\"+CT
      print(colorLightBlue+\"GLASSPOOL: \"+colorOrange+\"deactivating.\"+CT)
      globals.shell = get_shell
      globals.localmachine = globals.shell.host_computer
      globals.GLASSPOOL = globals.GLASSPOOL - 1
      globals.update_path
      return globals.shell
    end if
    try = null
    if typeof(passShell) == \"string\" then try = get_shell(\"root\", passShell)
    if typeof(try) == \"shell\" then
      globals.BUFFER.push(try)
      ch = user_input(colorLightBlue+\"malp:</b> new shell sent to \"+colorOrange+\"BUFFER\"+char(10)+colorLightBlue+\"-- open object in \"+colorOrange+\"</b>malp? [y/<b>N</b>] ||: \",0,1)
      if ch.lower != \"y\" then return try else return globals.memory_alpha(str(globals.BUFFER.len - 1))
    end if
    if try then print(try)
    if DEBUG then print \"passShell is a: \"+typeof(passShell)
    return \"psudo:\"+colorRed+\"</b> incorrect parameters:\"+char(10)+\"-- expected shell object or <b>correct</b> password\"
  end if
  return 0
end function

// stub for the future
globals._shell_prompt = function( input_shell=null, confirm=null, uu=null, pw=null )
  if typeof(input_shell) != \"shell\" then return \"psudo: expected shell, got: \"+typeof(input_shell)
  
  // menu
  if not confirm or confirm == \"-m\" then 
    // display options
    print colorGold+\"</b>psudo: \"+CT+\"[\"+colorWhite+\"y</b>|<b>l\"+CT+\"] open shell; aka run start_terminal on this shell object\"
    print colorGold+\"</b>psudo: \"+CT+\"[\"+colorWhite+\"u\"+CT+\"] BUFFER a <b>local</b> user shell with credentials\"
    print colorGold+\"</b>psudo: \"+CT+\"[\"+colorWhite+\"s\"+CT+\"] BUFFER a <b>local</b> root shell with credentials\"
    print \"-- press any other key to abort\"
    confirm = user_input(colorWhite+\"||: \"+colorGold+\"</b>\").lower
    if \"ylus\".indexOf(confirm) == null then return \"psudo: aborting...\"
  end if
  // handle options
    
  if confirm == \"y\" or confirm == \"-y\" or confirm == \"-l\" or confirm == \"l\" then 
    print colorGold+\"</b>psudo: \"+CT+\" runnning start_terminal on this shell connection\"+char(10)
    get_custom_object.return_value = \"#!#CASCADE#!#\"
    exit input_shell.start_terminal
    print colorGold+\"psudo:\"+colorOrange+\" Attention: if you are seeing this message:\"+char(10)+
    colorOrange+\"</b>-- A game anomoly has kept the script running\"+char(10)+
    colorOrange+\"</b>-- despite having used start_terminal.\"+char(10)+
    colorOrange+\"</b>-- You will need to manually exit out of 5hell to start the terminal.\"+char(10)+
    colorOrange+\"</b>-- Note: you must exit; do not use ctrl+c\"
    exit \"This is a game bug, not mine.\"
    return 0
  end if

  if confirm == \"u\" or confirm == \"-u\" or confirm == \"s\" or confirm == \"-s\" then 
    if globals.GLASSPOOL then
      print(\"psudo: starting terminal on glasspool shell...\")
      secure_connect(passShell)
    else
      uu = null
      if confirm == \"-s\" or confirm == \"s\" then uu = \"root\" 
      if not uu then 
        print(\"Get credentialed shell for what user? (leave blank to abort): \")
        uu = user_input(\"user_name:> <b>\")
      else 
        print(\"Getting root shell...\")
      end if
      if uu == \"\" then return \"aborting...\"
      if not pw then pw = user_input(uu+\" password:> <b>\",1)
      if pw == \"\" then return \"aborting...\"
      c_shell = get_shell(uu,pw)
      if typeof(c_shell) == \"shell\" then 
        if ch == \"y\" then exit globals._shell_prompt(c_shell,\"-l\")
        globals.BUFFER.push(c_shell)
        print colorLightBlue+\"malp:</b> new shell sent to \"+colorOrange+\"BUFFER\"
        if ch != \"-m\" then ch = user_input(colorLightBlue+\"-- open object in \"+colorOrange+\"</b>malp? [y/<b>N</b>] ||: \",0,1)
        if ch.lower != \"y\" then return c_shell else return globals.memory_alpha(str(globals.BUFFER.len - 1))

      else
        return(colorGold+\"psudo: \"+CT+\"failed to open shell\"+char(10)+\"-- check credentials and try again\")
      end if
    end if
  end if

  return \"psudo: aborting...\"
end function
// handle computer objects
globals.hooked_comp = function(result)
  logfile = result.File(\"/var/system.log\")
  passfile = result.File(\"/etc/passwd\")
  homefolder = result.File(\"/home\")
  lib_ssh_file = result.File(\"/lib/libssh.so\")
  ssh_spoof = localmachine.File(\"/root/rkit/silentclean\")
  hooking = true

  while hooking
    print(colorWhite+\"<u>=============================</u>\"+CT)
    print(format_columns(result.show_procs))
    print(\"[\"+checkUser(result)+\":\"+typeof(result)+\"] \"+char(10)+colorWhite+\"</b>\"+result.local_ip+\" @ \"+result.public_ip+CT)
    n_d = result.network_devices.trim.replace(char(10),\", \")
    if n_d == \"\" then print(colorWhite+\"</b>[Router]</color>\") else print(colorWhite+\"</b>\"+n_d+CT)
    ports = result.get_ports
    p_i = []
    for p in ports
      if p == \"\" then continue
      p_i.push(colorWhite+\"</b>[\" + p.port_number + \"] \")
      try = get_router(result.public_ip).port_info(p)
      if try then p_i[-1] = p_i[-1] + try
    end for

    if p_i.len >= 1 then print(p_i.join(char(10))) else print(colorWhite+\"<size=75%>[no port info to display]</size>\"+CT)
    print(colorWhite+\"<size=75%><u>=============================</u></size>\"+CT)
    print(\"[K] - kill [G] - glassp [c] curl \")
    print(\"[7] iwlist [8] iwconfig [9] chUnlock\")
    print(\"[4] chngpw [5] sclean   [6] useradd\")
    pause = user_input(\"[1] home   [2] passfile [3] dump tbuf \\n[0|q] quit [d] decompiler ||: \",0,1)
    if pause == \"d\" then 
      print(globals.decompiler(result))
      continue
    end if
    if pause == \"0\" or pause == \"q\" then hooking = false
    if pause.lower == \"k\" then print(result.close_program(user_input(colorWhite+\"pid to kill:> \"+CT).to_int ) )
    if pause.lower == \"g\" then
      command.glasspool(result)
    end if
    if pause.lower == \"c\" then
      print( globals.curl(result) )
    end if
    if pause == \"1\" then
      if homefolder then
        list_files(homefolder)
      end if
    end if
    if pause == \"2\" then
      if passfile then
        list_files(passfile)
      else
        print(\"Error: file /etc/passwd not found\")
      end if
    end if
    if pause == \"3\" then
      command.tdump
    end if
    if pause == \"4\" then
      user = user_input(\"Changing password for user (default: root): \")
      if user == \"\" or user == \" \" or user == null then user = \"root\"
      print(\"Enter (a) non-alpha_numeric character(s) to abort. (will return error, just ignore)\")
      pass = user_input(\"New password (default: pass): \", 1, 0)
      if pass == \"\" or pass == \" \" or pass == null then pass = \"pass\"
      catch = result.change_password(user, pass )
      if catch then print(catch)
    end if
    if pause == \"5\" then
      if not logfile then
        print(\"/var/system.log not found\")
        continue
      end if
      catch = result.touch(\"/var\",\"system.bak\")
      print(catch)
      catch = null
      syslogbak = result.File(\"/var/system.bak\")
      if syslogbak then
        logfile.chmod(\"o+rw\")
        catch = logfile.delete
        print(catch)
        syslogbak.set_content(\"No IPs Today :D\")
        catch = syslogbak.move(\"/var\", \"system.log\")
      else
        print(colorRed+\"Failed to spoof log [\"+catch+\"]. We are not root.\")
      end if
      if catch then
        print(\"<b>[\"+catch+\"] /var/system.log spoofed if [1]</b> else failed.\")
      end if
    end if // end option 5
    if pause == \"6\" then
      r = range(1,9)
      r.shuffle
      sparky = \"sparky\"+str(r.pull)+str(r.pull)
      spark = result.create_user(sparky, \"passwd\")
      print(sparky + \"status [\" + spark + \"]\")
    end if
    if pause == \"7\" then
      print(colorWhite+\"<size=50%><u>launching mitm attack... attempting to filter networks...</u></size>\")
      nets = null
      if result.is_network_active and result.active_net_card == \"WIFI\" then nets = result.wifi_networks(\"wlan0\") else print(colorRed + \"Wifi card is disabled!\" + CT)
      for n in nets
        print(n)
      end for
    end if
    if pause == \"8\" then
      interface = user_input(\"[0] abort [1] wifi [2] ethernet ||: \",0,1)
      if interface == \"0\" then continue
      if interface == \"1\" then
        if result.is_network_active and result.active_net_card == \"WIFI\" then 
          nets = result.wifi_networks(\"wlan0\") 
        else 
          print(colorRed + \"Wifi card is disabled!\" + CT)
          continue 
        end if
        i = 0
        for n in nets
          print(\"[\"+i+\"]\"+n)
          i = i + 1
        end for
        net_choice = user_input(\"select a network:> \").to_int
        if typeof(net_choice) != \"number\" or net_choice < 0 or net_choice >= nets.len then continue
        bssid = nets[net_choice].split(\" \")[0]
        essid = nets[net_choice].split(\" \")[2]
        netpass = user_input(\"network key (@brutus for dicttionary attack): \"+char(10)+\":> \")
        if netpass == \"@brutus\" then
          for d in dict_a
            if result.connect_wifi(\"wlan0\",bssid,essid,d) == 1 then
              print(\"Connection swapped to \"+essid)
              return
            end if
            print(\"Failed to swap connection. Key not found.\")
          end for
        else
          print(result.connect_wifi(\"wlan0\",bssid,essid,netpass))
        end if
      end if
      if interface == \"2\" then
        gateway = user_input(\"enter gateway ip:> \")
        if gateway == \"\" then gateway = result.network_gateway
        new_ip = user_input(\"enter new ip:> \")
        if new_ip == \"\" or not is_valid_ip(new_ip) then
          print(\"aborting...\")
          return
        else
          result.connect_ethernet(\"eth0\", new_ip, gateway)
        end if
      end if
    end if
    if pause == \"9\" then
      try = result.File(\"/\")
      try.chmod(\"o+rwx\",1)
      try.chmod(\"g+rwx\",1)
      try.chmod(\"u+rwx\",1)
      if try.has_permission(\"w\") then print(\"<b>Unlocked</b>\") else print(\"Access<b> Denied</b>.\")
    end if
  end while
end function

secure_connect = function(shll)
  secure_port = targetPort
  waitFor = user_input(\"Connect on port 22? [Y/n]||: \",0,1)
  if waitFor.lower == \"n\" then secure_port = user_input(\"enter port:> \").to_int else secure_port = 22
  if secure_port < 1 or typeof(secure_port) != \"number\" then
    print(\"Error: invalid port for secure connect.\")
    return 0
  end if
  print(targetIP)
  if targetIP.is_lan_ip then 
    secure_ip = user_input(\"enter lan ip (<<b>enter</b>>=\"+targetIP+\", non-int=abort\"+char(10)+\":> \")
  else
    secure_ip = user_input(\"enter lan ip (<<b>enter</b>>=abort):> \")
  end if
  if secure_ip == \"\" then secure_ip = targetIP
  userName = user_input(\"Enter remote user name (<<b>enter</b>>=root, -q=quit):> \")
  if userName == \"\" then userName = \"root\"
  passWd = user_input(\"Enter remote user password (-brutus=dictinary attack, <<b>enter</b>>=quit):> \")
  if passwd == \"\" then return 0
  print(colorWhite+\"--ssh------------------------\"+CT)
  remote = null
  if passWd == \"-brutus\" then
    print(\"<b>running dictionary attack...</b>\")
    for d in dict_a
      remote = shll.connect_service(secure_ip, secure_port, userName, d)
    end for
  else
    if passWd != \"\" then remote = shll.connect_service(secure_ip, secure_port, userName, passWd)
  end if
  print(\"<b>Connecting</b>... \")
  if typeof(remote) == \"shell\" or typeof(remote) == \"ftpshell\" then
    globals.BUFFER.push(remote)
    print \"sending new shell to BUFFER...\"+char(10)+\"make a selection:\"
    print(            \"[4] glasspool \")
    todo = user_input(\"[1] run [2] start terminal [3] scp\"+char(10)+\"[0|q] quit ||: \",0,1)
    if todo == \"2\" then
      get_custom_object.return_value = \"#!#CASCADE#!#\"
      exit remote.start_terminal
    end if
    if todo == \"0\" then
      print \"aborting...\"
      return 0
    end if
    if todo == \"1\" then
      a = user_input(\"command path:> \")
      b = user_input(\"parameters:> \")
      globals.stack_pool(\"up\")
      print remote.launch(a, b)
      _cascade // exit if cascade
      globals.stack_pool(\"down\")
    end if
    if todo == \"3\" then
      secure_copy(remote)
      BUFFER.push(remote)
    end if
    if todo == \"4\" then
      print(colorLightBlue+\"Initializing sshfs glasspool protocol...\"+CT)
      hold_shell = globals.shell
      globals.shell = remote
      globals.localmachine = remote.host_computer
      if currentPath and homePath then
        globals.GLASSPOOL = globals.GLASSPOOL + 1
        print(colorWhite+\"...glasspool initialization successful. \"+char(10)+colorOrange+\"Type <u>return</b> to deactivate (exit or quit to terminate program)\"+CT)
        if typeof(shell) == \"ftpshell\" then print(colorOrange+\"Warning: many commands will not work with ftpshells!\"+CT)
        command.shell
        globals.shell = hold_shell
        globals.localmachine = globals.shell.host_computer
        globals.GLASSPOOL = globals.GLASSPOOL - 1
        globals.update_path
        return colorLightBlue+\"GLASSPOOL: \"+colorOrange+\"deactivating...\"+CT
      end if
      return colorOrange+\"...glasspool failed to initialize. Check permissions. And current path.\"+CT
    end if
    // if todo == \"5\" then
    //   new_ip = user_input(\"Secondary ip: \")
    //   new_port = user_input(\"Second port: \")
    //   new_user = user_input(\"Second user: \")
    //   new_pass = user_input(\"Second pass: \")
    //   buf_shell = remote
    //   new_shell = remote.connect_service(new_ip, new_port.to_int, new_user, new_pass)
    //   if new_shell then
    //     i = 0
    //     BUFFER.push(new_shell)
    //     max_bounce = user_input(\"First bounce successful. How many times should we repeat? \")
    //     while i < max_bounce
    //       remote = new_shell.connect_service(secure_ip, secure_port, userName, passWd)
    //       new_shell = remote(new_ip, new_port.to_int, new_user, new_pass)
    //       i = i + 1
    //     end while
    //   else
    //     print(\"Bounce failed.\")
    //   end if
    // end if
  else
    print(\"Unable to establish connection.\")
  end if
end function

// legacy shit
silentclean = function()
  return command.silentclean
end function

globals.select_attack = function(waitFor=0)
  if not metaLib then return \"Link metaLib before continuing.\"
  memory = []
  custom_mem = \"\"
  custom_exploit = \"\"
  exploit = \"\"
  data = \"\"
  i = 1
  for x in XPLOITS
    data =  data + \"[\" + i + \"]\" + x + \"\\n\"
    i = i + 1
  end for
  print(format_columns(data))
  if typeof(waitFor) != \"string\" and typeof(waitFor) != \"number\" then return \"zap: invalid input\"
  if typeof(waitFor) == \"string\" then waitFor = waitFor.to_int
  if not waitFor then waitFor = user_input(\"Select an exploit #: \").val
  if waitFor == 0 then
    custom_mem = user_input(\"Enter memory address: \")
    if custom_mem == \"\" then return
    custom_exploit = user_input(\"Enter overflow: \")
    if custom_exploit == \"\" then return
    memory = [custom_mem , custom_exploit]
  else
    if waitFor > 0 and waitFor <= XPLOITS.len then
      memory = XPLOITS[waitFor - 1].split(\" \")
    else
      print(\"Invalid selection. \")
      return
    end if
  end if
  mem = memory.pull
  exploit = memory.pull
  inject = user_input(\"Enter ip or passwd for inject value or leave blank (press<b> return</b>)\"+char(10)+\":> \")
  print(\"Injecting address: \" + mem + \" with \" + exploit)
  result = metaLib.overflow(mem, exploit, inject)
  if result then 
    globals.BUFFER.push(result) // buffer result before handling it
    print colorRed+\"</b>zap:\"+colorWhite+\" sending <b>\"+result+\"</b> to \"+colorOrange+\"BUFFER\"
  end if
  if typeof(result) == \"shell\" then

    ob = user_input(colorWhite+\"</b>-- open shell in \"+colorOrange+\"BUFFER\"+CT+\"? [\"+colorOrange+\"Y\"+CT+\"/n]\"+char(10)+\"||: \",0,1)
    if ob.lower == \"n\" then print colorRed+\"</b>zap: \"+colorWhite+\"</b> returning... \" else return globals.memory_alpha(true,true)
    return result
  end if
  if typeof(result) == \"computer\" then
    print(\"Obtained \" + result)
    hooked_comp(result)
  end if
  if typeof(result) == \"file\" then
    print(\"Obtained \" + result)
    list_files(result.parent)
  end if
  //if result then  globals.BUFFER.push(result)
  print(\"-- returning... \")
  return result
end function

roil = function(inject=0)
  if not metaLib then return
  if XPLOITS.len < 1 then
    print(\"No xploits found.\")
    return
  end if
  print(format_columns(XPLOITS))
  prompt_me = false
  if inject == \"-p\" or inject == \"--prompt\" then prompt_me = true 
  if prompt_me then inject = user_input(\"Enter lan_ip or password for inject value (<<b>enter</b>>=\"\"pass\"\",q=quit):\"+char(10)+\":> \")
  if not inject then inject = \"\"
  for X in XPLOITS
    x = X.split(\" \")
    mem = x[0]
    val = x[1]
    result = metaLib.overflow(mem, val, inject)
    print(\"Hooked: \" + typeof(result) + \" with \" + mem + \" \" + val)
    if result then globals.BUFFER.push(result) // buffer the result before handling it
    if typeof(result) == \"shell\" then
      if prompt_me then shell_prompt(result)
      print colorGold+\"[BUFFERING SHELL]\"
    end if
    if typeof(result) == \"file\" then
      if prompt_me then list_files(result)
      print colorGreen+\"[BUFFERING FILE]\"
    end if
    if typeof(result) == \"computer\" then
      if prompt_me then hooked_comp(result)
      print colorWhite+\"[BUFFERING COMPUTER]\"
    end if
  end for
end function

//Depricated function. Use roil.
zap_it = function()
  if MEMORY == null then return \"Run a scan first.\"
  print(format_columns(XPLOITS))
  inject = user_input(\"Enter ip or passwd for inject value or leave blank (press<b> return</b>)\"+char(10)+\":> \")
  memory = globals.MEMORY
  for mem in memory
    address = metaxploit.scan_address(metaLib, mem).split(\"Unsafe check: \")
    for add in address
      if add == address[0] then continue
      value = add[add.indexOf(\"<b>\")+3:add.indexOf(\"</b>\")]
      value = value.replace(\"\\n\", \"\")
      result = metaLib.overflow(mem, value, inject)
      print(\"Hooked: \" + typeof(result) + \" with \" + mem + \" \" + value)
      if result then  globals.BUFFER.push(result) // buffer the result before handline it
      if typeof(result) == \"shell\" then
        shell_prompt(result)
      end if
      if typeof(result) == \"file\" then
        list_files(result)
      end if
      if typeof(result) == \"computer\" then
        hooked_comp(result)
      end if
      //if result then  globals.BUFFER.push(result)
    end for
  end for
end function

update_port_info = function()
  if DEBUG then print(\"Updating port info...\" )
  globals.portInfo = \"???\"
  globals.tarLan = \"???\"
  if PORT_MAP.hasIndex(globals.targetPort) then
    globals.portInfo = PORT_MAP[globals.targetPort][2]
    globals.tarLan = PORT_MAP[globals.targetPort][-1]
  else
    for p in PORT_MAP
      if p[\"value\"][3] == globals.targetIP and p[\"value\"][0] == globals.targetPort then
        globals.portInfo = p[\"value\"][2]
        globals.tarLan = globals.targetIP
      end if
    end for
  end if
end function

display_portmap = function(bool_dump=0)
  port_index = globals.PORT_MAP.indexes
  display = \"\"
  for n in port_index
    if n == 1 then continue
    display = display + (PORT_MAP[n][0] + \" \" + PORT_MAP[n][1] + \" \" + PORT_MAP[n][2] + \" \" + PORT_MAP[n][3] + \"\\n\")
  end for
  update_port_info
  if bool_dump then return format_columns(display)
  print(format_columns(display))
  return 0
end function
//services={}
//services.push(\"pNum\")
make_portmap = function(router, comps, q_bool)
  //services = {\"pNum\":[ \"PORT\" , \"STATUS\" , \"SERVICE INFO\" , \"LAN\" ]}
  //services.push(\"pNum\")
  services = {}
  if not q_bool then print(\"Building port map... \")
  services[\"pNum\"] = [ \"PORT\" , \"STATUS\" , \"SERVICE INFO\" , \"LAN\" ]
  if DEBUG then print(\"after pnum\")
  ports = router.used_ports
  r_lib_v = \"router \" + router.kernel_version
  services[\"router\"] = [ router.public_ip,  \"gateway\", r_lib_v, router.local_ip ]
  if DEBUG then print \"debug: obtained port object and router version\"
  for p in ports
    state = \"open\"
    if p.is_closed then state = \"closed\"
    //services.push(p.port_number + \" \" + state + \" \" + router.port_info(p) + \" \" + p.get_lan_ip + \"\\n\")
    services[p.port_number] = [p.port_number, state , router.port_info(p) , p.get_lan_ip]
  end for
  if DEBUG then print \"debug: services mapped\"
  cpl = null
  services[\"-\"] = [\"-\",\"-\",\"-\",\"-\"]
  for cip in comps
    if DEBUG then print \"debug: top of loop\"+char(10)+\"-- attempting router.device_ports(\"+cip+\")\"
    cpl = router.device_ports(cip)
    if DEBUG then print \"debug: got: \"
    if DEBUG then print \"--: \"+cpl
    if typeof(cpl) == \"string\" then
      if DEBUG then print \"debug: computer port list is a string: firewall detected\"
      services[cip] = [\"Firewall\", \"Detected\", \"@ addr:\", cip]
    else
      if DEBUG then print \"debug: computer port list is a list:\"+cpl
      for cp in cpl
        i = 0
        lip = cp.get_lan_ip
        if DEBUG then print \"debug: port.get_lan_ip: \"+lip 
        pn = cp.port_number
        if DEBUG then print \"debug: port.port_number: \"+pn
        rpi = router.port_info(cp)        
        if DEBUG then print \"debug: router.port_info(port): \"+rpi
        //services[cp.get_lan_ip+\":\"+cp.port_number] = [cp.port_number, \"internal\", router.port_info(cp), cp.get_lan_ip]
        services[lip+\":\"+pn] = [pn, \"internal\", rpi, lip]
        i = i + 1
      end for
    end if
  end for
  globals.PORT_MAP = services
  if DEBUG then print \"debug: portmap complete, displaying...\"
  display_portmap(q_bool)
  return 0
end function

who_scan = function(tally=15,pause=1,quiet=false) // tally is depricated and no longer used
  ip = globals.targetIP
  //tally = 255
  t_router = null
  is_switch = false
  if is_valid_ip(ip) then
    if not quiet then print(char(10)+\"Scanning ip: \" + ip)
    // if not quiet and is_lan_ip(ip) then
    //   waitFor = user_input(colorWhite+\"[<b>1</b>] get_router [2] get_router(</b>\"+ip+\"<b>) [3] get_router(</b>\"+localmachine.network_gateway+\"<b>)\"+CT+char(10)+\"(enter=1, q=quit)||: \",0,1)
    //   if waitFor.lower == \"q\" then return
    //   if waitFor == \"\" then waitFor == \"1\"
    //   if waitFor == \"1\" then
    //     t_router = get_router
    //   else
    //     if waitFor == \"2\" then
    //       t_router = get_router(ip)
    //     else
    //       if waitFor == \"3\" then
    //         t_router = get_router(localmachine.network_gateway)
    //       else
    //         t_router = get_router
    //       end if
    //     end if
    //   end if
    // else
    t_router = get_router(ip)
    // end if
    if DEBUG then print \"debug: t_router is a: \"+typeof(t_router)
    if DEBUG then print \"ip is: \"+ip
    if not t_router then
      if not is_lan_ip(ip) then 
        print(colorRed+\"probe: ip: \"+ip+\" not found.\"+CT)
        return
      end if
      if not quiet then print(\"probe: router not found at: \"+colorLightBlue+ip)
      ip = ip.split(\"\\.\")
      ip[-1] = 1
      ip = ip.join(\".\")
      if not quiet then print(\"probe: attempting to locate router at: \"+char(10)+colorWhite+ip+CT)
      t_router = get_router( ip )
      if not t_router then 
        if not quiet then print(colorRed+\"probe: failed to find router. portscan aborted.\")
        return
      end if
    end if
    if not quiet then print(t_router.public_ip + \" details:\")
    if not quiet then print(whois(t_router.public_ip).replace(\"Neurobox Network\",colorCyan+\"<size=150%>Neurobox Network</size>\"+CT))
    if not quiet then print(\"Getting all reachable computers on \" + t_router.local_ip + \"'s network...\")
    clist = null
    if not quiet then print(\"------------------------\")
    if not quiet then print(colorGreen+\"<align=center>(<|>)</align>\"+CT)
    if get_router.public_ip == get_router(ip).public_ip then clist = globals.lan_probe(get_router(ip),\"local\").split(char(10)) else clist = globals.lan_probe(get_router(ip),\"remote\").split(char(10))
    //clist.sort
    numComps = clist.len
    if not quiet then print(\"Found: \" + numComps + \" machines connected to: \" + char(10)+ t_router.essid_name + \" : \" + t_router.bssid_name)
    if not quiet then print(clist.join(char(10)))
    if not quiet then print(\"-----------\")
    if not quiet then print(\"Firewall Rules:\")
    rlz = t_router.firewall_rules
    if not quiet then
      if rlz.len then print(rlz.join(\" \")) else print(\"-none-\")
      print(\"___\")
    end if
    make_portmap(t_router, clist, quiet)
    if pause and not quiet then pause = user_input(\"Press return to continue...\")
  else
    if not quiet then print(\"Host does not exist, or is currently offline.\")
  end if
  return 0
end function

scan_memory = function()
  if globals.metaLib then print(metaLib.lib_name + \" v \" + metaLib.version) else return \"metaLib not loaded\"
  scanalysis = []
  data = \"\"
  globals.MEMORY = metaxploit.scan(metaLib)
  globals.meta_scan = []
  for mem in MEMORY
    address = metaxploit.scan_address(metaLib, mem).split(\"Unsafe check: \")
    globals.meta_scan.push(address)
    for add in address
      if add == address[0] then continue
      value = add[add.indexOf(\"<b>\")+3:add.indexOf(\"</b>\")]
      value = value.replace(\"\\n\", \"\")
      scanalysis.push(mem + \" \" + value)
    end for
  end for
  for s in scanalysis
    data = data + s + \"\\n\"
  end for
  print(format_columns(data))
  globals.XPLOITS = scanalysis
  waitFor = user_input(\"<b>Press return to continue...</b>\")
  return 0
end function

load_lib = function(lib_path)
  if DEBUG then print \"load_lib_path: \"+lib_path
  if lib_path.len < 1 then return \"aborting...\"
  print \"meta: clearing metaLib and net_session...\"
  globals.metaLib = null 
  globals.net_session = null // clear out net_session since we are working with a local lib
  new_lib = metaxploit.load(lib_path)
  if not new_lib then new_lib = metaxploit.load(\"/lib/\"+lib_path)
  if new_lib then
    print \"metaLib: linking \"+colorLightBlue+new_lib.lib_name+\"<color=blue> v </color>\"+new_lib.version+char(10)
    // if waitFor == \"n\" or waitFor == \"N\" then
    //   print(\"Aborting...\")
    //   return \"Aborting...\"
    // end if
    globals.metaLib = new_lib
  else
    print colorOrange+\"load_lib: File not found. \"
    return 0
  end if
  print metaLib.lib_name + \" v \" + metaLib.version
  return metaLib.lib_name + \" v \" + metaLib.version
end function

get_lib = function(waitFor=0,this_lib=null)
  address = globals.targetIP
  port = globals.targetPort
  if not waitFor then waitFor = user_input(colorOrange+\"Establishing Net_Session...\"+char(10)+
  colorOrange+\"This will leave a log on servers but not routers. Continue?\"+char(10)+
  \"[<b>Y</b> = Link Remote Lib] [<b>l</b> = Link Local Lib Instead] [n = No]\"+CT+char(10)+
  \"(<b>enter<b>=Y) ||: \",0,1)
  if waitFor == \"n\" or waitFor == \"N\" then
    print(\"Aborting connection...\")
    return \"Aborting connection...\"
  else
    if waitFor == \"l\" or waitFor == \"L\" then
      if this_lib then return load_lib(this_lib)
      lib_folder = localmachine.File(\"/lib\")
      if not lib_folder then
        print(\"/lib not found!\")
        return \"/lib not found!\"
      end if
      lib_list = lib_folder.get_files
      i = 0
      print colorGold+\"</b>load_lib: displaying contents of /lib on <u>active shell:\"
      print colorGold+\"</b>-- note: if importing a metaxploit object via \"+colorWhite+\"meta -i\"+CT+\":\"
      print colorWhite+\"</b>--: the list shown may not match the target's actual files\"
      for l in lib_list
        print(colorGold+\"</b>[\"+colorWhite+i+CT+\"] \" + l.name)
        i = i + 1
      end for
      selection = user_input(colorGold+\"load_lib:\"+colorWhite+\" select a lib.so to load: \"+CT).val
      if selection >= 0 and selection < i then
        return load_lib(lib_list[selection].path)
      else
        print(\"Invalid selection.\")
      end if
      return \"Invalid selection.\"
    end if
  end if
  if not localmachine.is_network_active then
    print(colorOrange+\"No network connection!\")
    return \"no_network\"
  end if
  if DEBUG then print \"debug: calling net_use\"
  if port == \"router\" then
    globals.net_session = metaxploit.net_use( address )
    if typeof(globals.net_session) == \"netsession\" then globals.routerLib = globals.net_session.dump_lib
  else
    globals.net_session = metaxploit.net_use( address, port )
  end if
  if not globals.net_session then
    print(\"Error: can't connect to net session\")
    return \"Error: can't connect to net session\"
  end if
  globals.metaLib = globals.net_session.dump_lib
  print(\"metaLib: loaded: \"+metaLib.lib_name + \" v \" + metaLib.version)
  return (metaLib.lib_name + \" v \" + metaLib.version)
end function

set_port = function()
  if PORT_MAP then display_portmap
  print(\"<b>[ \" + targetIP + \" ] [ \" + targetPort + \" ]</b>\")
  waitFor = user_input(\"Enter target port: \")
  if waitFor.to_int >= 1 then
    globals.targetPort = waitFor.to_int
    print(\"Port changed. Please rescan metaLib.\")
  else
    print(\"Invalid port. Defaulting to router.\")
    globals.targetPort = \"router\"
  end if
  update_port_info
end function

set_ip = function()
  working = true
  if PORT_MAP then display_portmap
  print(\"[ \" + targetIP + \" ] [ \" + targetPort + \" ]\")
  while working
    globals.targetIP = user_input(\"\\nPress <return> for localhost or\\nEnter target IP: \")
    print(targetIP)
    if globals.targetIP == \"\" then
      globals.targetIP = localmachine.public_ip
      globals.targetPort = \"router\"
      return true
    end if
    if is_lan_ip(globals.targetIP) then
      print(\"LAN IP\")
      if globals.targetIP[-1] == 1 then
        debug = \"router\"
      else
        debug = user_input(\"Enter target port: \").val
      end if
      if debug < 1 then
        print(\"Defaulting to router.\")
        debug = \"router\"
      end if
      globals.targetPort = debug
      working = false
    end if
    print(targetIP)
    if working then
      if is_valid_ip(globals.targetIP) then
        print(\"Valid IP\")
        debug = user_input(\"Enter target port or leave blank for router: \")
        if debug.val > 1 then
          globals.targetPort = debug.val
        else
          globals.targetPort = \"router\"
        end if
        working = false
      else
        print(\"Invalid IP.\")
      end if
    end if
  end while
  return true
end function

menu_launcher = function(cursor)
  if cursor == 0 then
    memory_alpha
    return
  end if
  if cursor == 1 then
    if targetIP and targetPort > 1 then
      secure_connect(shell)
    else
      print(\"Please set valip ip and port for secure session.\" )
    end if
  end if
  if cursor == 2 then
    return shell_prompt(shell)// stub, replace with 5hell
  end if
  if cursor == 3 then
    if targetIP then
      fw_rules
    else
      print(\"Please set target IP\")
      return
    end if
  end if
  if cursor == 4 then
    print(command.scribus)
    return
  end if
  if cursor == 5 then
    if T_BUF.len > 1 then
      transmit(T_BUF.join(char(10)))
    else
      print(\"Error: TBUF empty!\")
    end if
    return
  end if
  if cursor == 6 then
    print( command.kraken(0) )
    return
  end if
  if cursor == 7 then
    if targetPort == \"router\" then return
    if not targetIP then return
    print( mail_user_list( targetIP, targetPort ) )
    return
  end if
end function

page_two = function()
  cursor_position = 0
  rgb0 = colorRed
  //plugins = {\"position\" : \"function\", 0 : secure_connect, 1 : clip_board, 2 : shell_prompt, 3 : display_portmap }
  doing_stuff = true
  while doing_stuff
    print
    print(\"0001020304050607080900\")
    if cursor_position == 0 then
      print(rgb0+\"0001020.MALP..07080900\"+CT)
    else
      print(\"0001020.MALP..07080900\")
    end if
    if cursor_position == 1 then
      print(rgb0+\"0001020..SSH..07080900\"+CT)
    else
      print(\"0001020..SSH..07080900\")
    end if
    if cursor_position == 2 then
      print(rgb0+\"0001020.SHELL.07080900\"+CT)
    else
      print(\"0001020.SHELL.07080900\")
    end if
    if cursor_position == 3 then
      print(rgb0+\"00010FW.RULES.07080900\"+CT)
    else
      print(\"00010FW.RULES.07080900\")
    end if
    if cursor_position == 4 then
      print(rgb0+\"0001020.SCRIBUS.080900\"+CT)
    else
      print(\"0001020.SCRIBUS.080900\")
    end if
    if cursor_position == 5 then
      print(rgb0+\"0001020.TxBUF.07080900\"+CT)
    else
      print(\"0001020.TxBUF.07080900\")
    end if
    if cursor_position == 6 then
      print(rgb0+\"0001020.KRAKEN.7080900\"+CT)
    else
      print(\"0001020.KRAKEN.7080900\")
    end if
    if cursor_position == 7 then
      print(rgb0+\"0001020.SMTPUL.7080900\"+CT)
    else
      print(\"0001020.SMTPUL.7080900\")
    end if
    print(\"[q]1020304050607080900\")
    waitFor = user_input(\":||006<b>v</b>7<b><</b>8<b>></b>9<b>^</b>00||: \",0,1)

    if waitFor == 7 or waitFor == \"LeftArrow\" or waitFor.lower == \"q\" then
      // west
      doing_stuff = false
    end if
    if waitFor == 8 or waitFor == \"RightArrow\" or waitFor == \"Return\" or waitFor == \"Enter\" then
      // east/launch
      menu_launcher(cursor_position)
      //do stuff
    end if
    men_min = 0
    men_max = 7
    if waitFor == 9 or waitFor == \"UpArrow\" then
      //north
      if cursor_position == men_min then
        cursor_position = men_max
        continue
      end if
      if cursor_position > men_min then
        cursor_position = cursor_position - 1
        continue
      end if
    end if
    if waitFor == 6 or waitFor == \"DownArrow\" then
      // south
      if cursor_position == men_max then
        cursor_position = men_min
        continue
      end if
      if cursor_position < men_max then
        cursor_position = cursor_position + 1
        continue
      end if
    end if
  end while
end function

sphinx_switch = function(resolve,tt)
  if resolve.lower == \"q\" then
    return false
  end if
  if resolve.lower == \".\" then 
    if not targetIP then
      print(\"Please set target IP and Port before continuing.\")
    else 
      print(command.dig(targetIP,str(targetPort)))
    end if
    return true
  end if
  if resolve == \"-\" then
    print(command.purge(\"-x\"))
    return true
  end if
  if resolve == \"+\" or resolve == \"=\" then
    if targetIP and targetPort then
      print(command.linkdb(get_lib,\"-y\"))
    else
      print(colorOrange+\"Please set target IP and Port before continuing.\")
    end if
    return true
  end if
  if resolve.lower == \"a\" then
    if metaLib then
      print colorRed+\"zap: \"+colorWhite+\" obtained: \"+select_attack
    else
      print(\"Error: metaLib not loaded. \")
    end if
    return true
  end if
  if resolve.lower == \"z\" then
    print(\"Wiping local log file...\")
    silentclean
    print(\"Complete.\")
  end if
  if resolve == \"0\" or resolve.lower == \"p\" then
    if not localmachine.is_network_active then 
      print(colorOrange+\"No Network Connection!\")
      return true
    end if
    if targetIP then
      who_scan
    else
      set_ip
      who_scan
    end if
    return true
  end if
  if resolve == \"1\" or resolve.lower == \"s\" then
    if metaLib then
      //get_lib
      scan_memory
    else
      print(\"Please establish net connection: [+] before scanning.\" )
    end if
    return true
  end if
  if resolve == \"2\" or resolve.lower == \"r\" then
    if targetIP and metaLib then
      print(\"Casting roi1 storm...\")
      //zap_it
      roil
    else
      print(\"Error: metaLib not loaded.\" )
    end if
    return true
  end if
  if resolve == \"3\" or resolve.lower == \"d\" then
    if globals.metaLib and tt == \"local\" then
      confirm = user_input(\"Scan local lib: \"+globals.metaLib.lib_name+\" and update database? [Y/n] ||: \",0,1)
      if confirm.lower != \"n\" then command.db(\"-l\", metaLib.lib_name) else print(\"aborting...\")
      return true
    else
      if not localmachine.is_network_active then 
        print(colorOrange+\"No network connection!\")
        return true
      end if
      if globals.targetIP and globals.targetPort then
        confirm = user_input(\"Scan remote lib: \"+globals.targetIP+\" \"+globals.targetPort+\" and update database? [Y/n] ||: \",0,1)
        if confirm.lower != \"n\" then command.db(\"-r\", globals.targetIP, globals.targetPort)
        return true
      else
        print(\"Please set a target IP and port.\" )
      end if
    end if
    return true
  end if
  if resolve == \"*\" or resolve == \"/\" then 
    if globals.net_session then print command.db(\"-r\",\"*\") else print command.db(\"-l\",\"*\")
    return true
  end if
  if resolve == \"4\" or resolve.lower == \"i\" then
    catch = set_ip
    return true
  end if
  if resolve == \"5\" then
    set_port
    return true
  end if
  if resolve == \"6\" or resolve == \"DownArrow\" then
    command.mail
    return true
  end if
  if resolve == \"7\" or resolve == \"LeftArrow\" or resolve.lower == \"m\" then
    memory_alpha
    return true
  end if
  if resolve == \"8\" or resolve == \"RightArrow\" then
    page_two
    return true
  end if
  if resolve == \"9\" or resolve == \"UpArrow\" then
    r_hecks
    return true
  end if
  if resolve == \"?\" or resolve == \"F1\" then print_help
  // default
  return true
end function


print_help = function()
  print(colorRed+\"Sphinx</color> v\" + sphinx_version + \",<color=white> by Plu70   </b></color>running on localhost: \"+localmachine.local_ip)
  print(\"<b>////////////////////////////////////////////</b>\"+CT)
  print(\"<b>Press the key in </b>[]<b>'s to activate a command:\")
  print(\"A MetaLib is a scanned library (e.g. libssh 1.0.1) aka a<b> lib </b>\")
  print(\"A vuln is a vulnerability in a MetaLib that may be exploited\")
  print
  print(colorWhite+\"To begin, select an ip and port to target:\")
  print(colorCyan+\"</b>[\"+colorWhite+\"4</b></color>] or [\"+colorWhite+\"i</b></color>] - set target IP and port \\n-- <b>leave blank to default to current gateway\")
  print(colorCyan+\"</b>[\"+colorWhite+\"5</b></color>] or [\"+colorWhite+\"p</b></color>] - manually change target port without changing target IP\")
  print(colorCyan+\"</b>[\"+colorWhite+\"0</b></color>] or [\"+colorWhite+\"w</b></color>] - port scan (nmap) target IP\"+char(10)+
  \"-- if target IP is not a router, 5phinx will attempt to locate the router, halfheartedly\")
  print(colorCyan+\"</b>[\"+colorWhite+\"+</b></color>] or [\"+colorWhite+\"=</b></color>] - connect or load MetaLib\"+char(10)+
  \"--: [<b>y</b>] or <b>enter</b> establishes a net_session</b> \"+char(10)+
  \"--: this leaves a connection established log on servers but not on routers\"+char(10)+
  \"--: selecting [<b>l</b>] instead loads a <b>local lib</b> for scanning/exploiting\")
  print(\"--: if the target MetaLib is known in the database 5phinx will automatically link the entry\\n--: and load the vulns (xploits) into memory\")
  print(\"[\"+colorWhite+\"-</b></color>] - will unload the currently loaded MetaLib and clear vulns in memory\")
  print(colorCyan+\"</b>[\"+colorWhite+\"1</b></color>] or [\"+colorWhite+\"s</b></color>] - scan MetaLib at target IP:port and load vulns (xploits) into memory.\"+char(10)+
  \"--: this does <u>not</u> update the database\"+char(10)+
  \"--: while the vuln requirements may be viewed in malp option [2] \"+char(10)+
  \"--: the information is not stored\"+char(10)+
  \"--: this is useful if you: want to scan a target without writing to the target's filesystem\"+char(10)+
  \"--: or you want to scan a target without overwriting you current database entry\")
  print(colorCyan+\"</b>[\"+colorWhite+\"2</b></color>] or [\"+colorWhite+\"r</b></color>] - perform 'hail mary' attack using all vulns (xploits) loaded into memory\"+char(10)+
  \"--: does not database results\")
  print(colorCyan+\"<b>[\"+colorWhite+\"3</b></color>] or [\"+colorWhite+\"d</b></color>] - scans the target IP and port\"+char(10)+
  \"--: if a local metaLib has been loaded with [<b>=</b>] then db will database that instead of the target IP\"+char(10)+
  \"--: attacks using all exploits found\"+char(10)+
  \"--: <b>updates the database</b> with the results</b>\"+char(10)+
  \"--: loads vulns (xploits) to memory\"+char(10)+
  \"--: will overwrite the entry if a lib is databased again\"+char(10)+
  \"--: it is not necessary to link a remote lib with [=] to use db on a remote target\") 
  print(colorCyan+\"[\"+colorWhite+\"a</b></color>] - select a single attack from memory to launch at the target\"+char(10)+
  \"--: the same as the <b>zap</b> command\"+char(10)+
  \"--: to manually enter a [mem] [string] press enter at the menu and fill in the values\")
  print(colorCyan+\"</b>[\"+colorWhite+\".</b></color>] - run the <b>dig</b> command against the target (see dig -h)\"+char(10)+
  \"--: if dig.bat is not in rkit, a very basic dig.bat will be created\"+char(10)+
  \"--: edit dig.bat to perform whatever tasks you want dig to auto-execute when attacking the target\"+char(10)+
  \"--: dig uses the 'do' command to perform actions\"+char(10)+
  \"--: you may include instructions in dig.bat to launch other bat files with do\"+char(10)+
  \"--: any bat file, including dig.bat, may contain a call to shell.launch 5hell with a 'do' launch parameter\"+char(10)+
  \"--: this allows you to spread 5hell like the plague\"+char(10)+
  \"--: dig does not support digging /lib, use a do script for that\")
  print(colorCyan+\"</b>[\"+colorWhite+\"*</b></color>] or [\"+colorWhite+\"/</b></color>] - run <b>db</b> against all libs or ports in /lib or at target IP\"+char(10)+
  \"--: if a local lib is linked then all libs in /lib will be databased\"+char(10)+
  \"--: if no lib is linked then all libs in /lib will be databased\"+char(10)+
  \"--: link a net_session with a port or router on the target to db all reachable ports\")
  print(\"--:<b> all results from <b>[2], [3], [.], [*], and [a]</b> \"+char(10)+
  \"--: are sent to the \"+colorOrange+\"BUFFER</color></b> in memory alpha\")
  print(\"[6] - access the mail command\"+char(10)+
  \"--: may also use the down arrow key\")
  print(colorCyan+\"<b>[\"+colorWhite+\"7</b></color>] or [\"+colorWhite+\"m</b></color>] - access the malp command (Memory Alpha)\\n--: you may also use the <u>left_arrow</u></b> key\")
  print(\"--: from malp select \"+colorOrange+\"[5] to access the BUFFER\")
  print(\"[8] - access xtra menu, may also use the right arrow key\")
  print(\"[9] - access bank heist, may also use the up arrow key\\n--: n.b. bank heist is kinda crappy\\n--: and bank accounts contain almost nothing\")
  print(colorCyan+\"</b>[\"+colorWhite+\"z</b></color>] - wipe the local system.log\"+char(10)+
  \"--: sets log to a text file of size 0\"+char(10)+
  \"--: when returning to 5phinx's main menu, if the log has changed, an alert will print\")
  print(\"[\"+colorWhite+\"F1</b></color>] or [?] - access this help file \")
  print(\"[<b>q</b>] - leave 5phinx and return to 5hell \\n--: preserves state so you may return\"+char(10)+\"--: shares state with 5hell\")
  print
  print(\"n.b. running command.probe from 5hell will set the target IP and port for 5phinx\")
  print(\"n.b. command.zap in 5hell is the same as [a] in 5phinx\")
  print(\"n.b. command.roil in 5hell is the same as [2] in 5phinx\")
  print(\"n.b. command.meta link|load  in 5hell is the same as [=]/[+] in 5phinx\")
  print(\"n.b. database.csv is always <b>written</b> to /root/rkit/database.csv\")
  print(\"n.b. database.csv may be read from anywhere (uses first copy found on system)\")
  print(\"n.b. convention is to keep a copy of 5hell, metaxploit, crypto, database.csv\"+char(10)+
  \"--: in /root/rkit along with other useful tools for easy uploading\"+char(10)+
  \"--: you may use <b>kore -r</b> to quickly construct the rkit\")
  print
  print(\"5hell/5phinx does not phone home and therefore does not autoupdate\"+char(10)+
  \"--: 5hell is now open source so the above is a moot point\")
  print(\"5hell/5phinx is a product of Ra'al Tek and is written by jhook777 aka Plu70 aka Ra'al\")
  print(\"all rights reserved 2020-2024\")
  print
  stop = user_input(\"press <<b>anyKey</b>> to continue\",0,1)
end function

mail_widget = function(step)
  mw_dat = globals.inbox.fetch
  first_mail = mw_dat[0].split(char(10))

  i = first_mail[2].split(\" \")
  i = i[1]
  read_mail = mw_dat[this_mail].split(char(10))
  l = read_mail[2].split(\" \")
  l = l[1]
  show_mail = globals.inbox.read(l).split(char(10))
  if i == globals.last_mail then
    if step < show_mail.len then return \" {\"+colorWhite+this_mail+CT+\"} \"+slice( show_mail[step], 0 , 42 )+char(10)+\":: \"+slice( show_mail[step], 42, 80 )
    return \" {\"+colorWhite+this_mail+CT+\"} \"+show_mail[2]
  end if
  globals.last_mail = i
  return colorRed+\" {*new*} \"+CT+first_mail[3]
end function

// Start Main Menu
main = function()
  user_log_file = get_shell.host_computer.File(\"/var/system.log\")
  logSize = 0
  first_run = true
  running = true
  count = 0
  while running
    if targetPort == 0 or targetPort == \"0\" then targetPort = \"router\"
    count = count + 1
    if count > 7 then count = 1
    option = null
    alert = false
    last_log_size = logSize
    user_log_file = get_shell.host_computer.File(\"/var/system.log\")
    if user_log_file then logSize = user_log_file.size
    if logSize != last_log_size and not first_run then
      print(colorRed + \"Alert! /var/system.log has changed!\"+CT)
      alert = true
    else
      print
      first_run = false
    end if
    target_type = \"local\"
    print(char(10)+colorWhite + \"5phinx\"+char(8482) +\" \"+ sphinx_version + \", by Plu70 localhost: \"+localmachine.local_ip+CT)
    print(\"<b>/////////////////////////////////////////////</b>\")
    if metaLib and (metaLib.lib_name == \"metaxploit.so\" or metaLib.lib_name == \"crypto.so\" or metaLib.lib_name == \"net.so\" or metaLib.lib_name == \"init.so\" or metaLib.lib_name == \"kernel_module.so\" or metaLib.lib_name == \"libmail.so\"  or metaLib.lib_name == \"aptclient.so\") then
      target_type = \"local\"
    end if
    if PORT_MAP then
      update_port_info
      if targetPort == \"router\" or targetPort == 8080 then
        target_type = \"router\"
        if targetPort == 8080 then target_type = \"http\"
      else
        PI = portInfo.split(\" \")
        target_type = \"\"
        if typeof(PI[0]) == \"string\" and portInfo != \"\" and portInfo != \"???\" then
          target_type = \"computer\"
        end if
        if PI[0] == \"libcam\" or PI[0] == \"cam\" then target_type = \"camera\"
        if PI[0] == \"http\" then target_type = \"http\"
        if PI[0] == \"ssh\" then target_type = \"ssh\"
        if PI[0] == \"rshell\" then target_type = \"rshell\"
        if PI[0] == \"employees\" or PI[0] == \"criminals\" or PI[0] == \"students\" or PI[0] == \"bank\" then target_type = \"sql\"
        if PI[0] == \"smtp\" then target_type = \"mail\"
        if PI[0] == \"smartappliance\" then target_type = \"appliance\"
      end if
      if metaLib and (metaLib.lib_name == \"metaxploit.so\" or metaLib.lib_name == \"crypto.so\" or metaLib.lib_name == \"net.so\" or metaLib.lib_name == \"init.so\" or metaLib.lib_name == \"kernel_module.so\" or metaLib.lib_name == \"libmail.so\"  or metaLib.lib_name == \"aptclient.so\") then
        target_type = \"local\"
      end if
      if target_type == \"camera\" then
                          print(\"Target:________CAMERA_________Port Map: <b>Loaded</b>\")
      else
        if target_type == \"computer\" then
                          print(\"Target:_______SERVER__________Port Map: <b>Loaded</b>\")
        else
          if target_type == \"router\" then
                          print(\"Target:________ROUTER_________Port Map: <b>Loaded</b>\")
          else
            if target_type == \"http\" then
                          print(\"Target:_______WEB_SERVER______Port Map: <b>Loaded</b>\")
            else
              if target_type == \"local\" then
                          print(\"Target:________LOCAL__________Port Map: <b>Loaded</b>\")
              else
                if target_type == \"ssh\" then
                          print(\"Target:_______SSH_SERVER______Port Map: <b>Loaded</b>\")
                else 
                  if target_type == \"rshell\" then 
                          print(\"Target:_____RSHELL_SERVER_____Port Map: <b>Loaded</b>\")
                  else 
                    if target_type == \"sql\" then 
                          print(\"Target:_______SQL_SERVER______Port Map: <b>Loaded</b>\")
                    else 
                      if target_type == \"mail\" then 
                          print(\"Target:______MAIL_SERVER______Port Map: <b>Loaded</b>\")
                      else
                        if target_type == \"appliance\" then 
                          print(\"Target:_________DEVICE________Port Map: <b>Loaded</b>\")
                        else 
                          print(\"Target:___Set_Port_with_[5]___Port Map: <b>Loaded</b>\")
                        end if
                      end if
                    end if
                  end if
                end if
              end if
            end if
          end if
        end if
      end if
    else
      if targetPort then
        print(\"Target:___Map_with_[0]____Port Map:\"+colorOrange+\" Not</b> Loaded</color>\")
      else
        print(\"Target:___Set_with_[4]____Port Map:\"+colorOrange+\" Not</b> Loaded</color>\")
      end if
    end if
    if targetPort == \"router\" then print_port = \"0\" else print_port = targetPort
    print(format_columns(\"[ \" + targetIP + \" ] [ \" + print_port + \" ]\"))
    if portInfo then
      print(format_columns(\"[ \" + tarLan +   \" ] [ \" + portInfo +    \" ]\" ))
    end if
    if metaLib then
      print(format_columns(\"[\"+colorGreen+\"MetaLib: loaded\"+CT+\" [\" + NUM_SPLOITS + \"] Exploits Found]\"))
      print(format_columns(\"[MetaLib: <b>\"+metaLib.lib_name + \" v \" + metaLib.version+\"</b>]\"))
    else
      print(\"[MetaLib: \"+colorOrange+\"not loaded</b></color>] press [=] or [+] to link.\")
    end if
    if alert then
      print(colorRed + \"[/var/system.log: I/O detected \" + logSize + \"  bytes]\\n Alert! Filesize Change!\")
    else
      print(\"[Log I/O: \" + logSize + \" bytes]\")
    end if
    print
    print \"[<b>F1</b>] for <b>help\"
    if globals.HERMES == true then
      print(\"000\"+mail_widget(count))
    else     
      print(\"000102030405060708090<b>.\")
    end if
    if targetIP then
      print(\"0[<b><color=white>0</color></b>]....<b><color=white>P</color>ROBE</b>.....09<b>.\")
      print(\"00[<b><color=white>1</color></b>]...<b><color=white>S</color>CAN</b>..070809<b>.\")
    else
      print(\"000102030405060708090<b>.\")
      print(\"000102030405060708090<b>.\")
    end if
    if targetIP and targetPort then
      print(\"000.[<b><color=white>2</color></b>].<b><color=white>R</color>OIL</b>....0809<b>.\")
      print(\"000..[<b><color=white>3</color></b>]<b><color=white>D</color>BASER</b>...809<b>.\")
    else
      print(\"001 SET IP WITH [<color=white>4</color>] 0<b>.\")
      print(\"000 SET PT WITH [<color=white>5</color>] 0<b>.\")
    end if
    print(\"[\"+colorWhite+\".\"+CT+\"]DIG.[\"+colorWhite+\"4\"+CT+\"]<b>IP</b>.[\"+colorWhite+\"5</b></color>]<b>PORT</b>.\")
    print(\"[Q][A][Z][\"+char(177)+\"].6<b>v</b>7<b><</b>8<b>></b>9<b>^</b>.\")
    option = user_input(\"[0][1][2][3][4][5].<b>||: \",0,1)
    running = sphinx_switch(option,target_type)
  end while
end function
//main
//exit(\"Goodbye.\")"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction7" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Copy the [color=cyan]5hell.5pk.src[/color] source file below, paste it in [color=green]CodeEditor.exe[/color], then build the file at [color=cyan]/root/src/5hell.5pk[/color]. Make sure to keep 'Allow import' checked."
fit_content = true

[node name="5hell5pkCodeEdit" type="CodeEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 300)
layout_mode = 2
text = "// 5hell v 4.0.0 by Plu70
// released v 4.0.0
// imports .5pk files from /root/src
ver = \"4.0.7_falling_skies\"
DEBUG = false // set to true by launching 5hell with --debug as any parameter
if params and params.indexOf(\"--debug\") >= 0 then DEBUG = true
size_of_5hell = \"156.171\"
///////////////////////////////////////

if DEBUG then print(\"<size=75%>loading globals...</size>\") else print(\"<align=center><mark=red><color=black>#</color></mark></align>\")
//
// these three stubs are set below by super_import
globals.metaxploit = null 
globals.crypto = null 
globals.apt_get = null
//
globals.localip = function()
	return localmachine.local_ip
end function
globals.pubip = function()
	return localmachine.public_ip
end function
//
// register macros
if DEBUG then print(\"<size=75%>registering macros...\")
if not get_custom_object.hasIndex(\"macros\") then get_custom_object.macros = {}
//
// globals
globals.BIGBRAIN = false
globals.GLASSPOOL = 0
globals.command_buffer = []
globals.shell = get_shell
globals.metaLib = null
globals.debugLib = null
globals.net_session = null
globals.localmachine = shell.host_computer
globals.currentPath = current_path
globals.homePath = home_dir
globals.enumerated = []
globals.tagged_for_scp = \"\"
globals.backup_meta = null
//globals.services = {}

targ = {\"ip\":\"0.0.0.0\", \"pt\":0} // legacy crap, targetIP and targetPort and HOME_SERVER make this superfluous. also pretty sure it's not documented
if params and params.len > 0 then targ.ip = params[0]
if params and params.len > 1 then targ.pt = params[1].to_int
//globals.localip = localmachine.local_ip
//globals.pubip = localmachine.public_ip
globals.neurobox_user = \"\"
globals.neurobox_pass = \"\"
globals.clip_board_alpha = \"\" 
globals.clip_board_beta = \"\"
globals.clip_board_gamma = \"\"
globals.clip_board_delta = \"\" // for do
globals.debug_username = \"\"
globals.debug_password = \"\" // neurobox debug credentials
globals.instance = globals.localmachine.File(program_path)
//
// while importing a starting dictionary is still possible it is no longer supported
// current runtime loading of cerebrum is 20 seconds and importing from filesystem is less than 1 second
// start dictionaries are therefore superfluous
if DEBUG then print(\"<size=75%>loading dictionary...</size>\")
// this function puts the dictionary in the custom object for use between nested launches without breaking legacy dictionary calls
globals.dict_a = function(import=0)  
	cobble = get_custom_object
	if typeof(import) == \"list\" then cobble.dictionary = import // set a new dicitonary from input: list
	if not cobble.hasIndex(\"dictionary\") then cobble.dictionary = [\"a\"] // set default dictionary if it doesn't exist
	return cobble.dictionary // return the dictionary in all cases as a list
end function
//// UPDATING THE DICTIONARY IS HANDLED BY COMMAND.CEREBRUM //////
//// COB import and COB export are now deprecated commented out
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
if DEBUG then ds = dict_a.len
if DEBUG then print(\"<size=75%>dictionary loaded...(\"+(ds/1000)+\"kb)</size>\")
globals.SAFEWORD = \"stop_code\" // use @STOP (or this value) in a do script and/or in an if statement within a do script to 'break' the do loop
globals.routerLib = null
globals.targetIP = null
globals.targetPort = \"router\"
globals.PORT_MAP = {}
globals.HERMES = false
globals.inbox = null
globals.BUFFER = [get_shell]
globals.XPLOITS = []
globals.MEMORY = null
globals.meta_scan = []
globals.T_BUF = [(localip+\"@\"+pubip)] // transmission buffer
//globals.T_BUF = []
globals.portInfo = null
globals.tarLan = null
globals.grepped_file = null
globals.airing = false
globals.mail_user = null
globals.last_mail = null
globals.this_mail = 0

colorRed = \"<color=#FF0000FF><b>\"
colorGreen = \"<color=#00FF00FF><b>\"
colorOlive = \"<color=#048004FF><b>\"
colorWhite = \"<color=#FFFFFFFF><b>\"
colorCyan = \"<color=#00FFFFFF><b>\"
colorGold = \"<color=#CCCC00FF><b>\"
colorBlack = \"<color=#000000FF><b>\"
colorOrange = \"<color=#FF8400FF><b>\"
colorViolet = \"<color=#8821FDFF><b>\"
colorMagenta = \"<color=#FF00C8FF><b>\"
colorLightBlue = \"<color=#2382FFFF><b>\"
CT = \"</color></b>\"
//

// import 5phinx -- this contains critical shared functions and the backbone of the hacking suite
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code(\"/root/src/5phinx.5pk\") // override=5phinx.5pk

globals.super_import // located in 5phinx.5pk; include_lib latest of: metaxloit, crypto, aptclient
// -- sets globals.metaxploit, globals.crypto, globals.apt_get 
// -- this will be consolidated soon(tm)
//
// import contrib -- this contains shared functions and commands contributed by the community
import_code(\"/root/src/contrib.5pk\") // override=contrib.5pk
//

globals.get_file = function(input_string)
	if DEBUG then print(\"debug: in_get_file: \"+@input_string)
	if typeof(input_string) == \"file\" then return input_string.path
	if typeof(@input_string) != \"string\" then return 0
	if input_string == \"\" or input_string == \" \" or not input_string then return 0
	if DEBUG then print \"debug: get_file: processing string: \"+@input_string
	if input_string.split(\"/\")[0] == \"\" then
		file = localmachine.File(input_string)
	else
		file = localmachine.File(currentPath+\"/\"+input_string)
  	if not file then file = localmachine.File(currentPath+input_string)
	end if
	if DEBUG then
		if file then print(\"File: [\"+file.path+\"]\") else print(\"File: [not found]\")
	end if
  if file then return file else return 0
end function
// end globals
if DEBUG then print(\"<size=75%>loaded get_file...</size>\")                       ////////////////////////////////
if DEBUG then print(\"<size=75%>loading 5hell.5pk...(\"+size_of_5hell+\"kb)</size>\")                   /////LOADING 5HELL///////////////////////////////////
if DEBUG then print(\"<size=75%>loading clipcommander.5pk...(6.660kb)</size>\")     ////////////////////////////////
command.clipa = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == \"function\" then
		globals.clip_board_alpha = @arg1
		print(colorCyan+\"</b>clipped: \"+typeof(@globals.clip_board_alpha))
		return @globals.clip_board_alpha
	end if
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<u>clipboard alpha || clipa || clipspace</u>\"+char(10)+\"Usage:\"+char(10)+\" clipa: pipe outputs to clipa with: command | clipa\"+char(10)+\" clipa [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}]\"+char(10)+\"-- add any of the above to clipa\"+char(10)+\"clipa -- <b>Returns</b> contents of clipa if no arguments.\"+char(10)+\"scribus @clipa -- edit clipa directly with the text editor.\"
	if arg1 == \"0\" then
		globals.clip_board_alpha = \"0\"
		print(colorCyan+\"</b>clipped: \"+typeof(@globals.clip_board_alpha))
		return globals.clip_board_alpha
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_alpha) == \"function\" then return @globals.clip_board_alpha else	return globals.clip_board_alpha
	end if
	globals.clip_board_alpha = arg1
	if arg1 == \"@tbuf\" then
		globals.T_BUF.pull 
		globals.clip_board_alpha = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+\"@\"+pubip)]
		//globals.T_BUF = []
	end if
	if arg1 == \"@cc\" then globals.clip_board_alpha = globals.command_buffer.join(char(10))
	if arg1 == \"@B\" then
		if globals.BUFFER.len < 1 then return \"BUFFER is empty.\"
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == \"function\" then print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(@b)+\":\"+typeof(@b)+\"</b>\") else print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(b)+\":\"+typeof(b)+\"</b>\")
			i = i + 1
		end for
		get = arg2
    if get and get != \"-m\" then get = arg2.to_int
    if get == \"-m\" then get = user_input(\"clipa:> \").to_int
		if typeof(get) != \"number\" then return \"BUFFER: invalid selection.\"
		if get >= 0 and get < BUFFER.len then globals.clip_board_alpha = globals.BUFFER[get] else return \"BUFFER: invalid selection.\"
	end if
	print(colorCyan+\"</b>clipa: clipped: \"+typeof(@globals.clip_board_alpha))
	if typeof(@globals.clip_board_alpha) == \"function\" then return @globals.clip_board_alpha else	return globals.clip_board_alpha
end function
command.clipb = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == \"function\" then
		globals.clip_board_beta = @arg1
		print(colorCyan+\"</b>clipped: \"+typeof(@globals.clip_board_beta))
		return @globals.clip_board_beta
	end if
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<u>clipboard beta || clipb || clipspace</u>\"+char(10)+\"Usage:\"+char(10)+\" clipb: pipe outputs to clipb with: command | clipb\"+char(10)+\" clipb [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}|function]\"+char(10)+\"-- add any of the above to clipb\"+char(10)+\"clipb -- <b>Returns</b> contents of clipb if no arguments.\"+char(10)+\"scribus @clipb -- edit clipb directly with the text editor.\"+char(10)+\"N.B. please be awake that command.<b>append</b> works a bit differently with clipb than with clipa or clipc.\"+char(10)+\"-- see append -h for more info.\"
	if arg1 == \"0\" then
		globals.clip_board_beta = \"0\"
		print(colorCyan+\"</b>clipped: \"+typeof(@globals.clip_board_beta))
		return globals.clip_board_beta
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_beta) == \"function\" then return @globals.clip_board_beta else	return globals.clip_board_beta
	end if
	globals.clip_board_beta = arg1
	if arg1 == \"@tbuf\" then
		globals.T_BUF.pull
		globals.clip_board_beta = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+\"@\"+pubip)]
		//globals.T_BUF = []
	end if
	if arg1 == \"@cc\" then	globals.clip_board_beta = globals.command_buffer.join(char(10))
	if arg1 == \"@B\" then
		if globals.BUFFER.len < 1 then return \"BUFFER is empty.\"
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == \"function\" then print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(@b)+\":\"+typeof(@b)+\"</b>\") else print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(b)+\":\"+typeof(b)+\"</b>\")
			i = i + 1
		end for
		get = arg2
		if get and get != \"-m\" then get = arg2.to_int
		if get == \"-m\" then get = user_input(\"clipb:> \").to_int
		if typeof(get) != \"number\" then return \"BUFFER: invalid selection.\"
		if get >= 0 and get < BUFFER.len then globals.clip_board_beta = BUFFER[get] else return \"BUFFER: invalid selection.\"
	end if
	print(colorCyan+\"</b>clipb: clipped: \"+typeof(@globals.clip_board_beta))
	if typeof(@globals.clip_board_beta) == \"function\" then return @globals.clip_board_beta else	return globals.clip_board_beta
end function
command.clipc = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == \"function\" then
		globals.clip_board_gamma = @arg1
		print(colorCyan+\"</b>clipped: \"+typeof(@globals.clip_board_gamma))
		return @globals.clip_board_gamma
	end if
	if arg1 == \"help\" or arg1 == \"-h\" then return \"<u>clipboard gamma || clipc || clipspace</u>\"+char(10)+\"Usage:\"+char(10)+\" clipc: pipe outputs to clipc with: command | clipc\"+char(10)+\" clipc [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}]\"+char(10)+\"-- add any of the above to clipc\"+char(10)+\"clipc -- <b>Returns</b> contents of clipc if no arguments.\"+char(10)+\"scribus @clipc -- edit clipc directly with the text editor.\"
	if arg1 == \"0\" then
		globals.clip_board_gamma = \"0\"
		print(colorCyan+\"</b>clipped: \"+typeof(@globals.clip_board_gamma))
		return globals.clip_board_gamma
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_gamma) == \"function\" then return @globals.clip_board_gamma else	return globals.clip_board_gamma
	end if
	globals.clip_board_gamma = arg1
	if arg1 == \"@tbuf\" then
		globals.T_BUF.pull
		globals.clip_board_gamma = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+\"@\"+pubip)]
		//globals.T_BUF = []
	end if
	if arg1 == \"@cc\" then	globals.clip_board_gamma = globals.command_buffer.join(char(10))
	if arg1 == \"@B\" then
		if globals.BUFFER.len < 1 then return \"BUFFER is empty.\"
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == \"function\" then print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(@b)+\":\"+typeof(@b)+\"</b>\") else print(\"[\"+colorWhite+i+CT+\"] - <b>\"+checkUser(b)+\":\"+typeof(b)+\"</b>\")
			i = i + 1
		end for
		get = arg2
		if get and get != \"-m\" then get = arg2.to_int
		if get == \"-m\" then get = user_input(\"clipc:> \").to_int
		if typeof(get) != \"number\" then return \"BUFFER: invalid selection.\"
		if get >= 0 and get < BUFFER.len then globals.clip_board_gamma = BUFFER[get] else return \"BUFFER: invalid selection.\"
	end if
	print(colorCyan+\"</b>clipc: clipped: \"+typeof(@globals.clip_board_gamma))
	if typeof(@globals.clip_board_gamma) == \"function\" then return @globals.clip_board_gamma else	return globals.clip_board_gamma
end function
command.passwd = function(arg1, arg2, arg3=0, arg4=0)
  if arg1 == \"help\" or arg1 == \"-h\" then return \"<u>Password || Change Password || passwd\"+char(10)+\"Usage: passwd [opt: user] [opt: password] -- change password for user\"+char(10)+\"- will prompt for missing options\"
	user = null
	pass = null
	if arg1 then user = arg1
	if arg2 then pass = arg2
	if not user then user = user_input(\"passwd: change password for which user? :> \")
  if not pass then pass = user_input(\"passwd: select a new password for: \"+user+\":> \",1,0)
	if pass == \"\" or pass == \" \" then return \"aborting...\"
  try = localmachine.change_password( user, pass)
  if try == 1 then return \"passwd: \"+colorWhite+\"password for \"+user+\" updated to: \"+char(10)+pass
  return try
end function
command.echo = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"ECHO || echo || Echo || echO\"+char(10)+
	\"Usage: echo [up] [to] [four] [params] -- returns concatonated params to the terminal\"+char(10)+char(10)+
	\"General usage is to echo text back to the terminal during batch script/macro execution.\"+char(10)+
	\"However, it may also be used to feed input to another command or concatonate outputs\"+char(10)+
	\"of multiple commands. You may use floating quotes (single quotes not touching another\"+char(10)+
	\"character) to wrap complex input parameters. Examples:\"+char(10)+
	\"|> echo bob burger  --  output: bob burger\"+char(10)+
	\"|> echo \"\" Eat at Joe's Diner. \"\" <color=red>Because</color> \"\" it's the best. \"\" \"+char(10)+
	\"-- output: Eat at Joe's diner. <color=red>Because</color> it's the best.\"+char(10)+
	\"|> echo three four | echo one two -- output: one two three four\"+char(10)+
	\"Here's a fairly useless example, lol:\"+char(10)+
	\"|> cat file.txt | echo | poke file2.txt | cat | echo | poke file3.txt\"+char(10)+char(10)+
	\"Simple enough. You may use richtext in the echo to spruce it up.\"+char(10)+
	\"Resizing text and adding color allows the echo to stand out when text\"+char(10)+
	\"is flying by during a complex <b>dig</b>, for example.\"
	ec = arg1+\" \"
	if arg2 then ec = ec + arg2+\" \"
	if arg3 then ec = ec + arg3+\" \"
	if arg4 then ec = ec + arg4
	return ec.trim
end function
command.clear = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Clear Screen || Terminal Wipe || clearscreen\"+char(10)+\"Usage: clear -- clears the terminal of all text\"
	print(\"\",1)
	return 0
end function
command.ps = function(arg1, arg2, arg3=0, arg4=0)
	ps_usage = \"Show Processes || PS || show procs || not actually top or htop\"+char(10)+
	\"<b>Usage: ps [opt:-r] [opt:shell|computer] -- show processess running on the active host_computer\"+char(10)+
	\"-- when glasspool is active:\"+char(10)+
	\"-- the active shell/computer is the active host_computer\"+char(10)+
	\"-- optional [-r] parameter returns raw, uncolorized output\"+char(10)+
	\"--eg: ps -r\"+char(10)+
	\"<b>Usage: ps [opt:-r] [shell|computer] -- show processes running on the piped object\"+char(10)+
	\"-- optional [-r] parameter returns raw, uncolorized output\"+char(10)+
	\"--eg: rsi 1 7 | ps\"
	if arg1 == \"-h\" or arg1 == \"help\" then return ps_usage
	output = null
	raw = false
	verbose = false 
	if arg3 == \"--verbose\" then verbose = true
	locals.hold_comp = globals.localmachine
	if arg1 == \"-r\" then
		raw = true 
		arg1 = arg2 
		arg2 = arg3
		arg3 = arg4 
	end if
	if arg1 and (typeof(arg1) == \"shell\" or typeof(arg1) == \"computer\") then 
		if typeof(arg1) == \"shell\" then locals.hold_comp = arg1.host_computer
		if typeof(arg1) == \"computer\" then locals.hold_comp = arg1 
		//swapped = true
	end if
	if verbose then print(\"<size=75%>Showing processes...\")
	if raw == true then return format_columns(locals.hold_comp.show_procs)
	p_buf = hold_comp.show_procs.split(char(10))
	i = 0
	if DEBUG then print \"debug: \"+p_buf
	for line in p_buf 
		if i == 0 then 
			line = colorWhite+\"</b>\"+line+\"</color>\".replace(\"USER\",\"<color=#F5F5F5></b>USER</color>\")
			p_buf[i] = line
			i = i + 1
			continue 
		end if
		line = colorCyan+\"</b>\"+line
		line = line.replace(\"dsession\",colorRed+\"</b>dsession\").replace(\"Xorg\",colorLightBlue+\"</b>Xorg\").replace(\"kernel_task\",colorLightBlue+\"</b>kernel_task\").replace(\"ps\",colorRed+\"</b>ps\").replace(\"5hell\",colorRed+\"5\"+colorWhite+\"hell\")//.replace(\"root\",colorOrange+\"<b>root</color>\").replace(\"guest\",colorWhite+\"<b>guest</color>\")
		p_buf[i] = line
		i = i + 1
	end for
	output = format_columns(p_buf.join(char(10)))
	return output
end function
command.kill = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0  or arg1 == \"-h\" or arg1 == \"help\" then return \"KILL || END PROCESS || TERMINATE SCRIPT\"+char(10)+
	\"Usage: kill [PID] [opt: shell|computer] -- terminate PID\"+char(10)+
	\"-- PID should be process number or ALL\"+char(10)+
	\"-- see the <b>ps</b> command for process ID's\"+char(10)+
	\"--<b> kill ALL </b>will attempt to close all programs.\"+char(10)+
	\"n.b. if<b> kill ALL </b>kills the terminal that launched the program,\"+char(10)+
	\"---- it might not complete its task.\"+char(10)+char(10)+
	\"Usage: kill [process_name] [opt: shell|computer] --\"+char(10)+
	\"-- kill processes by process name instead of PID\"+char(10)+
	\"-- NOTE: kills ALL processes of that name\"+char(10)+char(10)+
	\"Note: piping a shell or computer object runs kill on the object instead of locally\"+char(10)+
	\"Note: running kill while glasspool is active runs kill on the active object\"
	target_machine = globals.localmachine
	if typeof(arg2) == \"shell\" then 
		target_machine = arg2.host_computer
	end if
	if typeof(arg2) == \"computer\" then 
		target_machine = arg2
	end if
	if typeof(arg1) == \"string\" then 

		if typeof(arg1.to_int) == \"number\" then PID = arg1.to_int else PID = arg1
	else 
		return \"kill: invalid input\"+char(10)+\"Usage: kill [pid|process_name] [opt:shell|computer]\"
	end if
	if typeof(PID) == \"string\" then
		processes = target_machine.show_procs.split(char(10))
		killed = false
		for p in processes
			if p == \"USER PID CPU MEM COMMAND\" then continue
			process = p.split(\" \")
			process_ID = process[1]
			process_CMD = process[4]
			stor = globals.localmachine
			globals.localmachine = target_machine
			if PID == \"ALL\" or PID == process_CMD then 
				print(command.kill(process_ID))
				killed = true 
			end if
			globals.localmachine = stor
		end for
		if killed == false then return \"kill: process <u>\" + PID + \"</u> not found\" else return 0
	end if
	output = target_machine.close_program(PID)
	if output == true then return(\"kill: terminating process: \" + PID + \"...\");
	if output then return(output)
	return \"kill: process <u>\" + PID + \"</u> not found\"
end function
command.pwd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: pwd -- print working directory\"+char(10)+\"-- returns the current path as a string\"
	return currentPath
end function
command.psudo = function(operation, arg2, arg3, arg4)
    if operation == \"help\" or operation == \"-h\" then return \"PSUDO || sudo || get shell || get_shell || start terminal\"+char(10)+
	colorCyan+\"<u>Start_terminal options:\"+char(10)+\"--\"+char(10)+
    \"Usage: \"+colorGold+\"</b>psudo\"+CT+\" -- display the psudo menu\"+char(10)+\"--\"+char(10)+
    \"Usage: \"+colorGold+\"</b>psudo\"+CT+\" [\"+colorWhite+\"shell_object\"+CT+\"] -- execute <b>start_terminal</b> on the shell_object\"+char(10)+
    \"-- unlike <b>run</b>, this command will <b>end</b> the script\"+char(10)+\"--\"+char(10)+
    \"Usage: \"+colorGold+\"</b>psudo\"+CT+\" [\"+colorWhite+\"-l\"+CT+\"] -- execute start_terminal on the currently active shell object\"+char(10)+
	\"-- unlike <b>run</b>, this command will <b>end</b> the script\"+char(10)+\"--\"+char(10)+
	colorCyan+\"<u>Get_shell options:\"+char(10)+\"--\"+char(10)+
    \"Usage: \"+colorGold+\"</b>psudo\"+CT+\" [\"+colorWhite+\"-u\"+CT+\"] [opt:\"+colorWhite+\"user\"+CT+\"] [opt:\"+colorWhite+\"password\"+CT+\"] -- \"+colorOrange+\"BUFFER\"+CT+\" a shell object using credentials\"+char(10)+\"--\"+char(10)+
	\"Usage: \"+colorGold+\"</b>psudo\"+CT+\" [\"+colorWhite+\"-s\"+CT+\"] [opt:\"+colorWhite+\"password\"+CT+\"] -- \"+colorOrange+\"BUFFER\"+CT+\" a <b>root</b> shell object using credentials\"
//
    _psudo_menu = function()
        // display options
        print colorGold+\"</b>psudo: \"+CT+\"[\"+colorWhite+\"y</b>|<b>l\"+CT+\"] execute \"+colorCyan+\"</b>start_terminal\"+CT+\" on the currently active shell object\"
        print colorGold+\"</b>psudo: \"+CT+\"[\"+colorWhite+\"u\"+CT+\"] BUFFER a <b>local</b> user shell using credentials\"
        print colorGold+\"</b>psudo: \"+CT+\"[\"+colorWhite+\"s\"+CT+\"] BUFFER a <b>root</b> shell using credentials\"
        print colorGold+\"</b>-- press any other key to abort\"
        op = user_input(colorWhite+\"||: \"+colorGold+\"</b>\",0,1).lower
        if \"ylus\".indexOf(op) == null then return 0 else return \"-\"+op
    end function
//
    _go_time = function(user=null,pass=null)
		if DEBUG then print \"debug: go time: \"+char(10)+\"usr: \"+user+\" is a: \"+typeof(user)+char(10)+\"pass: \"+pass+\" is a: \"+typeof(pass)
        if not user or not pass or user == \"\" or pass == \"\" then return colorGold+\"</b>psudo: aborting...\"
		if typeof(user) != \"string\" or typeof(pass) != \"string\" then return colorGold+\"</b>psudo: aborting...\"
        locals.sh = get_shell(user,pass)
        if typeof( locals.sh ) == \"shell\" then 
            colorLightBlue+\"</b>malp: \"+colorGreen+\"success</color></b>; new shell sent to \"+colorOrange+\"BUFFER\"
            open_it = user_input(colorGreen+\"</b>-- view context menu in \"+colorOrange+\"BUFFER\"+CT+\"? [y/<b>N</b>] ||: \"+colorWhite,0,1)
            if open_it.lower == \"y\" then return command.malp(\"-b\",locals.sh) else globals.BUFFER.push(locals.sh)
            colorGold+\"</b>psudo: returning shell object...\"
            return locals.sh
        else 
            return colorGold+\"</b>psudo: \"+colorRed+\"</b>failed</color> to obtain shell object\"+char(10)+colorGold+\"</b>-- check credentials and try again\"
        end if
    end function
//
    _shell_prompt = function(sh)
		if typeof(sh) != \"shell\" then return colorGold+\"psudo: error, expected shell, got: \"+sh
        if user_input(colorGold+\"</b>psudo: \"+colorOrange+\"warning; start_terminal ends the script!\"+char(10)+
            colorGold+\"psudo: \"+colorOrange+\"warning; start_terminal may result in an active trace\"+char(10)+
            colorGold+\"</b>Continue? [\"+colorWhite+\"y\"+CT+colorGold+\"</b>/\"+CT+colorWhite+\"N\"+CT+colorGold+\"</b>] ||: \"+colorWhite,0,1).lower == \"y\" then
				get_custom_object.return_value = \"#!#CASCADE#!#\"
                exit locals.sh.start_terminal
                exit \"starting_terminal on target shell...\"
                return char(10)+
                colorGold+\"psudo:\"+colorOrange+\" Attention: if you are seeing this message:\"+char(10)+
                colorOrange+\"</b>-- A game anomoly has kept the script running\"+char(10)+
                colorOrange+\"</b>-- despite having used start_terminal.\"+char(10)+
                colorOrange+\"</b>-- You will need to manually exit out of 5hell to start the terminal.\"+char(10)+
                colorOrange+\"</b>-- Note: you must <b>exit</b>; do not use ctrl+c\"
                exit \"This is a game bug, not mine.\"
            return 0
		else 
		 	return colorGold+\"</b>psudo: aborting...\"
        end if
    end function
//
	if not operation then operation = _psudo_menu
	if not operation then return colorGold+\"</b>psudo: aborting...\"
    // if it's a shell we warn and confirm
    if typeof(operation) == \"shell\" then _shell_prompt(operation)
//
    // otherwise we parse the flag or return if invalid flag
    if typeof(operation) != \"string\" then return colorGold+\"</b>psudo: aborting...\"
// 
    if operation == \"-l\" or operation == \"-y\" then return _shell_prompt(globals.shell)
//
	usr = null
	psw = null
    if operation == \"-u\" then 
		if not arg2 then usr = user_input(\"user name:> \") else usr = arg2 
		if arg3 then psw = arg3 else psw = user_input(\"user passwor:> \")
		return _go_time(usr,psw)
	end if
//
    if operation == \"-s\" then
		usr = \"root\"
		if not arg2 then psw = user_input(\"root password:> \",1) else psw = arg2
		return _go_time(usr,psw)
	end if
//
    return colorGold+\"</b>psudo: invalid input\"+char(10)+\"-- aborting...\"
end function
command.ls = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"List Files | List Folders | File Details\"+char(10)+
	\"Usage: ls [opt: -l|-a|-s|-r] [opt: /path] -- list files in path\"+char(10)+
	\"Opt: [-l] -- list all file details for given path\"+char(10)+
	\"Opt: [-a] -- list all files, alphabetically, for given path\"+char(10)+
	\"-- by default files and folders are listed from first created\"+char(10)+
	\"---- to last created \"+char(10)+
	\"Opt: [-s] -- list all files by size (not yet implemented)\"+char(10)+
	\"Opt: [-r] -- list all files and return raw, uncolorized output\"+char(10)+
	\"Note: option flags may be combined in any order\"+char(10)+
	\"-- eg: <b>ls -lars\"
	if DEBUG then print \"debug: in ls\"
	subFiles = null
	folderPath = globals.currentPath
	if DEBUG then print(\"ls: \"+folderPath)
	raw_output = false
	showHide = 1
	showDetails = 0
	a_order = 0
	s_order = 0
	if arg1 then 
		if arg1.indexOf(\"-\") == 0 then // we have flags
			if arg2 then folderPath = arg2
			if arg1.indexOf(\"l\") != null then showDetails = 1
			if arg1.indexOf(\"a\") != null then a_order = 1
			if arg1.indexOf(\"s\") != null then s_order = 1
			if arg1.indexOf(\"r\") != null then raw_output = true
		else 
			folderPath = arg1
		end if
	end if 
	folder = globals.get_file(folderPath)
	if not folder then return \"ls: No such file or directory\"
	if DEBUG then print(\"folder: \"+folder.path+\" is a: \"+typeof(folder))
	if folder.is_folder then 
		subFiles = folder.get_folders + folder.get_files
		if DEBUG then print \"debug: pre alpha sort\"
		if a_order then 
			f_buf = []
			s_buf = []
			for sub in subFiles 
				f_buf.push(sub.name)
			end for
			f_buf.sort
			for f in f_buf 
				for sub in subFiles
					if sub.name == f then s_buf.push(sub)
				end for 
			end for 
			subFiles = s_buf
		end if
		if DEBUG then print \"debug: pre size sort\"+char(10)+
		\"-- subFiles: \"+subFiles
	else 
		subFiles = [folder]
	end if
	output = \"\"
	for subFile in subFiles
		line_color = colorWhite+\"</b>\"
		nameFile = subFile.name
		permission = subFile.permissions
		owner = subFile.owner
		size = subFile.size
		group = subFile.group
		is_bin = subFile.is_binary
		if is_bin then line_color = colorCyan + \"</b>\"
		if subFile.is_folder then line_color = colorLightBlue + \"</b>\"
		if subFile.is_symlink then nameFile = colorGold+\"</b>\"+nameFile
		if raw_output then line_color = \"\"
		if showDetails then
			output = output + char(10) + line_color + permission + \" \" + owner + \" \" + group + \" \"+ size + \" bin[\"+is_bin+\"] \" + nameFile
		else
			output = output + char(10) + line_color + nameFile
		end if
	end for

	output = output.trim
	output = output.split(char(10))
	return format_columns(output.join(char(10)).trim)
end function
command.cd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: cd [path] -- change current working directory to path\"+char(10)+\"Usage: cd .. -- go back to parent directory.\"+char(10)+\"Usage: cd -- return to home directory.\"+char(10)+\"Returns: 0 on success or string on failure.\"
	if arg1 == \"\" then arg1 = 0
	if not globals.get_file(globals.currentPath) then globals.currentPath = home_dir
	cd = localmachine.File(globals.currentPath)
	if not arg1 then
		globals.currentPath = globals.homePath
		return 0
	end if
	if not cd then
		globals.currentPath = \"/\"
		return \"cd: path error. Setting path to<b> / </b>\"+char(10)+\"...please try again.\"
	end if
	if arg1 == \"..\" then
		if cd.name != \"/\" then
			globals.currentPath = cd.parent.path
		end if
		return 0
	end if
	new_path = globals.get_file(arg1)
	if new_path then
		if new_path.is_folder then globals.currentPath = new_path.path else return \"cd: \"+new_path.path+\" is not a directory.\"
	else
		return \"cd: \"+arg1+\" not found.\"
	end if
	return 0
end function
command.rm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == \"-h\" or arg1 == \"help\" then return \"<b><u>Remove File || RM || Delete</b></u> \"+char(10)+\"Usage: rm [opt:-r] [path|file_object] [opt:shell|computer]\"+char(10)+\"Usage: rm [path|file_object] - deletes a file\"+char(10)+\"Usage: rm -r [path|file_object] - deletes a folder (and all contents)\"+char(10)+\"Usage: rm [opt:-r] [/absolute/path] [shell_object|computer_object]\"+char(10)+\"-- uses supplied shell or computer to delete file or folder at path\"+char(10)+char(10)+\"N.B. The system.log delete entry will be from the originating IP\"+char(10)+\"-- NOT the ip of the remote shell or computer\"+char(10)+\"-- be sure to clean the log when remote deleting\"
	path_to_delete = null
	recursive = false
	remote = false
	shell_to_use = globals.shell 
	file = null
	usage = \"rm: usage:<b> rm [opt:-r] [path|file_object] [opt:shell|computer]</b>\"
	print \"<u>\"+colorRed+\"- - - - - \"
	if arg1 == \"-r\" then 
		recursive = true 
		arg1 = arg2 
		arg2 = arg3 
	end if	
	if not arg1 then return usage
	if typeof(arg1) == \"string\" then 
		path_to_delete = arg1 
		file = globals.get_file(path_to_delete)
	end if
	if typeof(arg1) == \"file\" then 
		file = arg1
		path_to_delete = file.path 
	end if
	if typeof(arg1) == \"shell\" or typeof(arg1) == \"computer\" then return usage
	if not path_to_delete then return usage 
	if arg2 and typeof(arg2) == \"shell\" then 
		shell_to_use = arg2 
		remote = true 
		file = shell_to_use.host_computer.File(path_to_delete)
		if not file then return \"rm: file not found on remote shell.\" else print \"rm: found file on remote shell...\"
	end if
	if arg2 and typeof(arg2) == \"computer\" then file = arg2.File(path_to_delete) 
	if file then
		if not file.has_permission(\"w\") then return \"rm: permission denied\"
		print \"rm: \"+colorWhite+\"deleting: </b><u>\"+file.path
		if file.is_folder then
			if recursive == true then return file.delete else return \"rm: use<b> rm -r [path|file_object] </b>to remove a folder.\"
		end if
		return file.delete
	end if
	return \"rm: file not found.\"
end function
command.mv = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"MOVE || MV || rename || I like to move it move it\"+char(10)+
	\"Usage: mv [source_path|file_object] [destination_path|file_object]\"+char(10)+
	\"-- move file or folder to new path\"+char(10)+
	\"-- optionally rename the file\"+char(10)+
	\"-- if destination is folder uses original filename, else renames\"+char(10)+
	\"-- overwrites destination file if it exists and is not a folder\"+char(10)+
	\"-- if file objects are supplied then uses the object's path\"+char(10)+
	\"Usage: mv [source_path|file_object] [@] -- move file to current path using original file name\"+char(10)+
	\"-- e.g:<b> mv bob /burger -- moves bob to / dir and renames to burger\"+char(10)+
	\"---- if /burger is a directory; moves bob into burger as /burger/bob\"+char(10)+
	\"NOTE: this command moves files between folders on the machine local to the file object\"+char(10)+
	\"-- please use <b>scpm</b> or BUFFER <b>scp</b> to transfer files between machines\"+char(10)

	if not arg1 or not arg2 then return \"mv: not enough input\"
	if typeof(arg1) != \"string\" and typeof(arg1) != \"file\" then return \"mv: invalid parameters;\"+char(10)+
	\"-- expects strings or file objects\"
	if typeof(arg2) != \"string\" and typeof(arg2) != \"file\" then return \"mv: invalid parameters;\"+char(10)+
	\"-- expects strings or file objects\"
	print \"<u>\"+colorLightBlue+\"= = = = =\"
	if typeof(arg1) == \"file\" then 
		if p_validate(arg1,\"size\") then file = arg1 else return \"mv: error: input file object does not exist\"
	else 
		file = globals.get_file(arg1)
	end if
	if not file then return(\"mv: can't find \" + arg1)
	destination = null
	final_name = null
	// check for file object
	if typeof(arg2) == \"file\" then 
		if p_validate(arg2,\"size\") then dest = arg2 else return \"mv: error: output file object does not exist\"+char(10)+
		\"-- please purge this object, recreate the file, or supply a string instead\"
	else 
		dest = globals.get_file(arg2)
	end if
	if not dest then
		if typeof(arg2) == \"string\" then 
			split = arg2.split(\"/\")
			final_name = split.pop
		else 
			return \"mv: invalid parameters\"
		end if
		if DEBUG then print(\"split: \"+split)
		if split.len and split[0] == \"\" then dest = globals.get_file(split.join(\"/\")) else dest = globals.get_file(split.join(\"/\"))
		if DEBUG then print(\"dest: [\"+dest+\"]\")
		if not dest then
			if arg2[0] == \"/\" then destination = \"/\" else destination = currentPath
		else
			destination = dest.path
		end if
	else
		if dest.is_folder then
			destination = dest.path
			final_name = file.name
			if dest.path == file.path then destination = dest.parent.path
		else
			destination = dest.parent.path
			final_name = dest.name
		end if
	end if
	if final_name == \"@\" then final_name = file.name
	if destination == \"/\" then print \"mv: \"+file.path+\" -> \"+destination+final_name+\"...\" else print \"mv: <u>\"+colorWhite+file.path+\" -> \"+destination+\"/\"+final_name+\"...\"
  return file.move( destination, final_name )
end function
command.cp = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == 0 or arg2 == 0 or arg1 == \"-h\" or arg1 == \"help\" then return \"COPY || copy files || CP\"+char(10)+
  \"Usage: cp [/old_path] [/new_path] -- copy file or folder to new_path \"+char(10)+
  \"Usage: cp [/old_path] [@] -- copy old path to current path and use original file name\"+char(10)+
  \"Usage: cp [/old/path] [/newpath/newname] -- make a copy of a file with a new name/path\"+char(10)+
  \"Usage Example:\"+char(10)+
  \"-- cp /root/file.txt @ \"+char(10)+
  \"---- copies file.txt to the current directory with name: file.txt\"+char(10)+
  \"Usage Example:\"+char(10)+
  \"-- poke /root/haha |  | poke /root/heehee |  | cp /root/haha /root/heehee\"+char(10)+
  \"---- creates files haha and heehee then copies haha over heehee, overwriting heehee\"+char(10)+
  \"Usage Example:\"+char(10)+
  \"-- poke haha |  | grep -p syst / | cp haha\"+char(10)+
  \"---- create file haha, grep for (system.log) and return file_path, overwrite /var/system.log with haha\"
  print \"<u>\"+colorGreen+\"= = = = =\"
  file = null
  if typeof(arg1) == \"file\" then file = arg1 else file = globals.get_file(arg1) // taking a file as arg1 isn't quite finished/tested yet; i'll likely rewrite cp instead
  if not file then return(\"cp: can't find \" + arg1)
  destination = null
  final_name = null
  dest = globals.get_file(arg2)
  if not dest then
    split = arg2.split(\"/\")
    final_name = split.pop
		if DEBUG then print(\"split: \"+split)
    if split.len and split[0] == \"\" then dest = globals.get_file(split.join(\"/\")) else dest = globals.get_file(split.join(\"/\"))
		if DEBUG then print(\"dest: [\"+dest+\"]\")
		if not dest then
      if arg2[0] == \"/\" then destination = \"/\" else destination = currentPath
    else
      destination = dest.path
    end if
  else
    if dest.is_folder then
      destination = dest.path
      final_name = file.name
    else
      destination = dest.parent.path
      final_name = dest.name
    end if
  end if
	if final_name == \"@\" then final_name = file.name
	if destination == \"/\" then print \"cp: \"+file.path+\" => \"+destination+final_name+\"...\" else print \"cp: <u>\"+colorWhite+file.path+\" => \"+destination+\"/\"+final_name+\"...\"
	print colorGold+\"- - - - - - - - - - - - - - - - - - - - - - -\"
  return file.copy( destination, final_name )
end function
command.usr = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == \"-h\" or arg1 == \"help\" then return \"USR || ADD USER || CHOWN\"+char(10)+
	\"Usage: usr [opt: -r] [new_owner] [path] \"+char(10)+
	\"-- [-r] flag makes the command recursive on all files and folders below [path]\"+char(10)+
	\"Usage: usr [-a|add] [opt:user] [opt:password] -- add a user to the system\"+char(10)+
	\"-- omitting user and or password will result in a prompt for these values\"+char(10)+
	\"Usage: usr [-d|del] [username] [opt:bool 1|0] -- delete a user from the system\"+char(10)+
	\"-- 0 == do not delete the home folder\"+char(10)+
	\"-- 1 == delete the home folder\"+char(10)+
	\"-- any other value results in a prompt\"+char(10)+
	\"Usage: usr [path] -- return owner of file at path\"+char(10)+
	\"-- Do not a name user add or del, for #reasons.\"+char(10)+
		\"-- It is good practice to run:\"+char(10)+
		\" |><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>\"+char(10)+
		\"-- or <b> kore -s</b> for optimal security\"
	is_recursive = false 
	if arg1 == \"add\" or arg1 == \"-a\" then
		if not arg2 then arg2 = user_input(\"new_user:> \")
		if not arg3 then arg3 = user_input(arg2+\" password:> \")
		if arg2 == \"\" then return \"usr: aborting...\"
		print \"usr: attempting to create user:<b> \"+arg2
		uc = localmachine.create_user(arg2, arg3)
		if uc == 1 then return \"-- user created\" else return uc 
	end if
	if arg1 == \"del\" or arg1 == \"-d\" then
		d_user = null
		if not arg2 then d_user = user_input(\"del_user:> \") else d_user = arg2
		del_home = null
		if arg3 == \"0\" then del_home = false 
		if arg3 == \"1\" then del_home = true 
		if del_home == null then 
			del_home = user_input(\"Delete /home/\"+d_user+\"? [Y/n] \"+char(10)+\"||: \",0,1)
			if del_home == \"n\" then del_home = false else del_home = true
		end if
		ud = localmachine.delete_user(d_user, del_home)
		if ud == 1 then return \"usr: deleted user: \"+d_user else return ud
	end if
	if arg1.lower == \"-r\" then 
		arg1 = 1
	end if
	if typeof(arg1) == \"string\" then // check owner of string: /file/path
		if not arg2 then
			check_u = globals.get_file(arg1)
			if typeof(check_u) == \"file\" then return check_u.owner 
		end if
	end if
	if arg1 == 1 then // recursive
		if not arg3 then return \"usr: invalid arguments. please supply a path.\"
		t_f = globals.get_file(arg3)
		if t_f then return t_f.set_owner(arg2, 1) else return \"usr: \"+arg3+\" not found.\"
	else // not recursive
		if not arg2 then return \"usr: \"+arg1+\" not found <b>or</b> path not supplied.\"
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_owner(arg1, 0) else return \"usr: \"+arg2+\" not found.\"
	end if
	return 0
end function
command.grp = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == \"-h\" or arg1 == \"help\" then return \"<u>GROUP || ADD GROUP || CHGRP</u>\"+char(10)+\"Usage: grp [optional: -r -- recursive] [new_group] [path] \"+char(10)+\"Usage: grp [add|del] [group] [user] -- add or remove group to|from user.\"+char(10)+\"Usage: grp -u [user] -- returns groups associated with user\"+char(10)+\"Usage: grp -f [path] -- returns group associated with file at path\"+char(10)+\"-- Do not name group add or del for #reasons.\"+char(10)+\"-- It is good practice to run:\"+char(10)+\"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>\"+char(10)+\"for optimal security.\"
	is_recursive = false
	if arg1 == \"-f\" then 
		if not arg2 or arg2 == \"\" then return \"Usage: grp -f [path]\"
		f_t = globals.get_file(arg2)
		if not f_t then return \"grp: \"+arg2+\" not found.\"
		return f_t.group
	end if 
	if arg1 == \"-u\" then 
		if not arg2 or arg2 == \"\" then return \"Usage: grp -u [user]\"
		return globals.localmachine.groups(arg2)
	end if 
	if arg1 == \"add\" then
		if not arg2 or not arg3 then return \"Usage: grp add [group] [user]\"
		return localmachine.create_group(arg3, arg2)
	end if
	if arg1 == \"del\" then
		if not arg2 or not arg3 then return \"Usage: grp del [group] [user]\"
		return localmachine.delete_group(arg3, arg2)
	end if
	if arg1 == \"-r\" or arg1 == \"-R\" then is_recursive = true
	if is_recursive then
		if not arg3 then return \"grp: invalid arguments. Usage: grp -r [group] [path].\"
		t_f = localmachine.File(arg3)
		if t_f then return t_f.set_group(arg2, 1) else return \"grp: \"+arg3+\" not found.\"
	else
		if not arg2 then return \"grp: invalid arguments. Usage: grp [group] [path]\"
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_group(arg1, 0) else return \"grp: \"+arg2+\" not found.\"
	end if
	return 0
end function
command.perms = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print(\"__debug: in perms\")
	if (arg1 == \"-h\" or arg1 == \"help\") and arg2 == \"extra\" then return \"Q: Perms lock all (aka the <b>lock</b> command): what does it do?\"+char(10)+\"A: the following:\"+char(10)+\"perms -R o-rwx /\"+char(10)+\"perms -R g-rwx /\"+char(10)+\"perms -R u-rwx /\"+char(10)+\"if on home computer, does the following to avoid lockout:\"+char(10)+\"perms g+x /bin/sudo\"+char(10)+\"perms g+x /bin/psudo\"+char(10)+\"perms g+x /bin/ssh\"+char(10)+\"perms g+x /usr/bin/Terminal.exe\"+char(10)+\"perms g+x /usr/bin/Chat.exe\"+char(10)+\"perms g+x /usr/bin/Mail.exe\"+char(10)+\"To bypass this and lock down anyway use:<b> perms lock down </b> (use with caution)\"+char(10)+\"n.b mail and chat are on this list because bugs happen when they are fully locked.\"
	perms_usage = \"<u>CHMOD || PERMISSIONS || PERMS || SECURITY</u>\"+char(10)+
		colorWhite+\"Usage: perms [opt:-r] [userstring{+|-}permission] [path]\"+char(10)+
		\"-- opt: -r -- run recursively on all files and folders under [path]\"+char(10)+
		\"-- userstring -- o = other, g = group, u = user/owner\"+char(10)+
		\"-- toggle -- [+] = add permission, [-] = remove permission\"+char(10)+
		\"-- permission -- r = read, w = write, x = execute\"+char(10)+
		\"E.G:<b> perms -r o-rwx / </b> -- remove rwx permissions from 'others' for all files\"+char(10)+
		\"E.G:<b> perms -r g+x /bin</b> -- add group execute permissions to all files in /bin\"+char(10)+char(10)+
		\"<color=white>Aliases:\"+char(10)+
		\"Usage: perms lock all -- remove all permissions from all files (alias:<b> lock</b>)\"+char(10)+
		\"-- includes anti-brick technology: checks for home pc and relaxes certain permissions:\"+char(10)+
		\"---- checks for user_email_address: if found, determines we are at home\"+char(10)+
		\"---- if at home add g+x to: sudo, ssh, Terminal.exe, Chat.exe, Mail.exe\"+char(10)+
		\"Usage: perms lock down -- force locking down, bypassing anti-brick technology\"+char(10)+		
		\"Usage: perms unlock all -- add o+rwx to all files\"+char(10)+
		\"<b>Shortcut:</b> \"+colorRed+\"lock\"+CT+\"-- alias for <b>perms lock all</b>\"+char(10)+
		\"-- it is good practice to run:\"+char(10)+
		\"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>\"+char(10)+
		\"--for optimal security.\"+char(10)+
		\"-- you may type:<b> kore -s</b> to have this action performed for you\"
		\"Extra: perms [-h|help] extra -- view extra help information about this command.\"
	if arg1 == \"-h\" or arg1 == \"help\" or arg1 == 0 or arg2 == 0 then return perms_usage
	if arg1 == \"unlock\" then return command.perms(\"-R\", \"o+rwx\", \"/\")
	if arg1 == \"lock\" then
		if not localmachine.File(\"/\").has_permission(\"w\") then return \"perms: lockdown failed: permission denied\"
		command.perms(\"-R\", \"o-rwx\", \"/\")
		command.perms(\"-R\", \"g-rwx\", \"/\")
		command.perms(\"-R\", \"u-rwx\", \"/\")
		//home = user_mail_address//user_input(\"r u home? [y/N] \"+char(10)+\"||: \",0,1)
		home = null 
		
		processes = localmachine.show_procs.split(char(10))
		for p in processes
			if p == \"USER PID CPU MEM COMMAND\" then continue
			process = p.split(\" \")
			process_ID = process[1]
			process_CMD = process[4]
			if process_CMD == \"Xorg\" then  home = true
		end for

		if home != null and arg2 != \"down\" then//home == \"y\" or home == \"Y\" then
			print(colorBlack+\"<mark=red><size=75%><color=yellow>Auto-detected: u r home</mark> -- locking file permissions\")
			command.perms(\"g+x\",\"/bin/sudo\")
			command.perms(\"g+x\",\"/bin/psudo\")
			command.perms(\"g+x\",\"/bin/ssh\")
			command.perms(\"g+x\",\"/usr/bin/Terminal.exe\")
			command.perms(\"g+x\",\"/usr/bin/Chat.exe\")
			command.perms(\"g+x\",\"/usr/bin/Mail.exe\")
			print(\"<b><size=75%>perms: setting critical binaries to <b>g+x</b>...\")
			print(\"<size=75%>perms: rerun with <b>perms lock down</b> to force full lockdown\")
		end if
		if arg2 == \"partial\" then command.perms(\"-R\",\"g+x\", \"/\")
		return \"perms: lockdown complete\"
	end if
	perms = arg1
	pathFile = arg2
	isRecursive = 0
	if arg1 == \"-R\" or arg1 == \"-r\" then
		perms = arg2
		if arg3 and typeof(arg3) == \"string\" or typeof(arg3) == \"file\" then pathFile = arg3 else return \"perms: invalid path\"
		isRecursive = 1
	end if
	if typeof(pathFile) == \"string\" then file = globals.get_file(pathFile)
	if typeof(pathFile) == \"file\" then file = pathFile 
	if not file then return(\"perms: can't find \" + pathFile)
	output = file.chmod(perms, isRecursive)
	if output then print(output)
	return 0
end function
command.mkdir = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"/\" or arg1 == 0 or arg1 == \"-h\" or arg1 == \"help\" then	return \"Usage: mkdir [/path/new_folder] -- create a new folder in path. path must exist.\"
	if globals.get_file(arg1) then return \"mkdir: \"+arg1+\" already exists.\"
	newpath = arg1.split(\"/\")
	new_dir = \"\"
	if newpath[0] == \"\" then
		newpath.pull
		new_dir = \"/\"
	else
		new_dir = currentPath
		if new_dir != \"/\" then new_dir = new_dir + \"/\"
	end if
	new_name = newpath.pop
	new_dir = new_dir+newpath.join(\"/\")
	if new_dir == \"\" then new_dir = \"/\"
	new_dir = globals.get_file(new_dir)
	if not new_dir then return \"mkdir: unable to create \"+arg1+\": parent folder not found.\"
	print colorGold+\"<b>mkdir: creating <b>\"+new_name+\" in:</b> \"+new_dir.path
	return localmachine.create_folder( new_dir.path , new_name )
	return 0
end function
command.cat = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"File Contents || cat || what's in that file\"+char(10)+
	\"Usage: cat [\"+colorWhite+\"path_to_text_file\"+CT+\"] -- returns contents of text file or null if read denied\"+char(10)+
	\"Usage: cat [\"+colorLightBlue+\"file_object\"+CT+\"] -- <b>returns</b> contents of piped file object\"+char(10)+
	\"-- e.g: grep -f passwd | cat \"+char(10)+
	\"Usage: cat [\"+colorOrange+\"-n|--noparse\"+CT+\"] [path|object] -- <b>prints</b> contents of text with with richtext tags escaped \"+char(10)+
	\"-- ie: it uses the <noparse><noparse> richtext tag\"
	file = null
	kittehns = [\"=^._.^= S\",\"^-^\",\"^ ^\",\"~(^._.)\",\"(^._.^)s\",\"(^..^)S\",\"(^-.-^)\",\"Z(=^.^=)\"]
	kittehns.shuffle
	kitteh = kittehns.pop
    no_parse = false
    if arg1 == \"-n\" or arg1 == \"--noparse\" then 
        no_parse = true 
        arg1 = arg2
        arg2 = arg3 
        arg3 = arg4
    end if
	print \"<u>\"+colorGold+\"- - - - - - - - - c a t - - - - - - - -\"+char(10)+
			    colorGold+\"                 \"+kitteh+\"              \"
	if typeof(arg1) == \"file\" then
		file = arg1
	else
		if typeof(arg1) == \"string\" then
			if arg1 == \"\" or arg1 == \" \" then return \"cat: file not found.\"
			if arg1.indexOf(char(10)) != null then return \"cat: invalid input\"
			file = globals.get_file(arg1)
			if not file then return (\"cat: \"+arg1+\" not found\")
		else
			return \"cat: expected path or file_object, got \"+arg1
		end if
	end if
	if file.is_binary then return (\"Cannot open binary file: \"+arg1)
	if no_parse then print file.get_content.noparse else return file.get_content
	return 0
end function
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code(\"/root/src/dtools.5pk\") // override=dtools.5pk
if DEBUG then 
	if command.hasIndex(\"grep\") then print \"debug: dtools loaded\"
end if 
command.run = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print(\"debug: arg1: \"+arg1+ \" :end arg1\")
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"run [file|path_to_file] [opt:parameters|shell] [opt:shell|parameters -- launch a script binary at path (gui's not supported)\"+char(10)+\"-- piped file objects are launched from the objects path\"+char(10)+\"-- max 14 nested launches before stack call error.\"+char(10)+\"-- providing a shell object will launch a binary using that shell object\"+char(10)+\"-- you must pipe launch params if more than one word\"+char(10)+\"-- use echo and easy clip for best results (@a,@b,@c)\"+char(10)+\"---- eg: echo do 1 -f pwn.bat | clipa | clipb @B 1 | run /home/guest/rkit/5hell @b @a\"+char(10)+\"---- eg: echo rshell 1.1.1.1 | clipa | brutus | run /root/rkit/5hell @a\"+char(10)+\"Note: run supports pshells with the launch function however p_objects are not currently in game\"
	if typeof(arg1) != \"string\" and typeof(arg1) != \"file\" then return \"run: arg1 should be file object or path to file\" 
	parameters = \"\"
	if arg2 and typeof(arg2) == \"shell\" then
		if arg3 and typeof(arg3) == \"string\" then parameters = arg3 else parameters = \"\"
		if typeof(arg1) == \"string\" then 
			globals.stack_pool(\"up\")
			cc = arg2.launch(arg1, parameters)
			globals.stack_pool(\"down\")
			_cascade // exit if cascade
			return cc
		end if
		if typeof(arg1) == \"file\" then 
			globals.stack_pool(\"up\")
			cc = arg2.launch(arg1.path, parameters)			
			globals.stack_pool(\"down\")
			_cascade // exit if cascade
			return cc
		end if
		return \"run: arg1 should be file or path to file\"
	end if
	if arg3 and typeof(arg3) == \"shell\" then 
		run_path = null
		if typeof(arg1) == \"string\" then run_path = arg1
		if typeof(arg1) == \"file\" then run_path = arg1.path
		if typeof(run_path) != \"string\" then return \"run: arg1 should be file object or path to file\"
		if typeof(arg2) == \"string\" then parameters = arg2
		if typeof(arg2) == \"file\" then return \"run: arg2 should be string (params) or shell object\"
		globals.stack_pool(\"up\")
		cc = arg3.launch(run_path, parameters)
		globals.stack_pool(\"down\")
		_cascade // exit if cascade
		return cc
	end if
	file = arg1
	if typeof(file) != \"file\" then file = globals.get_file(arg1)
	if not file then return \"run: \"+arg1+\" not found.\"
	parameters = \"\"
	if arg2 and typeof(arg2) == \"string\" then parameters = arg2
	if arg3 and typeof(arg3) == \"string\" then parameters = parameters + \" \" + arg3 
	if arg4 and typeof(arg4) == \"string\" then parameters = parameters + \" \" + arg4 
	if DEBUG then print(\"run: \"+file.path+\", \"+parameters)
	globals.stack_pool(\"up\")
	cc = shell.launch(file.path, parameters)
	globals.stack_pool(\"down\")
	_cascade // exit if cascade
	return cc
end function
command.scribus = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Scribus Terminal Text Editor by Plu70\"+char(10)+\"scribus [path_to_file] -- open terminal text editor on file at path\"+char(10)+\"Advanced: scribus @clipa|@clipb|@clipc -- This edits the clipboard directly.\"+char(10)+\"Advanced: scribus @cc -- edit the command buffer.\"+char(10)+\"Advanced: scribus [file_object] -- text only, open contents of piped object.\"+char(10)+\"Advanced: scribus @do -- edit the do buffer (to write / edit <b>do</b> scripts without launching them)\"+char(10)+\"-- see <b>do -h</b> for more info\"+char(10)+\"Note: you may press <b>@h</b> on a new line to get additional command info within the editor.\"
	p = arg1
	if not p then
		print(\":> \"+colorCyan+\"/relative/path/to/file\"+CT+\" - open a text file in the editor\")
		print(\":><b> @clipa | @clipb | @clipc </b>- edit clipboards in the editor\"+char(10)+\":><b> @do </b>- edit do command buffer (without running do)\"+char(10)+\":> @cc edit command buffer\"+char(10)+\"press <return> to abort.\")
	end if
	if p == 0 then p = user_input(\"Scribus:> \")
	if p == \"\" then return \"aborting...\"
	if p == \"@cc\" then
		print(\"Editing the command buffer...\")
		globals.command_buffer = globals.scribus(globals.command_buffer).split(char(10))
		return 0
	end if
	if typeof(p) == \"file\" then return globals.scribus(p)
	if p == \"@clipa\" then return command.clipa(globals.scribus(globals.clip_board_alpha))
	if p == \"@clipc\" then return command.clipc(globals.scribus(globals.clip_board_gamma))
	if p == \"@clipb\" then return command.clipb(globals.scribus(globals.clip_board_beta))
	if p == \"@do\" then
		if not globals.clip_board_delta then globals.clip_board_delta = []
		globals.clip_board_delta = globals.scribus(globals.clip_board_delta)
		print(\"do: clipped: \"+char(10)+colorBlack+\"*\"+CT+char(10)+globals.clip_board_delta)
		return globals.clip_board_delta
	end if
	if typeof(p) == \"string\" then
		f = localmachine.File(p)
		if not f then f = localmachine.File(currentPath+\"/\"+p)
		if not f then f = localmachine.File(currentPath+p)
		if not f then return \"scribus: \"+p+\" not found. \"
		//w = user_input(f.path+\" found. Open it? [Y/n] ||:\",0,1)
		//if w.lower == \"n\" then return \"aborting...\"
		return globals.scribus(f)
		//return 1
	end if
	return 0
end function
command.games = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"-h\" or arg1 == \"help\" then return \"games: battleship and blackjack and drugwars!\"
	print(\"[0] Battleship\")
	print(\"[1] Battleship - AI vs AI\")
	print(\"[2] Blackjack  - jokers wild\")
	print(\"[3] Drugawars\")
	print(\"[4] Back\")
	pick = user_input(\"||: \",0,1)
	if pick == \"0\" then return bat(\"\")
	if pick == \"1\" then return bat(\"-s\")
	if pick == \"2\" then return g2
	if pick == \"3\" then return g3
	return 0
end function
command.mail = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return colorGreen+\"<u></color>\"+colorGold+\"Mail || metaMail || herme5 || hermes || mail client\"+char(10)+
	\"herme5 mail client: its the mail (wip) -- its good enough but you may want to write your own;\"+char(10)+
	\"-- name your function<b> command.mail </b> to overwrite this one.\"+char(10)+
	\"-- see 5hell.src, template.5pk.src for instructions.\"+char(10)+
	\"Note: You may overwrite any command this way.\"+char(10)+char(10)+
	colorGold+\"- - - - - - - - - - - - - - - - - - - - - - - - - - - -\"+char(10)+
	\"Usage: mail -- opens the herme5 mail menu\"+char(10)+
	\"Extra: when prompted for a password you may enter:</b> -brutus\"+char(10)+
	\"-- this will invoke <b>brutus</b> and attempt to crack the email password.\"+char(10)+
	\"-- the password will be saved to the custom object as:\"+char(10)+
	\"-- key == password and value == public_ip:local_ip\"+char(10)+
	\"---- this will change once i work out a better storage system bc this is not ideal\"+char(10)+
	\"Extra: when viewing your inbox you may type <b>spool</b> to dump all mail to a file (up to 160kb)\"
        herme5 = function()
            mail = {}
            mail.meta = null  // metaMail object
            if globals.inbox then mail.meta = globals.inbox
            mail.data = null
            if globals.inbox then mail.data = mail.meta.fetch
            mail.user = null
            if globals.inbox then mail.user = globals.mail_user
            mail.pass = null
            if globals.inbox then mail.pass = true
			mail.a1 = outer.arg1 
			mail.a2 = outer.arg2
          
            mail.pwn = function(arg)
              dsize = globals.dict_a.len
              mode = user_input(\"[<b>0</b>] Onboard Dictionary -- [1] /root/tables/tp \"+char(10)+\"||: \",0,1)
              if mode == \"0\" or mode == \"\" then
                reverse_it = user_input(\"[<b>0</b>] start at dict_a[0]  --  [1] start at dict_a[-1] \"+char(10)+\"(type [q] abort) ||: \",0,1 )
                if reverse_it.lower == \"q\" then return \"aborting...\"
				if reverse == \"1\" then reverse_it = 1 else reverse_it = 0
                show_count = user_input(\"Show the count? [\"+dsize+\"] [y/<b>N</b>] ||: \",0,1)
                show_pass = user_input(\"Show passwords? [y/<b>N</b>] ||: \",0,1)
                if show_pass.lower == \"y\" then show_pass = true else show_pass = false
                if show_count.lower == \"y\" then show_count = true else show_count = false
                print(colorGold+\"Accessing onboard dictionary...\"+CT+char(10)+\"<align=center><<>></align>\")
                ds = dsize - 1
                for p in range( 0, ds )
                  dsize = dsize - 1
                  if reverse_it then pa = globals.dict_a[0 - p] else pa = globals.dict_a[p]
                  if show_count then print(colorGold+colorWhite+\"[\"+CT+dsize+colorWhite+\"]\"+CT+CT)
                  if show_pass then print(colorGold+colorWhite+\"[\"+CT+pa+colorWhite+\"]\"+CT+CT)
                  try = mail_login(arg, pa)
                  if typeof(try) == \"MetaMail\" then
                    print(\"brutus: <b>password found</b>: \"+colorWhite+pa+CT)
					print command.cob(\"set\",pa,arg)
                    return try
                  end if
                end for
              else
                if mode == \"1\" then
                  tp = localmachine.File(\"/root/tables/tp\")
                  if not tp then return 0
                  print(colorGold+\"Accessing /root/tables/tp...\"+CT+char(10)+\"<align=center><<>></align>\")
                  tp_f = tp.get_files
                  i=0
                  for f in tp_f
                    i = i + 1
                    print(i+\"/\"+(tp_f.len))
                    chunc = f.get_content.split(char(10))
                    for p in chunc
                      try = mail_login( arg, p )
                      if typeof(try) == \"MetaMail\" then
                        print(\"brutus: <b>password found</b>: \"+colorWhite+p+CT)
						print(\"brutus: accessing cob: saving password as key, email as value\")
						print command.cob( \"set\", p, arg)
                        return try
                      end if
                    end for
                  end for
                end if
              end if
              return 0
            end function
          
			_is_mail = function(strng)
				if typeof(strng) == \"string\" and strng.indexOf(\"@\") != null then return 1 else return 0 
			end function
            mail.Login = function()
              if globals.inbox then
                mail.meta = globals.inbox
                return mail.user+\" is already logged in.\"
              end if
              if _is_mail(mail.a1) then mail.user = mail.a1 else mail.user = user_input(\"email:> \")
              if mail.user == \"\" or mail.user == \" \" then mail.user = user_mail_address
              if not mail.user then return \"Invalid mail address.\"
              print(\"Enter <b>-brutus</b> to crack password with brutus.\")
              if _is_mail(mail.a1) and mail.a2 then mail.pass = mail.a2 else mail.pass = user_input(mail.user+\" pass:> \", 1)
              if mail.pass == \"\" or mail.pass == \" \" then return \"Invalid login credentials.\"
              if mail.pass == \"-brutus\" then
				print \"herme5: calling brutus...\"
                mail.meta = mail.pwn(mail.user)
              else
				print \"herme5: loging in: \"+mail.user+\"...\"
                mail.meta = mail_login(mail.user, mail.pass)
              end if
          
              if typeof(mail.meta) == \"MetaMail\" then
                globals.inbox = mail.meta
                globals.mail_user = mail.user
                return \"Login complete.\"
			  else 
				print mail.meta
              end if
              return \"Invalid login credentials.\"
            end function
            mail.get_id = function(arg)
              ds = mail.data[arg].split(char(10))
              //print(ds)
              i = ds[2].split(\" \")
              i = i[1]
              return i
            end function
            mail.Fetch = function()
              if typeof(mail.meta) != \"MetaMail\" then return \"Invalid login credentials.\"
              mail.data = mail.meta.fetch
              return \"Fetching mail for: \"+mail.user+\"...\"+char(10)
            end function
            mail.Read = function()
              if typeof(mail.meta) != \"MetaMail\" then return \"Invalid login credentials.\"
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
			  r = null 
			  if mail.a1 == \"spool\" then r = \"spool\" else r = user_input(\"Enter an index to read or type <b>spool</b> to dump to a file :> \").to_int
              print(colorGold+\"- - - - - - - - - - - - - - - - - - - - - - - - - - \"+CT)
			  if mail.data.len < 1 then return \"herme5: mailbox is empty\"
			  spool_buf = []
			  spooling = false
			  if r == \"spool\" then 
				spooling = true
			  	r = mail.data.len - 1
			  end if
			  while r >= 0
				if r >= 0 and r < mail.data.len then
					read_this = mail.meta.read(mail.get_id(r))
					if spooling then print \"<size=80%>herme5: spooling: [\"+colorWhite+r+CT+\"]\" else print(read_this)
					//if spooling then spool_buf.push(mail.data[(r)]+char(10)+read_this+char(10))
					if spooling then spool_buf.push(read_this+char(10))
					if read_this.split(char(10))[2] == \"Subject: *\" then
						print(colorLightBlue+\"<u><mark=#DF8600>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>\"+CT)
						print(command.code(\"-b\", read_this[read_this.indexOf(\"Subject: *\")+11:]))
					end if
				end if
				if spooling then r = r - 1 else r = -1
			  end while
			  if spooling then 
			  	st = time
			  	if typeof(mail.a2) == \"string\" then spool_file_path = mail.a2 else spool_file_path = user_input( colorGold+\"herme5: please enter a path for the spool file: \"+char(10)+\"[/path, <<b>enter</b>=home_dir/spool.txt, </b>q</b>=quit]:> \" )
				if spool_file_path.lower == \"q\" or spool_file_path.lower == \"quit\" then return \"aborting...\"
				if spool_file_path == \"\" or spool_file_path == \" \" then spool_file_path = homePath+\"/spool.txt\"
				spool_file = globals.get_file(spool_file_path)
				if typeof(spool_file) != \"file\" then print \"herme5: could not locate spool file.\"+char(10)+\"herme5: creating: \"+spool_file_path else print \"herme5: spool file found; overwriting\"
				if typeof(spool_file) == \"file\" and spool_file.is_binary then return \"herme5: cannot spool to binary file\"
				print colorWhite+\"<size=80%>Saving data to spool file: <b>\"+spool_file_path
				if DEBUG then print \"debug: spool_buf is: \"+spool_buf+\" and is a \"+typeof(spool_buf)
				spool_file = command.poke(\"-f\",spool_file_path, current_date+char(10)+char(10)+spool_buf.join(char(10))+char(10)+current_date)
				if typeof(spool_file) != \"file\" then return \"herme5: error: check write permissions\"
				globals.BUFFER.push(spool_file)
				wait(.1) 
				ttt = time - st
				print colorGold+\"herme5: \"+CT+\"spool_file object sent to \"+colorOrange+\"BUFFER\"+CT+char(10)+colorGold+\"</b>herme5: task completed in <b>\"+ttt+\"</b> seconds.\"
			  end if
              return \"returning...\"
            end function
            mail.Write = function()
              if typeof(mail.meta) != \"MetaMail\" then return \"Invalid login credentials.\"
              addr = user_input(\"address:> \")
              subj = user_input(\"subj:> \")
              mbuf = []
              send = \"\"
              body = globals.scribus(mbuf)
              munin = user_input(colorLightBlue+\"Encode with <mark=black>M</mark>unin<mark=black>C</mark>ipher before sending? [Y/n] ||: \"+CT,0,1)
              if munin.lower != \"n\" then
                send = command.code(\"-a\",body)
                subj = \"*\"
              else
                send = body
                print(colorGreen+\"<u>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</u>\"+CT)
              end if
			  if DEBUG then print \"debug: addr: \"+addr+char(10)+\"-- subj: \"+subj+char(10)+\"-- send: \"+send
              return mail.meta.send( addr, subj, send )
            end function
            mail.Delete = function(r=0)
              if typeof(mail.meta) != \"MetaMail\" then return \"Invalid login credentials.\"
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
              if not r then r = user_input(\"delete [*=all,<enter>=quit]:> \").to_int
			  if r and r == \"*\" then
				for m in range(0,mail.data.len - 1)
					mail.meta.delete( mail.get_id(m) )
			  	end for 
				print colorOrange+\"All emails deleted!\"
				return mail.Fetch
			  end if
              if typeof(r) == \"number\" and mail.data.hasIndex(r) then
                id = mail.get_id(r)
                if id then print(\"Deleting (crt+c to cancel): \"+id+\"...\")
                wait(.5)
                print(\"in 3...\")
                wait(1)
                print(\"2...\")
                wait(1)
                print(mail.meta.delete( id ))
                return mail.Fetch
              else
                return \"aborting...\"
              end if
              return 0
            end function
            mail.Widget = function()
              if typeof(mail.meta) != \"MetaMail\" then return \"Invalid login credentials.\"
              if HERMES == true then
                globals.HERMES = false
                wState = \"off\"
              else
                globals.HERMES = true
                wState = \"on\"
                globals.this_mail = user_input(\"Configuring widget...\"+char(10)+\"pin_mail_# (default: 0 for newest):> \").to_int
                mail.data = mail.meta.fetch
                if typeof(globals.this_mail) == \"number\" and globals.this_mail >= 0 and globals.this_mail < mail.data.len then
                  print(colorGold+\"Pinned: \"+colorWhite+globals.this_mail+colorGold+\".\"+CT+char(10)+colorGold+\"Herme5 mail widget configured.\"+CT)
                else
                  print(colorGold+\"Defaulting to: \"+colorWhite+\"0\"+colorGold+\".\"+CT+char(10)+colorGold+\"Herme5 mail widget configured.\"+CT)
                  globals.this_mail = 0
                end if
              end if
              return \"Herme5 mail widget toggled \"+wState+\".\"
            end function
            mail.Exit = function()
              return \"herme5: exiting...\"
            end function
            mail.data_stream = function(alist)
              d = \"\"
              i = 0
              for el in alist
                d = d + \"[\" +colorWhite+ i +CT+ \"] \" + el + char(10)
                i = i + 1
              end for
              return d
            end function
            mail.menu = function()
              mailing = true
              menu_options = [\"Exit\", \"Login\", \"Fetch\", \"Read\", \"Write\", \"Widget\", \"Delete\"]
              while mailing
                print(colorGold+\"- - - - - - - Herme5 v 0.4.5 by Plu70 - - - - - - - - \"+CT)
				print colorGold+\"- - - - - - [ </b><u>\"+colorWhite+mail.user+\"</color></u> ]</b> - - - - - -\"
				opt = 0
				if _is_mail(mail.a1) then opt = 1 
				if mail.a1 == \"spool\" then opt = 3
				if not opt then 
					mail.a1 = 0
					print(mail.data_stream(menu_options))
					opt = user_input(\"(q=quit)||: \",0,1).to_int
			  	end if
                print(colorGold+\"- - - - - - - - - - - - - - - - - - - - - - - - - - \"+CT)
                if opt == \"q\" then opt = 0
                if opt < 0 or opt > menu_options.len-1 or typeof(opt) != \"number\" then continue
                mm = @mail[menu_options[opt]]
                print(mm)
				if mail.a1 != 0 then return \"herme5: returning...\"
                mailing = opt
              end while
              return mailing
            end function

            return mail.menu
          end function
          // end Herme5
          //herme5          
	return herme5
end function
command.malp = function(arg1, arg2, arg3=0, arg4=0)
	if @arg1 == \"-h\" or @arg1 == \"help\" then return \"malp: Memory Alpha - buffer, object and database management menu. \"+char(10)+
	\"Usage: \"+colorGold+\"</b>malp\"+CT+colorWhite+\"</b> -- Access all\"+colorOrange+\"</b> BUFFER \"+CT+\"objects from here.\"+char(10)+
	\"Usage: \"+colorGold+\"</b>malp\"+CT+colorWhite+\"</b> [\"+colorGold+\"</b>piped_object\"+CT+\"] -- adds ANY piped object to the \"+colorOrange+\"</b> BUFFER \"+CT+\".\"+char(10)+
	colorWhite+\"</b>-- May be of any type: string, list, map, shell, file, computer, etc, et al.\"+char(10)+
	\"Usage: \"+colorGold+\"</b>malp\"+CT+colorWhite+\"</b> [\"+colorOrange+\"</b>-b\"+CT+\"] [opt: piped_object] -- open the\"+colorOrange+\"</b> BUFFER \"+CT+\"immediately on opening malp\"+char(10)+
	\"-- if an object is supplied, it's entry will be opened in the BUFFER\"+char(10)+
	\"Functions: \"+char(10)+
	\"[0] -- display portmap, if available\"+char(10)+
	\"[1] -- display loaded exploits and requirements if known\"+char(10)+
	\"[2] -- display raw scan output from met scan\"+char(10)+
	\"-- performs scan if not already scanned\"+char(10)+
	\"[3] -- dump memory; runs the memdump command\"+char(10)+
	\"-- this will dump session info such as portmap, exploits-\"+char(10)+
	\"-- and others to a file named memdump[random number].mx\"+char(10)+
	\"-- feel free to request additional info dumped by this command\"+char(10)+
	\"[4] -- access felix file explorer or run tree (locally or on buffered filesystem)\"+char(10)+
	colorOrange+\"[5] -- the main BUFFER where objects are stored\"+char(10)+
	\"-- contains contextual object handlers\"+char(10)+
	\"[6] -- Air menu for cracking wifi\"+char(10)+
	\"[7|q] -- exit\"+char(10)+
	\"[8] -- show running processes\"+char(10)+
	\"[9] -- kill processes\"+char(10)+
	\"[0] exit\"+char(10)+
	\"[/] -- open Cer Bios\"+char(10)+
	\"[-] -- open reverse shell interface\"+char(10)+
	\"[.] -- linkdb database entry\"
	if DEBUG then print(\"@arg1: \"+typeof(@arg1))
	open_buffer = false
	open_entry = false
	if @arg1 then
		if typeof(@arg1) == \"string\" then 
			if arg1 == \"-b\" then 
				open_buffer = true 
				arg1 = arg2 
				arg2 = arg3 
				arg3 = arg4 
			end if
		end if
		if @arg1 then 
			globals.BUFFER.push(@arg1)
			open_entry = true
		end if
	end if
	if DEBUG then print(\"starting malp with:\"+char(10)+\"--: ob: \"+open_buffer+char(10)+\"-- oe: \"+open_entry)
	return globals.memory_alpha(open_buffer,open_entry)
end function
command.fwr = function(arg1, arg2, arg3=0, arg4=0) // requires metaxploit.so
	if GLASSPOOL then print(colorOrange+\"fwr: ignores glasspool.\"+CT)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: fwr [ip] -- returns firewall rules for ip. returns local rules if no ip given.\"
	if not localmachine.is_network_active then return \"fwr: no network connection\"
	router = get_router
	if typeof(router) != \"router\" then return \"fwr: router not found\"
	if arg1 and is_valid_ip(arg1) then
		router = get_router(arg1) 
		if DEBUG then print \"debug: router is a: \"+typeof(router)
		if typeof(router) != \"router\" then return \"fwr: router not found\"
	end if
	if DEBUG then print \"debug: router is a: \"+typeof(router)
	return router.firewall_rules
end function
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code(\"/root/src/kore.5pk\") // override=kore.5pk
if DEBUG then 
	if command.hasIndex(\"kore\") then print \"debug: kore loaded\"
end if 
command.memdump = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"memdump: dump MEMORY, XPLOITS, PORT_MAP, clipboards,  to current_path+/memdump.mx\"+char(10)+\"n.b. ignores glasspool. main purpose is generating reports for clients.\"
	return globals.dump_memory
end function
command.enum = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"<b><u>enumeration || ENUM || enum buffer\"+char(10)+
	\"Use this to put things in a list.\"+char(10)+
	\"Usage: enum [opt|/path|file_object|array|#]\"+char(10)+
	\"Usage: enum [list|string] -- enumerates a list or a newline separated string\"+char(10)+
	\"-- if the string is a single word it will be interpreted as a path\"+char(10)+
	\"-- multiple words on a single line (piped) will be interpreted as a single entry\"+char(10)+
	\"Usage: enum [path|file_object]\"+char(10)+
	\"-- enumerate file contents as a list of strings\"+char(10)+
	\"-- useful for 5hell scripting (see the '<b>do</b>' command).\"+char(10)+
	\"-- e.g: enum file.txt | enum 1\"+char(10)+
	\"---- enumerate file.txt then return index [1] from the list\"+char(10)+
	\"Usage: enum -l  -- return the length of enum buffer.\"+char(10)+
	\"Usage: enum -s  -- show the enum buffer and return the length\"+char(10)+
	\"Usage: enum -d  -- enumerate the onboard dictionary\"+char(10)+
	\"Usage: enum [#] -- return the element at index # in the enum buffer\"+char(10)+
	\"UsagE: enum -r [index] -- remove the element at index\"+char(10)+
	\"Usage: enum -i [index] [element] -- insert element at index \"+char(10)+
	\"-- shifts everything below it down\"+char(10)+
	\"Usage: enum -a [element] -- append element to end of enum buffer\"+char(10)+
	\"-- unlike enum [string] you may use enum -a [string] to append a single word to the enum buffer\"+char(10)+
	\"Usage: enum -e -- return the enum buffer as a list\"+char(10)+
	\"Usage: enum -b  -- concatonate the BUFFER and globals.enumerated (the enum buffer)\"+char(10)+
	\"Usage: enum -p -- purge the enum buffer\"+char(10)+
	\"Advanced: poke files.txt | lock |  | ls | append files.txt | cat files.txt | clipb | enum\"+char(10)+
	\"-- Or: ls | enum -- pipe ls output to the enum buffer\"+char(10)+
	\"Advanced: lanpro | enum -- scan network and enumerate all LAN addresses found. \"+char(10)+
	\"Advanced: enum -e -- return the enumerated buffer as a list object.\"+char(10)+
	\"Note: map support is coming soon(tm)\"
	if arg1 == null then return 0
	if not arg1 or arg1 == \"0\" then
		if globals.enumerated.len then return globals.enumerated[0] else return 0
	end if
	if arg1 == \"-r\" then 
		if not arg2 then return \"enum: -r expects an index\"
		if typeof(arg2.to_int) != \"number\" then return \"enum: invalid index\"
		if globals.enumerated.hasIndex(arg2.to_int) then 
			globals.enumerated.remove(arg2.to_int)
			return \"enum: entry at index \"+arg2+\" removed\"
		else 
			return \"enum: invalid index\"
		end if
	end if
	if arg1 == \"-b\" then 
		if globals.enumerated.len < 1 then return \"enum: enumerated buffer is empty\"
		print \"enum: <b>appending enumerated buffer to main BUFFER</b>\"
		globals.BUFFER = globals.BUFFER + globals.enumerated
		return 0
	end if 
	if arg1 == \"-p\" then 
		globals.enumerated = []
		return \"enum: \"+colorOrange+\" enum buffer purged\"
	end if
	if arg1 == \"-i\" then 
		if not arg3 then return \"enum: -i [index] [element]\"
		buf_bak = globals.enumerated
		if typeof(arg2) != \"string\" then return \"enum: -i expects string index\"
		if typeof(arg3) != \"string\" and typeof(arg3) != \"list\" then return \"enum: -i [index] [string|list]\"
		dx = arg2.to_int
		sbb = null 
		if typeof(arg3) == \"list\" then sbb = arg3 
		if typeof(arg3) == \"string\" then sbb = arg3.split(char(10))
		if typeof(dx) != \"number\" or dx >= buf_bak.len or dx < 0 then return \"enum: invalid index\"
		sli_1 = buf_bak[0:dx]
		sli_2 = buf_bak[dx:]
		new_buf = sli_1 + sbb + sli_2
		return \"enum: element inserted at index \"+dx
	end if
	if arg1 == \"-a\" then 
		if not arg2 then return \"enum: append failed: missing input\"
		sb = \"\"
		if typeof(arg2) == \"list\" then sb = arg2
		if typeof(arg2) == \"string\" then sb = arg2.split(char(10))
		if sb == \"\" then return \"enum: append failed: invalid type: expects string or list\"
		globals.enumerated = globals.enumerated + sb
		return \"enum: list appended\"
	end if
	if arg1 == \"-d\" then
		globals.enumerated = globals.dict_a[0:]
		print(\"enum: <b>onboard dictionary enumerated</b>. Num entries:\")
		return globals.enumerated.len
	end if
	if arg1 == \"-l\" then return str(globals.enumerated.len)
	if arg1 == \"-s\" then
		if not globals.enumerated.len then return 0
		ie = 0
		for ge in globals.enumerated
			print(\"[\"+ie+\"] \" + ge)
			ie = ie + 1
		end for
		return globals.enumerated.len
	end if
	if arg1 == \"-e\" then
		return globals.enumerated
	end if
	if typeof(arg1) == \"list\" then 
		globals.enumerated = arg1
		return \"enum: list enumerated\"
	end if
	if typeof(arg1) == \"map\" or typeof(arg1) == \"custom_object\" or typeof(arg1) == \"shell\" or typeof(arg1) == \"computer\" or typeof(arg1) == \"file\" then
	globals.enumerated = []
		for a in arg1
			globals.enumerated.push(a)
		end for
		return \"enum: map <b>enumerated.</b>\"
	end if
	if typeof(arg1) == \"number\" then arg1 = str(arg1)
	if typeof(arg1) == \"string\" and typeof(arg1.to_int) == \"number\" then
	 	if globals.enumerated.hasIndex(arg1.to_int) then return globals.enumerated[arg1.to_int] else return \"enum: error: invalid index\"
	end if
	if typeof(arg1) == \"string\" then
		if arg1.split(char(10)).len > 1 or arg1.split(\" \") > 1 then // more than one line or more than one word, otherwise it's a path
			globals.enumerated = arg1.split(char(10))
			for el in globals.enumerated
				if el == \"\" then
					globals.enumerated.remove(globals.enumerated.indexOf(el))
					continue
				end if
				globals.enumerated[globals.enumerated.indexOf(el)] = el.replace(char(32),\"\").trim
			end for
			return \"enum: entry <b>enumerated.</b>\"
		end if
		file = null
		file = globals.get_file(arg1)
		if not file then return \"enum: error: \"+arg1+\" not found.\"
		arg1 = file
	end if
	if typeof(arg1) == \"file\" then
		print(\"enum: purging...\")
		globals.enumerated = []
		if arg1.is_binary then return \"enum: can't open binary file\" else stuff_buf = arg1.get_content
		if stuff_buf then globals.enumerated = stuff_buf.split(char(10)) else return \"enum: error: file empty or read protected.\"
		return \"enum: \"+arg1+\" <b>enumerated.</b>\"
	end if
	return \"enum: error: unknown type\"
end function
command.rclean = function(arg1, arg2=0, arg3=0, arg4=0)
	if DEBUG then print(\"in rclean: got: \"+typeof(@arg1))
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Remote Clean || log scrubber || system.log cleaner\"+char(10)+
	\"Copy a file over the system.log to corrupt it\"+char(10)+
	\"Usage: rclean [opt: int ] -- select an object from buffer to atttempt a remote log wipe.\"+char(10)+
	\"Usage: rclean [file|shell|computer] -- remote wipe piped object\"+char(10)+
	\"-- e.g. clipb @B 1 | rclean -- where BUFFER[1] was a file|shell|computer\"+char(10)+
	\"-- rclean with no params will display a menu \"+char(10)+
	\"-- rclean is intended for remote scrubbing using BUFFER objects.\"+char(10)+
	\"-- However you may use silentclean or rclean for local log scrubbing\"+char(10)+
	\"-- if rclean detects a file named <b>silentclean</b> it will use that file to scrub the log\"+char(10)+
	\"-- for this reason it is a good idea to include an empty file named silentclean in the rkit\"+char(10)+
	\"-- or, rename an empty system.log file to silentclean\"+char(10)+
	\"---- or, a not so empty system.log file...\"+char(10)+
	\"Usage: rclean -d [#|shell|file|computer] -- run rclean as above and delete rkit and/or 5hell, if present\"+char(10)+
	\"Usage: rclean -n [#|shell|file|computer] -- run rclean as above and delete the contents of /boot, if present\"
	if arg1 and arg1 == \"-d\" then 
		arg1 = arg2
		arg2 = \"-d\"
	end if 
	if arg1 and arg1 == \"-n\" then 
		arg1 = arg2 
		arg2 = \"-n\"
	end if

	if arg1 and (typeof(arg1) == \"shell\" or typeof(arg1) == \"ftpshell\" or typeof(arg1) == \"computer\" or typeof(arg1) == \"file\") then return globals.rclean(arg1,arg2)
	if arg1 and typeof(arg1.to_int) == \"number\" then return globals.rclean(command.clipb(\"@B\",arg1),arg2)
	return globals.rclean(command.clipb(\"@B\",\"-m\"),arg2)
end function
command.ipfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: ipfit -- menu to specify a way to generate ips. (wip)\"+char(10)+\"Recommendation: pipe the output to a file or to the clipboard.\"+char(10)+\"e.g<b> ipfit | clipb </b>, or<b> ipfit | poke iplist </b>\"
	print(\"Configuring: \")
	print(\"<b>How do you want to specify ip's? </b>\"+char(10)+\"[0] - enter manually\"+char(10)+\"[1] - read from file \"+char(10)+\"[2] - random\")
	print(\"[3] - specify range\"+char(10)+\"[4] - from clipb\")
	choice = user_input(\"||: \",0,1).to_int
	ips = []
	if choice == 0 then
		ips = globals.scribus(ips)
		return ips
	end if
	if choice == 1 then
		ips = command.cat(user_input(\"path_to_file:> \"))
		return ips
	end if
	if choice == 2 then
		ips = command.rnip(user_input(\"# ips to create: \"))
		return ips
	end if
	if choice == 3 then
		print(\"Soon (tm)\")
		return \"Soon (tm)\"
	end if
	if choice == 4 then
		return command.clipb
	end if
	return 0
end function
command.code = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print(\"input type: \"+typeof(@arg1))
	if typeof(@arg1) == \"function\" then
		print(\"Function() detected...\")
		return globals.decompiler(@arg1)
	end if
	if @arg1 == null or @arg1 == \"-h\" or @arg1 == \"help\" then return \"<u>character code || cipher || encryption || || decryption || decompiler\"+char(10)+
	\"<b>CODE</b> encode and decode utility\"+char(10)+
	\"Supports standard Caesar cipher and 5hell's MuninCipher for encryption.\"+char(10)+
	\"May also return ascii character codes, decompile objects, and execute functions.\"+char(10)+
	\"Usage: code [char] -- returns ascii code for char\"+char(10)+
	\"Usage: code -c [int] -- returns ascii char(int)\"+char(10)+
	\"Usage: code [any_function|any_object] -- sends object to decompiler to view object map.\"+char(10)+
	\"-- will evaluate piped functions.\"+char(10)+
	\"Advanced: code [-d|-e] [word] -- decode|encode a word using standard caesar cypher\"+char(10)+
	\"Advanced: code [-a|-b] [opt:input] -- encode|decode using <b>MuninCipher(tm)</b>\"+char(10)+
	\"-- prompts for input if not supplied\"+char(10)+
	\"-- enter text to encrypt|decrypt on a single line up to 40,000 chars\"+char(10)+
	\"-- if input is more than one word use without params for prompt\"+char(10)+
	\"-- or use piping or an input file (see -f options)\"+char(10)+
	\"Advanced: code [-f|-fa|-fb] [/file/path|file_object] -- encode|decode contents of file\"+char(10)+
	\"-- option [-f] [path] -- prompts for enc/dec\"+char(10)+
	\"-- option [-fa|-af] [path] -- encode contents of path with MuninCipher\"+char(10)+
	\"-- option [-fb|-bf] [path] -- decode contents of path with MuninCipher\"+char(10)+
	\"<b>N.B.</b> MuninCipher is tamper resistant! Attempting to copy/paste the cipher text can/will corrupt it!\"
	Encode = function(instruction, password)
    caesar = function(type, pass)
				if pass == \"\" then return char(32)
        nr = pass.len%9
				if nr == 0 then nr = 25
        crypt = function(char, nr, type)
            if type == \"enc\" then return char+nr
            if type == \"dec\" then return char-nr
        end function
        out = []
        for i in range(0, pass.len-1)
            c = pass[i].code
            if c >= 48 and c <= 57 then
                c = crypt(c, nr, type)
                if c < 48 then c = c+10
                if c > 57 then c = c-10
            else if c >= 65 and c <= 90 then
                c = crypt(c, nr, type)
                if c < 65 then c = c+26
                if c > 90 then c = c-26
            else if c >= 97 and c <= 122 then
                c = crypt(c, nr, type)
                if c < 97 then c = c+26
                if c > 122 then c = c-26
            end if
            out.push(char(c))
        end for
        return out.join(\"\")
    end function
    output = caesar(instruction, password)  // instruction should be either \"enc\" for encode or \"dec\" for decode
    return output
	end function
	if @arg1 == 0 then return str(char(32).code)
	if @arg1 == \"0\" then return str(\"0\".code)
	if typeof(@arg1) == \"number\" then
		print(\"<mark=red><size=75%>Converting integer...</mark></size>\")
		arg1 = str(arg1)
	end if
	if @arg1 == \"-a\" or @arg1 == \"-b\" then
		enc_line = arg2
		if arg2 and typeof(arg2) != \"string\" then return \"code: -a|-b expects string input, got\"+typeof(arg2)
		if not arg2 then enc_line = user_input(\"MuninCipher:> \")
		if enc_line.len > 40000 and @arg1 == \"-a\" then return \"MC: max 40k characters for encode\"
		cipher_input = []
		cipher_output = []
		enc_dec = \"enc\"
		if @arg1 == \"-b\" then enc_dec = \"dec\"
		cipher_this = \"\"
		if enc_dec == \"enc\" then
			cipher_input = enc_line.split(char(32))
		else
			cipher_input.push(arg2)
		end if
		print(colorLightBlue+\"<mark=black>M</mark>unin<mark=black>C</mark>iphering: \"+cipher_input.join(\" \"))
		/////////////////////////////////////
		if enc_dec == \"dec\" then
			input_split = cipher_input[0].split(char(40001))
			ci_sli_dex = cipher_input[0].split(char(40001))[1]
			ci_sli_txt = cipher_input[0].split(char(40001))[0]
			cipher_size = ci_sli_dex.values
			cipher_size = cipher_size.pop
			cipher_size = cipher_size.code
			ci_sli_txt = ci_sli_txt.values
			spaces = []
			last_space = 0
			for dex in ci_sli_dex
				spaces.push(dex.code+last_space+1)
				last_space = spaces[-1]
			end for
			buf = []
			if DEBUG then print(\"debug:<b>indexed</b>\"+char(10)+\"debug:spacing\")
			spaces.pop
			for ci in range(0, cipher_size)
				if DEBUG then print(\"debug: ci = \"+ci)
				if spaces.len and spaces[0] == ci+1 then
					buf.push(char(32))
					spaces.pull
				else
					if ci_sli_txt.len then buf.push(ci_sli_txt.pull)
				end if
			end for
			buf = buf.join(\"\")
			//print(buf)
			cipher_input = buf.split(char(32))
		end if

		//////////////////////////////////////
		for password in cipher_input
		  cipher_this = password
		  for l in range(0,cipher_this.len)
		    //print(cipher_this)
		    cipher_this = Encode( enc_dec, cipher_this )
		  end for
		  cipher_output.push(cipher_this)
		end for
		//print(\"debug: output: \"+cipher_output)
		//////////////////////////////////////
		if enc_dec == \"enc\" then
			spacedex = \"\"
			for co in cipher_output
				spacedex = spacedex + char(co.len)
			end for
			leng = cipher_output.join(\" \").len
			cipher_output.push(char(40001))
			cipher_output.push(spacedex)
			cipher_output.push(char(leng))
			cipher_output.push(char(40001))
			cipher_output = cipher_output.join(\"\")
		end if
		/////////////////////////////////////
		print(colorLightBlue+\"<u><mark=black>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>\"+CT)
		if enc_dec == \"dec\" then return cipher_output.join(\" \")
		return cipher_output
	end if
	if @arg1 == \"-c\" and arg2 then return char(arg2.to_int)
	if @arg1 == \"-d\" then
		if not arg2 then return \"nothing to decode\"
		return Encode(\"dec\", arg2)
	end if
	if @arg1 == \"-e\" then
		if not arg2 then return \"nothing to encode\"
		return Encode(\"enc\", arg2)
	end if
	if @arg1 == \"-f\" or @arg1 == \"-fa\" or @arg1 == \"-af\" or @arg1 == \"-bf\" or @arg1 == \"-fb\" then
		act = 0
		if @arg1 == \"-f\" then act = (-1)
		if @arg1 == \"-fa\" or @arg1 == \"-af\" then act = 1
		cipher_file = null
		cipher_text = \"\"
		if not arg2 then return \"code: -f expects a file_path or file_object\"
		if typeof(arg2) == \"file\" then
			if not arg2.is_binary then cipher_file = arg2 else return \"code: cannot open binary file\"
			if cipher_file.has_permission(\"r\") then cipher_text = cipher_file.get_content.trim else return \"code: read error. check permissions\"
		end if
		if typeof(arg2) == \"string\" then
			cipher_text = command.cat(arg2)
		end if
		if act < 0 then act = user_input(\"[0] decode [<b>1</b>] encode ||: \",0,1).to_int
		if act == 0 then act = \"-b\" else act = \"-a\"
		return command.code(act, cipher_text)
	end if
	if DEBUG then print(\"Checking types...\")
	buf = []
	if typeof(@arg1) == \"string\" then
		print(\"<mark=yellow><size=75%>Processing string...</mark></size>\")
		if arg1 == \"\\n\" then return str(char(10).code)
		if arg1 == 0 or arg1 == \" \" then return str(\" \".code)
		arg1 = arg1.values
		for letter in arg1
			buf.push(letter.code)
		end for
		if DEBUG then print \"debug: code: string buf: \"+buf
		return buf.join(\", \")
	end if
	if typeof(@arg1) == \"shell\" or typeof(@arg1) == \"ftpshell\" or typeof(@arg1) == \"file\" or typeof(@arg1) == \"computer\" or typeof(@arg1) == \"map\" or typeof(@arg1) == \"custom_object\" or typeof(@arg1) == \"list\" then return globals.decompiler(@arg1)
	if typeof(@arg1) == \"pshell\" or typeof(@arg1) == \"pcomputer\" or typeof(@arg1) == \"pfile\" or typeof(@arg1) == \"prouter\" then return globals.decompiler(@arg1)
	if @arg1.hasIndex(\"__isa\") then return globals.decompiler(@arg1)
	check = new @arg1 
	if typeof(@check) == \"map\" then return globals.decompiler(@arg1)
	return \"code: unkown type\"
end function
command.md5 = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == \"help\" or arg1 == \"-h\" then return \"MD5SUM || md5 sum || password hash decipher || encode\"+char(10)+\"Usage: md5 [string] -- returns the md5sum of a string\"+char(10)+\"Usage: md5 -d [32_char_hash] -- checks hash against onboard dictionary then attempts decipher\"+char(10)+\"-- defaults to crypto.so if cerebrum is not loaded\"+char(10)+\"-- one of three main ways to decipher password hash combo's\"+char(10)+\"-- see also: <b>gopher</b>, <b>hashim</b>, <b>brutus</b>\"
	if arg1 == \"-d\" then
		if not arg2 or typeof(arg2) != \"string\" or arg2.len != 32 then
			return \"[-d] expects 32 character hash string\"
		else
			for d in dict_a
				if md5(d) == arg2 then
					print(\"md5: found: [\"+colorWhite+\" \"+d+CT+\" : \"+colorGold+arg2+CT+\" ]\")
					return d
				end if
			end for
			print \"gopher: hash not in dictionary\"+char(10)+\"-- defaulting to crypto.so\"
			if crypto then
				rslt = crypto.decipher(arg2)
				if rslt then return rslt
			else 
				print \"md5: cryto.so library is not loaded\"
			end if
			return \"md5: hash not found\"
		end if
	end if
	if typeof(arg1) == \"string\" then return md5(arg1) else return \"md5: string required\"
end function
command.pipe = function(arg1, arg2, arg3=0, arg4=0)
	return \"pipe usage: place <b>|</b> between sets of commands to pipe a commands output\"+char(10)+
	\"The output of a command can be piped to the input of the following command using a pipe.\"+char(10)+
	\"Examples: \"+char(10)+
	\"lanpro | enum\"+char(10)+
	\"ls -la /root | clipb | enum | poke file.txt | lock || clipb | append file.txt\"+char(10)+
	\"You may chain commands without piping by using <b>||</b> instead\"+char(10)+
	\"-- eg: command1 || command2 -- output from command1 is NOT passed to command2\"
end function
command.do = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then
		if arg2 == \"extra\" then
			return \"<u><mark=red>=============</u></mark>\"+char(10)+
			\"Setup (copy after the |> and paste into 5hell): \"+char(10)+
			\"|> clipa 0 | rnip 11 | enum | enum -s | do\"+char(10)+
			\"Paste this Script : \"+char(10)+
			\"clipa | enum | probe\"+char(10)+
			\"calc @a + 1 | clipa\"+char(10)+
			\"Result:\"+char(10)+
			\"set clipa to 0, produce 11 random ips, enumerate those ips, do 11 loops of: probe enum[clipa], clipa++\"+char(10)+
			\"-- this runs probe on 11 random ips stored in the enum(eration) buffer using calc and the clipboard to iterate through the list.\"+char(10)+
			\"<u><mark=red>=============</u></mark>\"+char(10)+
			\"Setup (copy after the |> and paste into 5hell)\"+char(10)+
			\"|> clipa 1 | ls -a /lib | enum | enum -s | do\"+char(10)+
			\"Paste this Script : \"+char(10)+
			\"clipa | enum | db -l\"+char(10)+
			\"calc @a + 1 | clipa\"+char(10)+
			\"Result:\"+char(10)+
			\"set clipa to 1, enumerate files in /lib, do [num_files+1] loops, start at 1 and run db (databaser) on each file, the error at the end is because ls returns with an extra blank line which gets enumerated at position [0] resulting in the loop being 1 over.\"+char(10)+
			\"<u><mark=red>=============</u></mark>\"+char(10)+
			\"(all commands are valid but note interactive commands will still require interaction)\"
		else
			return colorGold+\"<u>DO || SCRIPTING || AUTOMATION || NOT BASH || BATCH COMMANDS || DORC || BASHRC\"+char(10)+
			colorWhite+\"</b>The scheduling or automation service for 5hell. You write a set of\"+char(10)+
			colorWhite+\"</b>commands for 5hell to <b>do</b>. Commands may be entered in-line on the\"+char(10)+
			colorWhite+\"</b>command line, entered into a text editor buffer, or read from a text file.\"+char(10)+
			colorWhite+\"</b>see also: do help extra -- for some example do scripts\"+char(10)+
			colorGold+\"</b>-- see also: <b>help prompt</b>, <b>dig -h</b>, <b>scribus -h</b>\"+char(10)+
			colorWhite+\"</b>Do may be launched in a number of ways, depending on your goals:\"+char(10)+char(10)+
			colorCyan+\"Usage: do [int] [command] [arg1] [arg2]-- perform [command] [int] times\"+char(10)+
			colorLightBlue+\"</b>-- passes arg1 and arg2 to the command\"+char(10)+
			colorLightBlue+\"</b>-- use text blocks to pass complex arguments and/or complex commands\"+char(10)+
			colorGold+\"</b>-- eg: |><b> do 3 \"\" rnip 1 | probe | db -r | zap \"\" \"+char(10)+
			colorGold+\"</b>-- eg: |><b> do 1 poke test.txt \"\" this is a bunch of text \"\" \"+char(10)+
			colorLightBlue+\"</b>---- note: in practice the above line can be done without the <b>do 1</b>\"+char(10)+
			colorLightBlue+\"</b>---- it's just an example of how you would supply complex parameters to <b>do</b>\"+char(10)+
			colorLightBlue+\"- - - - - - - - - - - \"+char(10)+
			colorCyan+\"Usage: do -- without arguments will prompt for iterations then open the editor\"+char(10)+
			colorCyan+\"Usage: do [#] -- supplying iteration without a command opens the editor immediately\"+char(10)+
			colorLightBlue+\"</b>-- enter commands into the editor and enter @ on a newline to begin execution\"+char(10)+
			colorLightBlue+\"</b>-- the commands in the editor remain until changed and therefore may be rerun/reused\"+char(10)+
			colorLightBlue+\"</b>-- you may use <b>scribus @do</b> to edit the <b>do</b> buffer without firing the script\"+char(10)+char(10)+
			colorCyan+\"Usage: do [int] -f [/path] -- perform commands in [/path] [int] times\"+char(10)+
			colorLightBlue+\"</b>-- the preferred method of firing a 'batch' of commands\"+char(10)+
			colorLightBlue+\"</b>-- many examples may use a .bat extension but the .bat extension is not enforced at all\"+char(10)+
			colorLightBlue+\"</b>-- it is just a convention, you may name them whatever you wish except:\"+char(10)+
			colorLightBlue+\"</b>---- dig.bat must be named dig.bat in order for <b>dig</b> to use it (see dig -h)\"+char(10)+
			colorGold+\"</b>-- nested calls to the do command within these files are valid and encouraged\"+char(10)+
			colorGold+\"</b>---- dig.bat: cerebrum | brutus | run /home/guest/rkit/5hell \"\" do 1 -f file2.bat \"\" \"+char(10)+
			colorGold+\"</b>---- file2.bat: rshell @home | sc -d | exit rshell_placed\"+char(10)+
			colorLightBlue+\"</b>-- by placing these two files in your rkit folder and running <b>dig [ip]</b> you are able to:\"+char(10)+
			colorLightBlue+\"</b>---- automate: infiltrating and placing a root rshell on the target\"+char(10)+
			colorLightBlue+\"</b>----- removing your rkit\"+char(10)+
			colorLightBlue+\"</b>----- and cleaning the log\"+char(10)+
			colorCyan+\"Alias: \"+colorWhite+\"do 1 -f [path]\"+CT+\" has been aliased to\"+colorWhite+\" bat [path]\"+CT+\" in 5hell.src\"+char(10)+char(10)+
			colorCyan+\"You may launch 5hell from the game's command line with a 'do' instruction:\"+char(10)+
			colorLightBlue+\"</b>-- instead of launching 5hell simply by typing '5hell' you may launch with:\"+char(10)+
			colorGold+\"</b>----# 5hell do [#] [opt:-f] [command|path]\"+char(10)+
			colorLightBlue+\"</b>-- and 5hell will launch and immediately begin running the given commands\"+char(10)+
			colorLightBlue+\"</b>-- 5hell will then drop to the exit prompt;\"+char(10)+
			colorLightBlue+\"</b>---- press 'y' if you wish to exit, press enter or any other key to continue running\"+char(10)+
			colorGold+\"This allows 5hell to launch 5hell with instructions to launch 5hell with instructions to...\"+char(10)+
			colorLightBlue+\"</b>-- keep in mind there is a game limit of 15 <u>nested</u> uses of shell.launch\"+char(10)+
			colorLightBlue+\"</b>-- but no limit to the number of uses of shell.launch; meaning <b>do 1000 dig -s</b> is completely valid\"+char(10)+
			colorLightBlue+\"</b>-- please note that the game does not allow the use of <b>\"\"</b> in launch parameters\"+char(10)+
			colorLightBlue+\"</b>----<b> 5hell do 1 echo three | echo two | echo one\"+char(10)+
			colorLightBlue+\"</b>---- will result in 5hell running the three echoes at launch \"+char(10)+
			colorLightBlue+\"</b>---- if this line were typed at runtime, it would have to be:\"+char(10)+
			colorLightBlue+\"</b>----<b> do 1 \"\" echo three | echo two | echo one \"\"\"+char(10)+
			colorLightBlue+\"</b>Note: launching 5hell with <b>do</b> results in 5hell exiting on completion\"+char(10)+
			colorCyan+\"</b>However:\"+char(10)+
			colorLightBlue+\"</b>-- you may launch 5hell with params, without do:\"+char(10)+
			colorLightBlue+\"</b>----<b> 5hell echo three | echo two | echo one\"+char(10)+
			colorLightBlue+\"</b>---- will result in the same behavior, but 5hell will <b>not exit</b> on completion\"+char(10)+char(10)+
			colorGold+\"Advanced: Resource Configuration\"+char(10)+
			colorCyan+\"You may place a file named \"+colorWhite+\"do.rc</color> in your \"+colorWhite+\"rkit</color> and/or \"+colorWhite+\"Config folder\"+char(10)+
			colorLightBlue+\"</b>-- the contents of the file should look like a standard <b>do</b> script and will be executed on launch\"+char(10)+
			colorLightBlue+\"</b>-- unlike launching with <b>5hell do 1 -f do.rc</b>, this method will not exit on completion\"+char(10)+
			colorLightBlue+\"</b>-- do.rc in <b>Config</b> will take priority over do.rc in <b>rkit</b>. This allows a 'home' and 'away' do.rc\"+char(10)+
			char(10)+
			colorCyan+\"Early Termination:\"+char(10)+
			colorLightBlue+\"</b>If the final return value of a line in a do script is: <b>@STOP</b>, then:\"+char(10)+
			colorLightBlue+\"</b>-- that iteration will cease, and the next iteration will begin\"+char(10)+
			\"----: equivalent to a <b>continue</b>\"+char(10)+
			colorLightBlue+\"</b>If the final return value of a line in a do script is: <b>@RETURN</b>, then:\"+char(10)+
			\"-- the do script will terminate; no further iterations will run\"+char(10)+
			\"----: equivalent to a <b>break</b>\"+char(10)+char(10)+
			colorCyan+\"Comments:\"+char(10)+
			colorLightBlue+\"</b>You may add comments to <b>do</b> scripts. The comment character must be placed\"+char(10)+
			colorLightBlue+\"</b>on it's own line. Comments place within command strings or at the end will error.\"+char(10)+
			colorLightBlue+\"</b>Valid comment characters are: <b>#, /, and -</b>\"+char(10)+
			colorLightBlue+\"</b><size=75%>While <b>|</b> will technically work, it might break things down the road if\"+char(10)+ 
			colorLightBlue+\"5hell.src changes. If a comment character is the first character on a line, <b>do</b> will skip that line.\"+char(10)+
			colorLightBlue+\"Please note that because macros are done in-line, they may not include comments. Please\"+char(10)+
			colorLightBlue+\"keep this in mind if piping the contents of a do script into a macro definition.\"

			colorGreen+\"As you can see, 5hell is designed to be (almost*) completely automated.\"+char(10)
			colorGreen+\"See Also: macro -h, help conventions, help alias, help automation\"
		end if
	end if
	iter = 0
	cmd = []
	if arg1 then
		if typeof(arg1) == \"number\" then iter = arg1 else iter = arg1.to_int
	else
		iter = user_input(\"Number of iterations to run command:\"+char(10)+\":> \").to_int
	end if
	if not iter or typeof(iter) != \"number\" then return \"do: invalid iteration.\"
	if arg2 and arg2 != \"\" then
		if arg2 == \"-f\" then
			cmd.push(arg2)
		else
			if arg3 then arg2 = arg2 + \" \" + arg3
			if arg4 then arg2 = arg2 + \" \" + arg4
			cmd.push(arg2)
		end if
	else
		print(\"Configure command list: \")
		print(\"* piped commands go on a single line separated by | \")
		print(\"* non-piped commands go on a new line \")
		print(\"* @ on newline to save and execute\")
		print(\"* @@ on newline to abort and quit\")
		cmd_hold = command.scribus(\"@do\")
		if cmd_hold then cmd = cmd_hold.split(char(10)) else return \"aborting...\"
		//print(cmd.join(char(10)))
	end if
	if cmd[0] == \"-f\" then
		if arg3 then
			cf = globals.get_file(arg3)
			if not cf then return \"do: file: \"+arg3+\" not found\"
			if cf.is_binary then return \"do: cannot open binary file\"
			if not cf.has_permission(\"r\") then return \"do: can't read \"+arg3+\": permission denied\"
			cmd = cf.get_content.split(char(10))
		else
			return \"do: input error: -f expects a file path\"
		end if
	end if
	time_s = time
	if DEBUG then print(cmd)
	if cmd.len then
		for i in range(1,iter)
			//print(colorBlack+\"*\"+CT)
			for c in cmd
				// experimental
				if c == globals.SAFEWORD then break // ick
				c = c + \" | return\"
				r = command.shell(c)
				if r == \"@STOP\" then break
				if r == \"@RETURN\" then return
			end for
		end for
	else
		return \"<b>aborting...</b>\"
	end if
	return colorCyan+\"<size=50%>do: batch complete in [</size><size=75%>\"+colorOrange+(time-time_s)+colorCyan+\"</size><size=50%>] seconds\"+CT
end function
command.cc = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \": carbon copy: command buffer.\"+char(10)+\"Usage: cc -- select command from history.\"+char(10)+\"Usage: cc [#] -- where # corresponds to the command you wish to run from the command buffer.\"+char(10)+\"-- will <b>return</b> the output of the commands as if they were run normally.\"+char(10)+\"-- you may use cc inside of pipe chains.\"+char(10)+\"---- e.g: cc 22 | echo | cc 10 | poke file.txt\"
	i = 0
	schtick = \"| return\"
	if not arg1 then 
		for ccom in globals.command_buffer
			print(\"[\"+colorWhite+i+CT+\"] \"+char(187)+\" \"+ccom)
			i = i + 1
		end for
	end if
	do = null
	if arg1 then do = arg1.to_int
	if not do then do = user_input(\"cc:> \",0,0).to_int
	if typeof(do) == \"number\" and do >= 0 and do < globals.command_buffer.len then
		carbon = globals.command_buffer[do]
		carbon = carbon +\" \"+ schtick
		//carbon = carbon.split(\" \")
		return command.shell( carbon )
	else
		return \"cc: invalid index\"	
	end if
	return 0
end function
command.time = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: time -- returns current game time.\"+char(10)+\"Usage: time [-d|date] -- returns current game time and date.\"+char(10)+\"Usage: time [-t] -- returns time in seconds since script launch.\"
	if arg1 == \"-t\" then return time
	if arg1 == \"-d\" or arg1 == \"date\" then return current_date
	return current_date.split(\" \")[2]
end function
command.pause = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == \"0\" or arg1 == \"help\" or arg1 == \"-h\" then return \"Pause || Wait || Hang || Sleep\"+char(10)+
	// note, this function expects time as a string, the user should form the string as a float. eg: pause .01 -- where .01 is a string
	\"Usage: pause [seconds(float)] -- pauses script execution\"+char(10)+
	\"-- Minumum time: .01 seconds\"+char(10)+
	\"-- Maximum time: 300 seconds\"+char(10)+
	\"-- useful for putting a delay in 'do' scripts.\"+char(10)+
	\"-- useful for putting a delay in a chain of commands\"+char(10)+
	\"-- this command uses the general function: wait(time)\"+char(10)+
	\"Usage: pause [-v] [delay] -- as above but prints a notification at each pause\"+char(10)+
	\"Usage: pause [-m] -- pause until manually unpaused (by pressing enter)\"

	time_to_wait = \"1\" // default wait 1 second 
	manual_unpause = false // if false the chain of commands continues after the pause, if true then press a key to continue
	verbose = false // if false; works silently. if true; prints a line on each pause
	if arg1 == \"-m\" then 
		manual_unpause = true 
		arg1 = \".01\"
	end if
	if arg1 == \"-v\" then 
		verbose = true 
		arg1 = arg2 
	end if
	if DEBUG then print \"debug: in pause: arg 1 is: \"+arg1+\" and manual pause is: \"+manual_unpause
	if typeof(arg1.val) == \"number\" then time_to_wait = arg1.val else return \"pause: invalid interval: expects positive float [.01 : 300]\"+char(10)+\"n.b. - negative values will not reverse time\"
	if manual_unpause then return user_input(colorWhite+\"pause</b>: script execution paused\"+char(10)+\"-- press <\"+colorGreen+\"enter\"+CT+\"> to continue --\")
	if time_to_wait <= 300 and time_to_wait >= .01 then
		if DEBUG then print \"debug: ttw is\"+time_to_wait
	else
		time_to_wait = 1
		print \"pause: invalid wait time: changing time_to_wait to 1 second\"
	end if
	if verbose then print colorWhite+\"<u>pause</b>: script execution paused for <b>\"+time_to_wait+\"</b> seconds...\"
	wait(time_to_wait)
	if verbose then return colorWhite+\"pause:\"+CT+\" resuming script execution\"
	return 0
end function
command.bios = function(arg1=0, arg2=0, arg3=0, arg4=0)
if arg1 == \"help\" or arg1 == \"-h\" then return \"OBJECT | MEMORY | BIOS | CERBIOS\"+char(10)+
\"Usage: bios -- system info\"+char(10)+
\"Advanced:copy the following to 5hell's command line:\"+char(10)+
\"<b>mkdir /virt | poke /virt/hdd.io dev_sda:SIZE </b>\"+char(10)+
\"-- replace SIZE with the maximum size of your hdd in bytes. \"+char(10)+
\"-- this lets bios report the remaining hdd space\"+char(10)+
\"Usage: bios -a -- return the currently loaded <color=#FFD000>aptclientlib object\"+char(10)+
\"Usage: bios -m -- return the currently linked <color=#13E6CA>metaLib object\"+char(10)+
\"Usage: bios -x -- return the currently loaded <color=#FF0800>metaxploitLib object\"+char(10)+
\"Usage: bios -c -- return the currently loaded <color=#8C00FF>crypto object\"+char(10)+
\"Usage: bios -n -- return the currently linked <color=#0011FF>netsession object\"+char(10)+
\"Usage: bios -p -- return the currently loaded <color=#69E488>port_map object as a string\"+char(10)+
\"Usage: bios -H -- return the currently linked <color=#E4EE58>herme5 meta.mail object\"+char(10)+
\"-- returns null if not logged in to a mail account\"+char(10)+
\"Usage: bios -s -- return the currently loaded <color=#8B8568>meta_scan information</color> as a string\"+char(10)+
\"Usage: bios -P -- return the currently loaded <color=#00FF40>port_map object as a map\"+char(10)+
\"Usage: bios -X -- return the currently loaded <color=#065F0D>XPLOITS as a list\"+char(10)+
\"Usage: bios -M -- return the current <color=#FF00C8>MEMORY object or null\"+char(10)+
\"Usage: bios -B -- return the global <color=#E68A13>BUFFER as a list\"+char(10)+
\"Usage: bios -r [opt: ip] -- return the <b>local<b> <color=#71858D>router object</color> [opt:ip]\"+char(10)+
\"Usage: bios -i [path] -- runs <b>include_lib</b> on path and returns result\"+char(10)+
\"-- init.so, net.so, kernel_module.so cannot be imported as they lack an API\"+char(10)+
\"-- prompts for path if path not supplied\"+char(10)+
\"---- e.g.|> bios -i /lib/blockchain.so | malp \"+char(10)+
\"---- returns the blockchainLib object and pipes it to malp (to the BUFFER)\"+char(10)+
\"---- note: cannot include_lib net.so, init.so, kernel_module.so\"+char(10)+
\"------ only libs with API's may use include_lib\"+char(10)+
\"------ use meta link to load those with the metaxploitLib\"+char(10)+
\"Usage: bios --stack -- return the global stack_pool value (as a string numeral)\"+char(10)+
\"-- this value is incremented by one with each use of <B>run</b> (shell.launch)\"+char(10)+
\"-- this value is decremented on return from <b>run</b>\"+char(10)+
\"-- current stack_pool: <b>\"+globals.stack_pool
\"Usage: bios --home -- return the globals.HOME_SERVER list\"+char(10)+
\"-- current HOME_SERVER: <size=75%><b>\"+globals.HOME_SERVER
if arg1 == \"--stack\" then return str(globals.stack_pool)
if arg1 == \"-a\" then return globals.apt_get 
if arg1 == \"-x\" then return globals.metaxploit 
if arg1 == \"-c\" then return globals.crypto 
if arg1 == \"-n\" then return globals.net_session
if arg1 == \"-p\" then return globals.display_portmap(1)
if arg1 == \"-P\" then return globals.PORT_MAP
if arg1 == \"-H\" then return globals.inbox
if arg1 == \"-m\" then return globals.metaLib
if arg1 == \"-s\" then return globals.meta_scan
if arg1 == \"-X\" then return globals.XPLOITS 
if arg1 == \"-M\" then return globals.MEMORY
if arg1 == \"-B\" then return globals.BUFFER
if arg1 == \"--home\" then return globals.HOME_SERVER
if arg1 == \"-r\" then 
	if arg2 then
		if is_valid_ip(arg2) then return get_router(arg2)
		return \"bios: get_router: invalid ip\"
	else 
		return get_router
	end if
end if
if arg1 == \"-i\" then 
	if not arg2 then 
		arg2 = user_input(\"Enter path to file.so :> \")
	end if
	tf = globals.get_file(arg2)
	if not tf then return \"bios: \"+colorRed+\"</b>target file not found!\"
	inc = include_lib(arg2)
	if inc then globals.BUFFER.push(inc)
	print \"bios: sending \"+inc+\" to \"+colorOrange+\"BUFFER...\"
	if not inc then return \"bios: \"+colorRed+\"</b>include_lib failed:\"+char(10)+\"-- target file does not have an API\"+char(10)+colorGreen+\"kore: helper:</b> perhaps try<b> meta link -l [libname] </b>instead\"+char(10)+\"-- if you meant metax.load(\"+arg2+\")\" else return inc
end if

bios_info = []
bios_info.push(\"<mark=red><u>=======================================================================</u></mark>\")
bios_info.push(\"<u><mark=red>=</mark><color=red>__(WIP)________________cer_bios_v_0.6_by_Plu70________________(WIP)__</color><mark=red>=</mark></u>\")
bios_info.push(\"* \"+current_date+\" \"+globals.localmachine.local_ip+\" @ \"+globals.localmachine.public_ip+\" up: \"+time)
procs = globals.localmachine.show_procs.split(char(10))
//print(procs)
root_procs = 0
user_procs = 0
guest_procs = 0
mem_used = 0
cpu_used = 0
for p in procs
	spl = p.split(\" \")
	pro_usr = spl[0]
	pro_idn = spl[1]
	pro_cpu = spl[2].remove(\"%\")
	pro_mem = spl[3].remove(\"%\")
	pro_nam = spl[4]
	if pro_cpu != \"CPU\" then cpu_used = cpu_used + pro_cpu.val
	if pro_mem != \"MEM\" then mem_used = mem_used + pro_mem.val
	if pro_usr == \"root\" then
		root_procs = root_procs + 1
	else
		if pro_usr == \"guest\" then
			guest_procs = guest_procs + 1
		else
			if pro_usr != \"USER\" then user_procs = user_procs + 1
		end if
	end if
end for
root = localmachine.File(\"/\")
hdd_io = localmachine.File(\"/virt/hdd.io\")
h_size = \"<color=red>dev_sda error</color>\"
if hdd_io then
	h_c = hdd_io.get_content.split(char(10))
	h_s = h_c[0].split(\":\")
	h_n = 0
	if h_s.len > 1 then h_n = h_s[1].val
	if h_n then h_size = h_n - root.size.val else h_size = \"<color=red>dev_sda error</color>\"
end if
if globals.stack_pool >= 15 then stack_print = \"depleted; restart required\" else stack_print = globals.stack_pool
bios_info.push(\"<mark=red><size=85%>|</size></mark>\")
bios_info.push(\"<size=85%>Macula Registry: [stack_pool:\"+colorRed+stack_print+CT+\"] </size>\")
bios_info.push(\"<size=85%>root_procs [<b>\"+root_procs+\"</b>] user_procs [<b>\"+user_procs+\"</b>]  guest_procs [<b>\"+guest_procs+\"</b>] t:<b> \"+(procs.len-1)+\"</b></size>\")
bios_info.push(\"<size=85%>cpu_usage: [\"+cpu_used+\"%] mem_usage: [\"+mem_used+\"%] temp: <color=red>therm_io not found</color></size>\")
bios_info.push(\"<size=85%>[cpu:<mark=green>|\"+\"|\"*(cpu_used/4)+\"</mark>\"+\"_\"*((100-cpu_used)/4)+\"]   [ram:<mark=green>\"+\"|\"*(mem_used/4+1)+\"</mark>\"+\"_\"*((100-mem_used)/4)+\"]</size>\")
bios_info.push(\"<size=85%>[hdd_used: <b>\"+root.size+\" </b>bytes]  [hdd_free: \"+h_size+\" bytes]</size>\")
allfiles = command.tree(\"-r\",\"/\")
folds = 0
bins = 0
txts = 0
tot = 0
for f in allfiles
	if f.is_folder then 
		folds = folds + 1
	else if f.is_binary then 
		bins = bins + 1
	else
		txts = txts + 1
	end if
end for
tot = folds + bins + txts
bios_info.push(\"<size=85%>num_folders [\"+folds+\"] num_binaries [\"+bins+\"] num_ascii [\"+txts+\"] tot: [\"+tot+\"]</size>\")
ess = \"-wifi disabled-\"
if localmachine.active_net_card == \"WIFI\" then
	//sig = floor(rnd*99)+1
	//sig = sig - 0
	sig = 0
	nets = localmachine.wifi_networks(\"wlan0\") // list
	ess = get_router.essid_name
	_get_wifi = function(networks)
		for net in networks 
			n = net.split(\" \")
			if DEBUG then print \"debug: n is: \"+n+\" and n[1] is: \"+n[2]
			if ess == n[2] then
				sig = n[1].replace(\"%\",\"\")
				sig = sig.to_int
				if DEBUG then print \"debug: sig strength is: \"+sig+\"%\"
				return sig 
			end if
		end for
		return 0
	end function
	sig = _get_wifi(nets)
	sig_not = 100 - sig
	bios_info.push(\"<size=85%>[wifi_signal:<mark=green>|\"+\"|\"*(sig/2)+\"</mark>\"+\"_\"*(sig_not/2)+\"]</size>\")
end if
dl = localmachine.network_devices.split(char(10))
bios_info.push(\"<size=85%>[\"+dl.join(\"] [\")+localmachine.active_net_card+\"] [\"+ess+\"]\")
ports = localmachine.get_ports
pl = []
for p in ports
	pl.push(p.port_number)
end for
bios_info.push(\"<size=85%>ports: [\"+pl.join(\"] [\")+\"] </size>\")
bios_info.push(\"<mark=red><size=50%>|</size></mark>\")
if DEBUG then print \"debug: bios searching for database...\"
database = command.tree(\"/\",\"database.csv\",1,\"N\")
data_lines = \"--\"
data_size = \"-not_found-\"
if database then
	if DEBUG then print \"-- found database.csv: \"+database.path
	data_size = command.file(\"-c\",database)
	if database.has_permission(\"r\") then data_lines = command.file(\"-l\",database) else data_lines = \"-check_perms-\"
	if data_size.to_int > \"150000\".to_int then data_size = colorOrange+\"Warning: \"+data_size+CT
end if
bios_info.push(\"<size=85%>[database_size:\"+data_size+\"]  [database_lines:\"+data_lines+\"]</size>\")
bios_info.push(\"<size=85%>[BUFFER: \"+globals.BUFFER.len+\" objects]</size>\" )
bios_info.push(\"<size=85%>[Custom_Object: \"+get_custom_object.len+\" indexes]\")
bios_info.push(\"<size=85%>[tagged4scp: \"+globals.tagged_for_scp+\"]</size>\")
bios_info.push(\"[tbuf:<size=60%>\"+globals.T_BUF.join(\" \")+\"</size>]</size>\")
if typeof(@globals.clip_board_alpha) == \"string\" then
	bios_info.push(\"[clipa:<size=60%>\"+@globals.clip_board_alpha.replace(char(10),\", \")+\"</size>]\")
else
	bios_info.push(\"[clipa:<size=60%>\"+@globals.clip_board_alpha+\"</size>]\")
end if
if typeof(@globals.clip_board_beta) == \"string\" then
	bios_info.push(\"[clipb:<size=60%>\"+@globals.clip_board_beta.replace(char(10),\", \")+\"</size>]\")
else
	bios_info.push(\"[clipb:<size=60%>\"+@globals.clip_board_beta+\"</size>]\")
end if
if typeof(@globals.clip_board_gamma) == \"string\" then
	bios_info.push(\"[clipc:<size=60%>\"+@globals.clip_board_gamma.replace(char(10),\", \")+\"</size>]\")
else
	bios_info.push(\"[clipc:<size=60%>\"+@globals.clip_board_gamma+\"</size>]\")
end if
mscan = \"-none-\"
if globals.meta_scan then mscan = \"ready\"
bios_info.push(\"<size=85%>[portmap:\"+globals.PORT_MAP.len+\"] [xploits: \"+globals.NUM_SPLOITS+\"] [metascan: ]</size>\")
bios_info.push(\"<size=85%>[dict_a:\"+colorGold+globals.dict_a.len+CT+\"]  [dict_size: \"+dict_a.join(\", \").len+\"]</size>\")
bios_info.push(\"<mark=red><size=50%>|</size></mark>\")
score = 10
pwf = command.tree(\"/etc\",\"passwd\",1,\"N\")
if pwf then 
	pwf = pwf.permissions 
	score = score - 1
else 
	pwf = \"--null--\"
end if
bff = command.tree(\"/\",\"Bank.txt\",1,\"N\")
if bff then
	bff = bff.parent.path 
	score = score - 1
else 
	bff = \"--null--\"
end if
mtf = command.tree(\"/\",\"Mail.txt\",1,\"N\")
if mtf then 
	mtf = mtf.parent.path 
	score = score - 1
else 
	mtf = \"--null--\"
end if
mcf = command.tree(\"/\",\"Map.conf\",1,\"N\")
if mcf then 
	mcf = mcf.parent.path 
	score = score - 1
else 
	mcf = \"--null--\"
end if
bcf = command.tree(\"/\",\"Browser.txt\",1,\"N\")
if bcf then 
	bcf = bcf.parent.path 
	score = score - 1
else 
	bcf = \"--null--\"
end if
clf = command.tree(\"/\",\"ConfigLan.conf\",1,\"N\")
if clf then 
	clf = clf.parent.path 
	score = score - 1
else 
	clf = \"--null--\"
end if
unsec_files = 0
unsec_dirs = 0
for file in allfiles
	fp = file.permissions.values 
	if fp[-1] != \"-\" or fp[-2] != \"-\" or fp[-3] != \"-\" then 
		if file.is_folder then unsec_dirs = unsec_dirs + 1 else unsec_files = unsec_files + 1
	end if	
end for
if unsec_files then score = score - 1
if unsec_dirs then score = score - 1
log = localmachine.File(\"/var/system.log\")
log_size = 0
log_is_binary = 0
log_permissions = \"-log-missing-\"
if log then
	log_size = log.size
	log_is_binary = log.is_binary
	log_permissions = log.permissions
end if
log_ps = log_permissions.values
if log_ps[-2] != \"-\" or log_ps[-3] != \"-\" then score = score - 1
if score == 10 then 
	score = colorGreen+str(score) 
	else if score < 2 then 
		score = colorRed+str(score)
	else 
		score = colorOrange+str(score)
end if
bios_info.push(\"<size=85%>Security Audit Score: \"+score+\"/10</size>\")
bios_info.push(\"<size=60%>[unsecured_files:\"+unsec_files+\"]  [unsecured_directories: \"+unsec_dirs+\" ]</size>\")
bios_info.push(\"<size=60%>[/etc/passwd:\"+pwf+\"] [Mail.txt:\"+mtf+\"] [Bank.txt:\"+bff+\"]</size>\")
bios_info.push(\"<size=60%>[Map.conf:\"+mcf+\"] [Browser.txt:\"+bcf+\"] [ConfigLan.conf:\"+clf+\"]</size>\")
//bios_info.push(\"<size=60%>[services:                   ]</size>\")
bios_info.push(\"<mark=red><size=50%>|</size></mark>\")


bios_info.push(\"<size=85%>[/var/system.log: \"+log_size+\" bytes || is_binary: \"+log_is_binary+\" || perms: \"+log_permissions+\" ]\")
bios_info.push(\"<mark=red><size=50%>|</size></mark>\")
bios_info.push(\"*<size=50%> (obvious stub needs obvious improvement)</size>\")
bios_info.push(\"*<size=50%> see <b>bios -h</b> for additional usage info.\")
bios_info.push(\"<mark=red><u>=======================================================================</u></mark>\")

return bios_info.join(char(10))
end function
command.cname = function(arg1,arg2,arg3,arg4)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: cname -- returns the name of the currently active computer_object\"
	return localmachine.get_name
end function
command.whoami = function(arg1,arg2,arg3,arg4)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"WHOAMI || current user || active user || new user, who dis?\"+char(10)+
	\"Usage: whoami -- returns the active_user\"+char(10)+
	\"-- if GLASSPOOL is active; returns best guess at active user\"
	if GLASSPOOL then return checkUser(localmachine) else return active_user
end function

command.credits = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"credits\"
	logo = []
	logo.push(\"  |-----\\ \"+CT+colorWhite+\"   |      |   /--------   |          |         \")
	logo.push(\"  |     | \"+CT+colorWhite+\"   |      |   |           |          |         \")
	logo.push(\"  |       \"+CT+colorWhite+\"   |      |   |           |          |         \")
	logo.push(\"  |____   \"+CT+colorWhite+\"   | _____|   |--------   |          |         \")
	logo.push(\"       |  \"+CT+colorWhite+\"   |      |   |           |          |         \")
	logo.push(\"       |  \"+CT+colorWhite+\"   |      |   |           |          |         \")
	logo.push(\" |     |  \"+CT+colorWhite+\"   |      |   |           |          |         \")
	logo.push(\" \\ ____|  \"+CT+colorWhite+\"   |      |   \\--------    \\_______   \\_______ \"+char(8482))
	for l in logo
		print(colorRed+l+CT)
	end for
	print(\"by Plu70 aka jhook, aka ra'al\")
	print(\"special thanks to: KuRouZu\")
	print(\"MuninCipher by:\"+colorWhite+\" Plu70, CypherRaven\"+CT)
	print(\"CheckUser function by: \"+colorWhite+\"Corvus\"+CT)
	print(\"Blackjack card art by: \"+colorWhite+\"3nigma\"+CT)
	print(\"Pwgen by : \"+colorWhite+\" UsesPython, additions by Plu70 \"+CT)
	print(\"Glosure by: \"+colorWhite+\"rocketorbit\")
	print(\"Htop by: \"+colorWhite+\"redit0\")
	print(\"Additional code contributions by: Clover, redit0, muhahahahe, rocketorbit\")
	print(\"Github Readme by: \"+colorWhite+\"Hikaru918\")
	print(\"5hell Discord by: \"+colorWhite+\"Redit0\")
	print(\"5hell.src optimizations by: \"+colorWhite+\"Clover\")
	print(\"beta testing by: \"+colorWhite+\"CypherRaven, Deckard, KotyKD, Silent, Wulf, Amanda, Sabranan \")
	print(\"Inspiration from: \"+char(10)+colorWhite+\"AweTux, Kirin, Rasputin, CypherRaven, 3nigma, muhahahahe, Sl3ekr, bakeneko, GSQ, blujoker, Lady, KotyKD, Corvus, Amanda, DHZA, Silent, Conner, STYX, Fear_Rua, Penelope, Andreno, Minidevil96, tyy, Sabranan, MrMember, Clover, Rocketorbit, Trashed, Bit, OmegaKawaii, Hikaru918, Xagic, Omega, Redit0, Eclipse00, Jessa, Forteyn, Nyx \"+char(10)+\"and many others!\")
	return 0
end function
command.quit = function(state=1, arg2=0, arg3=0, arg4=0) // NOT reboot command, rather ends script
	if state == \"help\" or state == \"-h\" then return \"<u>QUIT || EXIT || RETURN</u>\"+char(10)+\"Usage: quit [opt:state] -- exits the program.\"+char(10)+\"-- if no optional state then prompts before exit\"+char(10)+\"-- if state supplied then skips confirmation and exits with state\"+char(10)+\"Usage:<b> exit [opt:state]</b> -- also exits the program with optional state\"+char(10)+\"Usage: return -- used to return from glasspool. Will exit 5hell if glasspool is inactive.\"
	did = false
	if params and params[0] == \"do\" then did = true
	if not state or did then 
		if not state then 
			if user_input(\"Exit \"+colorRed+\"5hell\"+char(8482)+CT+\"? [y/N]\"+char(10)+\"||: \",0,1).lower != \"y\" then return \"aborting shutdown...\"
		end if
	end if
	exit(state)
end function
command.help = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == \"help\" or arg1 == \"-h\" then return \"helping...\"
	if arg1 == \"shell\" then return (colorRed+instance.name+CT+\" v \"+ver+\" by Plu70\"+char(10)+\"(type<b> shell </b> for more info.)\")
	if arg1 == \"guide\" then
		print(colorGold+\"<u>= = = = = = = = = = = = = =</u>\"+CT)
		print(\"Quick start guide: (5hell command line: |> )\")
		print(colorGold+\"probe [ip]\"+CT+\" -- perform a whois and portscan on target ip. Sets target IP in 5phinx/sphinx.\")
		print(colorGold+\"sphinx\"+CT+\" -- bring up pentest tool with target already set.\"+char(10)+
		\"-- Press [0] to view portmap, [4] to change target ip, [5] to set target port.\")
		print(\"Use arrow keys to access other 5phinx menus.\")
		print(\"in sphinx \"+colorGold+\"press [=]\"+CT+\" -- connect metalib and get net_session (or load local lib)\")
		print(\"in sphinx \"+colorGold+\"press [3]\"+CT+\" -- if target lib is unknown (scan/add to dbase)\")
		print(\"in sphinx \"+colorGold+\"press [a] or [2]\"+CT+\" -- single attack or attack with all. results are stored in the BUFFER.\")
		print(\"access \"+colorGold+\"malp\"+CT+\" -- memory alpha, (left arrow from sphinx or malp from |> )\")
		print(\"in malp \"+colorGold+\"press [5]\"+CT+\" for BUFFER objects.\")
		print(\"the BUFFER in <b>malp</b> is where you will interact with most objects.\")
		print(\"use \"+colorGold+\" scpm \"+CT+\"command from |> or select a shell in BUFFER and press [7] scp to upload rkit \")
		print(\"do this<u> before </u>activating glasspool for best results.\")
		print(\"use \"+colorGold+\"felix\"+CT+\" -- file explorer to send files/folders to BUFFER\")
		print(\"all other commands are utility. explore them!\")
		print(colorGold+\"glasspool is shell/computer mirroring. some commands may change when this is active. \"+CT+char(10)+
		\"N.B. when active you are on the other side of the mirror looking back.\")
		print(colorGold+\"*--*\"+CT)
		print(\"<b>/root/rkit</b> is the default location of the rootkit which should consist of:\"+char(10)+
		\"<b>   5hell, crypto.so, metaxploit.so, database.csv </b>\"+char(10)+\"Additionally it may contain: \"+char(10)+
		\"   dig.bat, ScanLan.exe, and other tools/libs you find useful.\")
		print(\"In most cases you may type<b> kore -r</b> to have the rkit built for you.\"+char(10)+
			\"kore will look for 5hell in /bin, and meta and crypto in /lib.\"+char(10)+
				\"Add these files manually if kore is unable to do so.\")
		print(\"For scripting see:<b> do -h</b>\"+char(10)+
		\"For dictionary attacks see:<b> cerebrum -h, brutus -h, gopher -h, hashim -h</b>\")
		print(\"For networking see:<b> air -h, iwlist -h, ifconfig -h, ssh -h, kraken -h</b>\")
		print(\"For security see:<b> perms -h, usr -h, grp -h, sniff -h, silentclean -h, bios -h\")
		print(\"For dev tools see:<b> scribus -h, makfit -h, clipb -h, make -h, chop -h, dfit -h </b>\")
		print(colorGold+\"*--*\"+CT)
		return 0
	end if

	help_conventions = \"<b>CONVENTIONS</b>\"+char(10)+\"While a great deal of 5hell is discordant, there are some conventions:\"+char(10)+char(10)+
	\"You may toggle the full prompt and minimal promt by typing: \"+char(10)+
	\"<b>prompt</b> at the command line\"+char(10)+
	\"- - - - - - - - - - \"+char(10)+
	colorWhite+\"Input: arguments and quote blocks and piping oh my!\"+char(10)+
	\"-- 5hell uses a 4 argument system. This means all commands take at most 4 arguments\"+char(10)+
	\"-- this might sound limiting but it isn't at all in practice. Each of the 4 arguments may be overloaded.\"+char(10)+
	\"Some input methods are:\"+char(10)+
	colorLightBlue+\"----* simply typing input: |> ping 1.1.1.1\"+char(10)+
	\"------ up to four typed arguments\"+char(10)+
	\"------ remember that |> is the prompt, you don't type that part\"+char(10)+
	colorLightBlue+\"----* using single quotes to wrap text: |> echo \"\" this is a text block \"\" \"+char(10)+
	\"------ would return: this is a text block\"+char(10)+
	\"------ note that: |> echo \"\"this is a text block\"\" \"+char(10)+
	\"------ would return: \"\"\"\"this is a text \"+char(10)+
	\"------ this allows you to overload each argument with more than one \"\"word\"\"\"+char(10)+
	\"------ easy clip and piping and objects(mostly) are preserved inside of text blocks\"+char(10)+
	\"------ <b>you may escape a floating quote with <b>\\\"\"\"+char(10)+
	\"--------eg: macro set foo \"\" echo \\\"\" bar none \\\"\" \"\"\"+char(10)+
	colorLightBlue+\"----* use <color=yellow>do</b></color> to run a batch of commands from a file or from memory using an editor\"+char(10)+
	\"------ |> do -- without arguments do will prompt for number of iterations then open the editor\"+char(10)+
	\"------ |> do 1 -- would bring up an editor commands typed here will be executed in order\"+char(10)+
	\"------ |> do 1 ping 1.1.1.1 -- would result in pinging 1.1.1.1 once\"+char(10)+
	\"------ |> do 5 \"\" rnip 1 | dig \"\" -- would run dig on a random ip 5 times\"+char(10)+
	\"------ |> do 1 -f /foo.bar -- execute the batch of commands in the file foo.bar\"+char(10)+
	\"-------- you may launch 5hell from the game's command line with <b>do</b> parameters\"+char(10)+
	\"-------- the format is the same as if typing commands on the command line\"+char(10)+
	\"-------- newlines in the script are considered to be new command line entries\"+char(10)+
	\"-------- you may use piping, easy clip, and even calls for <b>do</b> to execute further scripts\"+char(10)+
	\"-------- you may use text blocks for complex commands in place of files or the editor\"+char(10)+
	\"--eg:  |> do 3 \"\" rnip 1 | dig |  | cob get metx | meta -i | db -m | zap \"\" | poke test.txt \"\" this is a bunch of text going into a file \"\"\"+char(10)+
	colorGold+\"** it is possible to almost completely automate every aspect of 5hell via <u>do</u> and <u>dig</u>\"+char(10)+
	\"------ for ease of use <b><color=white>do 1 -f</b></color> has been aliased to <color=white><b>bat</b></color> in 5hell.src:\"+char(10)+
	\"-------- |> <b>bat /foo.bar</b> is equivalent to |> <b>do 1 -f foo.bar</b>\"+char(10)+
	\"------ please see <u><b><color=yellow>do -h</b> and <b>dig -h</b></u></color> for more information on automation\"+char(10)+
	colorLightBlue+\"----* piping input: |> grep -f ^syst | file -p | cp /etc/passwd\"+char(10)+
	\"------ would result in copying /etc/passwd over top of system.log (if permissions allowed it)\"+char(10)+
	\"------ piping allows you to transfer the output of one command to the innput another command\"+char(10)+
	\"------ in the above example the output of grep [args...] is the input of file -p [input]\"+char(10)+
	\"------ and the output of file -p [args] is the input of cp /etc/passwd [input]\"+char(10)+
	\"------ please see <b>pipe -h</b> for more\"+char(10)+
	\"------ if malp is the backbone of 5hell, pipes are the circulatory system of 5hell\"+char(10)+char(10)+
	colorWhite+\"Prompts: \"+CT+\"|> , :> , ||: \"+char(10)+
	\"<color=#FFFFFF>|>  --  this is the standard Command Line Interface prompt\"+char(10)+
	\"-- by default there will be information printed before this\"+char(10)+
	\"-- toggle to a minimalist prompt with: <b>prompt</b>\"+char(10)+
	\"-- fires CLI commands\"+char(10)+
	colorLightBlue+\"|> \"+CT+\"  --  by default, the GLASSPOOL prompt turns the |> blue\"+char(10)+
	\"-- this means commands execute on the remote object controlled by glasspool\"+char(10)+
	\"-- see glasspool -h for more\"+char(10)+
	colorWhite+\":>  \"+CT+\" --  this is a liminal prompt, it expects a string or empty return\"+char(10)+
	\"-- this is used to gather user input within a command\"+char(10)+
	colorWhite+\"||: \"+CT+\" --  this is an 'any key' prompt\"+char(10)+
	\"-- it takes a single keypress\"+char(10)+
	\"-- this is used in 'button' driven menus\"+char(10)+char(10)+
	colorWhite+\"Decision Pompts: \"+CT+\"[ N/Y/X ] [n/y/x]\"+char(10)+
	\"-- Multiple choice prompts have a default\"+char(10)+
	\"-- the default is always Capitolized and sometimes highlighted\"+char(10)+
	\"-- the default is chosen if <enter> is pressed without input\"+char(10)+
	\"-- unless otherwise noted, default is chosen if input doesn't match a choice\"+char(10)+
	\"E.G: |> psudo\"+char(10)+
	\"Open shell? [c/y/N]\"+char(10)+
	\"||:\"+char(10)+
	\"-- in this example, the choices are [c], [y], and [N]\"+char(10)+
	\"---- [c] -- enter credentials\"+char(10)+
	\"---- [y] -- open shell\"+char(10)+
	\"---- [n] or anything else -- no; return/abort\"+char(10)+
	\"------ this is because N is the default\"+char(10)+char(10)+
	colorWhite+\"Prompt: advanced:\"+char(10)+
	\"-- by default the prompt will display the public and local ip of the active shell\"+char(10)+
	\"---- or computer if using glasspool on a computer object\"+char(10)+
	\"-- by default the prompt will display computer name and working directory\"+char(10)+
	\"-- by default the prompt indicates user privileges (root,user,guest) with:\"+char(10)+
	\"---- under the ip information there will be a:\"+char(10)+
	\"------ a<color=red> red line for root</color>, <color=green>green line for user </color>, </color>and <color=white>white line for guest\"+char(10)+
	\"---- please note that user permissions are determined by access level\"+char(10)+
	\"---- in some cases, this might not be the actual user\"+char(10)+
	\"-- you may customize the prompt to your liking in 5hell.src\"+char(10)

	help_tools = \"<u><b>Main tools:\"+char(10)+
	colorCyan+\"probe \"+colorWhite+\"-- whois and portmap a target\"+char(10)+
	colorCyan+\"db \"+colorWhite+\"-- scan target and <b>database results</b>\"+char(10)+
	colorCyan+\"meta \"+colorWhite+\"-- metaLib and metaxploitLib fine control\"+char(10)+
	colorCyan+\"zap \"+colorWhite+\"-- select and fire exploits one at a time (does not database)\"+char(10)+
	colorCyan+\"roil \"+colorWhite+\"-- fire all exploits at once (does not database)\"+char(10)+
	colorCyan+\"malp \"+colorWhite+\"-- Memory Alpha: BUFFER management\"+char(10)+
	\"-- exploit results and other objects go here\"+char(10)+
	\"-- this is arguably the backbone of 5hell\"+char(10)+
	colorCyan+\"scpm \"+colorWhite+\"-- menu and/or cli driven scp\"+char(10)+
	colorCyan+\"kraken \"+colorWhite+\"-- proxy management\"+char(10)+
	colorCyan+\"scribus \"+colorWhite+\"-- simple text editor\"+char(10)+
	colorCyan+\"cerebrum \"+colorWhite+\"-- add 325k+ passwords to custom_object.dictionary\"+char(10)+
	colorCyan+\"brutus \"+colorWhite+\"-- use custom_object.dictionary to get root on any (unmodified) npc machine\"+char(10)+
	colorCyan+\"See: [command] [-h|help] for more help on these and other commands\"+char(10)

	help_buffer = colorOrange+\"The BUFFER\"+char(10)+
	colorOrange+\"</b>The BUFFER stores objects. Anything may be stored in the BUFFER.\"+char(10)+
	colorOrange+\"You access the BUFFER with the <b>malp</b> command >> option [5]\"+char(10)+
	colorOrange+\"</b>When an exploit is run, the result is stored in the BUFFER. You\"+char(10)+
	colorOrange+\"</b>may interact with these objects in a number of ways by selecting them\"+char(10)+
	colorOrange+\"</b>from the list and using their context menu (if the object has one).\"+char(10)+
	colorOrange+\"</b>One way to fetch an object from the BUFFER for use elswhere is to use the clipboard:\"+char(10)+
	colorOrange+\"</b>|> \"+colorGreen+\"clipb @B [index|-m]</color>\"+colorOrange+\"</b>-- where index == BUFFER[index]\"+char(10)+
	colorOrange+\"</b>-- then pipe the value to another function\"+char(10)+
	colorOrange+\"</b>Easy Clip! As of version 3.9.6 any command may take <b>@B [index|-m] as one or more parameters!\"+char(10)+
	colorOrange+\"</b>-- if -m is passed instead of an index, a menu is displayed\"+char(10)+
	colorOrange+\"</b>|> roil | scpm /root/rkit @B -m\"+char(10)+
	colorOrange+\"You may pipe anything into the buffer with |><b> [command_returning_input] | malp</b>\"+char(10)+char(10)+
	colorGreen+\"Easy Clip! You may reference the clipboards with the @ symbol:\"+char(10)+
	colorGreen+\"***  clipa, clipb, and clipc are all clipboard spaces  ***\"+char(10)+
	colorGreen+\"</b>You may use @a, @b, and @c to reference their values\"+char(10)+
	colorGreen+\"</b>e.g. echo hello world | clipa |  | poke hello.txt @a\"+char(10)+
	colorGreen+\"*** tbuf, home, do ***\"+char(10)+
	colorGreen+\"</b>e.g. <b>gopher @tbuf</b>, e.g. <b>rshell @home</b>, e.g <b>scribus @do\"+char(10)+char(10)+
	colorCyan+\"</b>The CUSTOM_OBJECT is a way for scripts to share information between\"+char(10)+
	colorCyan+\"</b>nested launches. This means you can launch 5hell with 5hell and pass objects back and forth.\"+char(10)+
	colorCyan+\"</b>You interact with the custom_object via the various <b>cob</b> commands\"+char(10)+
	colorCyan+\"</b>Namely: cob get and cob set.\"+char(10)+
	colorCyan+\"For ease of use: <color=white>cob get</color> and <color=white>cob set</color> have been aliased to:\"+char(10)+
	colorCyan+\"</b>-- <color=white>get</color> and <color=white>set</color> in 5hell.src\"+char(10)+
	colorCyan+\"</b>-- |> <b>cob set bob burger </b>is equivalent to |><b> set bob burger\"+char(10)+
	colorCyan+\"</b>-- |> <b>cob get bob</b> is quivalent to |><b> get bob\"+char(10)+
	colorCyan+\"</b>An example would be \"+colorGold+\"cerebrum</color> which loads the dictionary to the custom object.\"+char(10)+
	colorCyan+\"</b>-- When generated, the dictionary is loaded to the custom object under the key: <b>dictionary</b>.\"
	colorCyan+\"</b>-- Once loaded, you may <b>run</b> 5hell through nested launches and the dictionary will persist.\"+char(10)+
	colorCyan+\"</b>-- This also allows you to import/export metaLib's and metaxploitLib's between machines!\"+char(10)
	colorCyan+\"</b>-- Easy Clip! You may reference a value in the custom object by it's key with: <b>@o [key]</b>\"+char(10)+
	colorGold+\"</b>--eg:<b> set foo \"\" look out for that tree, \"\" | echo @o foo george </b>// look out for that tree, george\"+char(10)+
	colorCyan+\"</b>-- Please see cob -h for more informaiton\"

	help_logs = colorWhite+\"The dreaded \"+colorRed+\"System.log\"+char(10)+
	\"Actions that generate an entry in system.log: \"+char(10)+
	\"-- establishing a net_session on a server (not a router)\"+char(10)+
	\"-- connecting via Browser.exe to a server\"+char(10)+
	colorWhite+\"---- connection established on port ##\"+char(10)+
	\"-- obtaining a shell (server/router)\"+char(10)+
	colorWhite+\"---- shell obtained on port ##\"+char(10)+
	\"-- deleting a file\"+char(10)+
	colorWhite+\"---- file deleted [ip]\"+char(10)+
	\"-- routing a connection with:\"+char(10)+
	\"-- connect_service or file_explorer\"+char(10)+
	colorWhite+\"---- connection routed [ip]\"+char(10)+
	\"-- shell disconnect\"+char(10)+
	\"-- i.e. exiting from start_terminal\"+char(10)+
	colorWhite+\"---- connection closed [ip]\"+char(10)+char(10)+
	colorRed+\"Active Traces\"+CT+\" will start when <b>shell.start_terminal</b> is used\"+char(10)+
	\"on an npc machine with an active admin of sufficient knowledge and give-a-damn.\"+char(10)+
	\"Generally, if there is a root: dsession active, using start_terminal will trigger\"+char(10)+
	\"an active trace. Active traces are stopped by disconnecting (exiting) that terminal instance.\"+char(10)+char(10)+
	\"When using 5hell you should NOT ever open a terminal (on a target) unless you are doing an Academic or\"+char(10)+
	\"Police record mission. OR if you absolutely need to open the browser to edit firewall or port rules\"+char(10)+
	\"on a target. Otherwise, use <b>glasspool</b> and <b>run</b> to leverage shell object manipulation instead.\"+char(10)+char(10)+
	\"However! You <u>should</u> start_terminal on your end point attack proxy. In fact, do it twice:\"+char(10)+
	\"-- use <b>prox</b> to tunnel to your end point proxy then launch 5hell and type <b>psudo</b> and then select [y]\"+char(10)+
	\"-- this will start_terminal on top of your start_terminal, effectively looping your connection on that machine\"+char(10)+
	\"-- this will ensure your end point proxy's ip is left in logs, not your origin ip\"+char(10)+
	\"-- without this, you risk exposing ip's behind the proxy\"+char(10)+
	\"-- note: this means you'll have to 'exit' twice from that proxy to return home\"+char(10)+
	colorRed+\"Passive Traces\"+CT+\" can/will start when certain actions have been left unaddressed:\"+char(10)+
	\"- Deleting a file and not removing the log entry\"+char(10)+
	\"- Leaving a connection closed log without a corresponding connection established log\"+char(10)+
	\"- Leaving a shell connected log at all\"+char(10)+
	\"- I think connection routed logs trigger traces, too. Not sure though.\"+char(10)+char(10)+
	colorMagenta+\"We all leave logs, sometimes. To clean them up, here are a few methods:\"+char(10)+
	colorLightBlue+\"Silentclean \"+CT+\"-- local log corruption using a text file\"+char(10)+
	\"-- creates a file used to corrupt logs\"+char(10)+
	\"-- has nuke option (see: silentclean -h)\"+char(10)+
	colorCyan+\"Rclean \"+CT+\"-- remote (or local) log corruption using objects\"+char(10)+
	\"-- uses a file already on system to corrupt logs\"+char(10)+
	\"-- accepts and works on piped objects (see: rclean -h)\"+char(10)+
	colorGold+\"MV \"+char(10)+\"-- yep, just the <b>mv</b> command\"+char(10)+
	\"-- poke haha | mv haha /var/system.log\"+char(10)+
	colorOrange+\"Wiping the log with one of these methods using a reverse shell is best\"+char(10)+
	\"but not necessary. You may run silentclean, exit 5hell, exit the terminal, and you will not leave a disconnect log.\"+char(10)+
	\"-- be aware that taking any log-creating action after running sc, except exiting, may regenerate the log.\"+char(10)

	help_alias = \"<u><b>aliases || do script || shortcuts || macros || User Defined Behavior\"+char(10)+
	\"5hell can be very simple to use, or very, very complicated, depending on your goals.\"+char(10)+
	\"It isn't necessary to learn 100% of 5hell. Nor is it necessary to suffer through some of it's\"+char(10)+
	\"more complex chains of commands. You can define your own behavior in a number of ways:\"+char(10)+char(10)+
	colorLightBlue+\"Aliases: \"+char(10)+
	colorWhite+\" You may define aliases in the aliases section of 5hell.src\"+char(10)+
	colorWhite+\"the default ones supplied are all prompt replacements. There are also 'easy clip' defenitions\"+char(10)+
	colorWhite+\"that replace arguments in the user input with, for instance, the contents of a clipboard or\"+char(10)+
	colorWhite+\"your @home server ip. These hard coded aliases may be more complicated than a simple\"+char(10)+
	colorWhite+\"word or string replacement. You may, for instance, have a simple two word alias fire\"+char(10)+
	colorWhite+\"a whole series of commands. This might be considered a macro at that point, but also\"+char(10)+
	colorWhite+\"might not quite qualify.\"+char(10)+char(10)+
	\"Here is a list of the currently defined default aliases in 5hell.src:\"+char(10)+
	colorLightBlue+\"Alias           | Definition\"+char(10)+
	colorCyan+\"bat [path]      |</b> do 1 -f [path]\"+char(10)+
	colorCyan+\"set [key] [val] |</b> cob set [key] [val]\"+char(10)+
	colorCyan+\"get [key]       |</b> cob get [key]\"+char(10)+
	colorCyan+\"lock            |</b> perms lock all\"+char(10)+
	colorCyan+\"exit            |</b> quit\"+char(10)+
	colorCyan+\"sc [opt]        |</b> silentclean [opt]\"+char(10)+
	colorCyan+\"gp [#]          |</b> glasspool [#]\"+char(10)+
	colorCyan+\"prompt          |</b> -this will toggle the full_prompt on/off-\"+char(10)+char(10)+
	colorWhite+\"Easy Clip       |</b> Replacement\"+char(10)+
	colorGold+\"@a              |</b> clipa -- globals.clip_board_alpha\"+char(10)+
	colorGold+\"@b              |</b> clipb -- globals.clip_board_beta\"+char(10)+
	colorGold+\"@c              |</b> clipc -- globals.clip_board_gamma\"+char(10)+
	colorGold+\"@tbuf           |</b> transmission buffer -- globals.T_BUF\"+char(10)+
	\"-- this is                |</b> where hashes go when the tree command finds them\"+char(10)+
	colorGold+\"@t              |</b> targetIP\"+char(10)+
	colorGold+\"@p              |</b> targetPort\"+char(10)+             
	colorGold+\"@home           |</b> HOME_SERVER ip address defined in 5hell.src\"+char(10)+char(10)+
	colorGold+\"@B [index|-m]   |</b> directly reference a value in the\"+colorOrange+\" BUFFER \"+CT+\"by [index] or menu: [-m]\"+char(10)+
	colorGold+\"@o [key]        |</b> directly reference a value in the custom object by key\"+char(10)+
	colorWhite+\"All <b>@</b> aliases (known as ez_clips) may be escaped with the <b>\\</b> character:\"+char(10)+
	\"--eg: <b>\\@a</b>, \\@home\"+char(10)+
	\"--eg: <b>clipb bob | echo @a -- will echo 'bob', while <b>clipa bob | echo \\@a -- will echo '@a' \"+char(10)+
	\"Please note: several commands have their own references for editing the clipboards\"+char(10)+
	\"-- these commands will use @clipa, @clipb, @clipc instead of @a, @b, @c\"+char(10)+
	\"Further, the clipa, clipb, and clipc will use @B to reference the BUFFER:\"+char(10)+
	\"-- e.g: |> <b>clipa @B 1</b> -- copy the object at index 1 in the BUFFER to clipa\"+char(10)+
	\"---- that object may then be used by other commands that accept piped objects as input\"+char(10)+
	\"-- as of 3.9.6 any command may use @B [index] as any parameter(s)\"+char(10)+
	\"-- there are other ways to pipe objects around besides the clipboards, explore to learn more.\"+char(10)+
	char(10)+
	colorOlive+\"Marcos and Automation: \"+char(10)+
	colorWhite+\" </b>You may define custom macro's with the \"+colorOrange+\"</b>macro</color> command. A macro is a \"+char(10)+
	colorWhite+\"</b>runtime-defined set of instructions executed by a single command. Think of it as an alias that performs\"+char(10)+
	colorWhite+\"</b>commands for you. Additionally, you may execute batch commands either from a file or from memory. There are\"+char(10)+
	colorWhite+\"</b>a few differences between a <u>macro</u> and a <u>do script</u>.\"+char(10)+
	colorWhite+\"</b>Please see:  \"+colorLightBlue+\"</b>do -h, macro -h, and help automation for more information on this topic.\"+char(10)

	help_automation = \"<u><b>automation || macro || do script || batch file\"+char(10)+
	colorCyan+\"How to fully automate <color=red>5</color><color=white>hell</color>:\"+char(10)+
	colorWhite+\"</b> As mentioned in <b>help alias</b>, you may define custom macro's, or sets of commands\"+char(10)+
	colorWhite+\"</b>that <color=red>5hell</color> will execute automatically. The two commands involved are:\"+char(10)+
	colorOrange+\"--: </b>macro</color> and \"+colorOrange+\"</b>do\"+char(10)+
	colorWhite+\"</b>The two commands function similarly in that they execute the defined commands as \"+char(10)+
	colorWhite+\"</b>if they were typed by you. The list of commands, or 'script,' is formed the same \"+char(10)+
	colorWhite+\"</b>way for both commands. Therefore both commands may execute the same scripts. That is, \"+char(10)+
	colorWhite+\"</b>do may execute a macro, and macro may execute a do script. This way, don't have to \"+char(10)+
	colorWhite+\"</b>remember two different formats for these similar commands.\"+char(10)+
	colorWhite+\"</b>The specific behavior of each is as follows:\"+char(10)+
	colorOrange+\"DO: \"+char(10)+
	colorCyan+\"<b> Do is essentially a 'do while' loop that executes at least once. You specify the number \"+char(10)+
	colorCyan+\"</b>of loops with the first argument: <b>do [some integer]</b> \"+char(10)+
	colorCyan+\"</b>The <b>primary</b> way to use do is like a macro that you want repeated on a loop.\"+char(10)+
	colorCyan+\"</b>If there are no more arguments after the number, an editor will open (scribus) where you may\"+char(10)+
	colorCyan+\"</b>type out the commands you want executed line by line. Lines may be complex lines, that is, \"+char(10)+
	colorCyan+\"</b>the lines may include piping. The output of a line will <b>not</b> be passed to the following \"+char(10)+
	colorCyan+\"</b>line. This way, you may type out commands without using the <b>|  |</b> trick. Once \"+char(10)+
	colorCyan+\"</b>you type <b>@</b> on a new line, the script will begin executing. Use <b>@@</b> on a new line\"+char(10)+
	colorCyan+\"</b>to abort execution. Additionally, you may use<b> scribus @do</b> to edit the buffer without executing.\"+char(10)+
	colorCyan+\"</b>You may then fire it later with<b> do [#]</b> and then <b>@</b>.\"+char(10)+
	colorLightBlue+\"An example do script, either written in the editor or read from a file* (*explained in the third usage): \"+char(10)+
	colorGold+\"</b>ifconfig -p | probe\"+char(10)+
	colorGold+\"</b>brutus | clipb\"+char(10)+
	colorGold+\"</b>grep -p 5hell | clipc\"+char(10)+
	colorGold+\"</b>run @c \"\" do 1 rshell @home \"\" @b\"+char(10)+
	colorGold+\"</b>rclean @b/b>\"+char(10)+
	colorLightBlue+\"</b>This would result in a network probe, an escalation, a root rshell placement, and \"+char(10)+
	colorLightBlue+\"</b>finally a log scrub. This is useful to run each time you attack a new target and \"+char(10)+
	colorCyan+\"</b>is also included as the default <b>dig.bat</b>.\"+char(10)+
	char(10)+
	colorCyan+\"</b>The <b>Second</b> way to use do is to define the commands on a single line, wrapped by floating quotes. \"+char(10)+
	colorLightBlue+\"</bThis would look like:<b> do 5 \"\" rnip 1 | ping 1.1.1.1 \"\"\"+char(10)+
	colorLightBlue+\"</bThis results in pinging 1.1.1.1 five times. More complex commands may be further chained by piping. \"+char(10)+
	colorLightBlue+\"</b>Be sure to wrap the commands you wish to <b>do</b> in quotes* that do not touch anything \"+char(10)+
	colorLightBlue+\"</b>(ie, floating) as shown above.\"+char(10)+
	colorLightBlue+\"<b>* If the command string is only two words, quotes are not needed. eg: do 1 ping 1.1.1.1\"+char(10)+
	char(10)+
	colorCyan+\"The <b>Third</b> way to use do is to read defined commands from a file.\"+char(10)+
	colorLightBlue+\"</b>The commands in the (text) file are written exactly as they are when using the editor to list commands.\"+char(10)+
	colorLightBlue+\"</b>These commands are executed with:<b> do [#] -f [pathToFile]\"+char(10)+
	colorLightBlue+\"</b>For your convenience, the alias \"+colorGold+\"</b>bat [path]</color> will be relaced by <b>do 1 -f [path]\"+char(10)+
	colorLightBlue+\"</b>This is most useful when launching 5hell with a set of instructions. If you launch 5hell from the command \"+char(10)+
	colorLightBlue+\"</b>line with: <b>5hell do 1 -f [path] </b>5hell will automatically execute the commands in the file and then exit.\"+char(10)+
	colorLightBlue+\"</b>If you do not wish 5hell to exit after completion, use a file named <b>do.rc</b> in your home_dir/Config or\"+char(10)+
	colorLightBlue+\"</b>in rkit (executes only if ~/Config/do.rc does not exist). Note that <b>do</b> does not return a value other than\"+char(10)+
	colorLightBlue+\"</b>it's completion time. Macros, however, do return the final value. Additionally, the <b>dig</b> command makes\"+char(10)+
	colorLightBlue+\"</b>use of the <b>do</b> engine when executing <b>dig.bat</b> (which itself, may reference other do scripts). \"+char(10)+
	colorLightBlue+\"</b>This allows 5hell to be fully automated throughout an arbitrary number of attacks. Cool stuff, right!?\"+char(10)+
	char(10)+
	colorGold+\"Macro:\"+char(10)+
	colorWhite+\"</b>A macro is similar to a do script, except it is intended to be written 'on the fly.' In other words, you type \"+char(10)+
	colorWhite+\"</b>the macro definition on the command line, without the editor, in most cases. If you do wish to use the editor, \"+char(10)+
	colorWhite+\"</b>simply use: <b>scribus @clipa/b/c | macro [macro_name]\"+char(10)+
	colorWhite+\"</b>Marco's are stored in the custom object and are executed when called by name: <b>macro [name]\"+char(10)+
	colorWhite+\"</b>A macro <b>will</b> return it's final value and will not print execution time. There is no built in option \"+char(10)+
	colorWhite+\"</b>to read a macro from a file, but <b>cat [file] | macro [name]</b> may be used to achieve this.\"+char(10)+
	colorWhite+\"</b>An example macro definition:\"+char(10)+
	colorWhite+\"macro prop \"\" cp 5hell /bin | cp /bin/5hell rkit | kraken /bin/5hell | kraken rkit/5hell \"\"\"+char(10)+
	colorWhite+\"</b>Again, it looks exactly the same as an inline do script, because it is! However, this script is stored \"+char(10)+
	colorWhite+\"</b>in the custom object, </b>meaning it may be retrieved with <b>get [name]</b> and piped somewhere,\"+char(10)+
	colorWhite+\"</b>such as to a file. You may absolutely fire a macro with <b>do</b>. Simply type: <b>do [#] @o [macroName]</b>\"+char(10)+
	colorWhite+\"</b>and do will happily execute the macro. Likewise, as mentioned earlier, piping the </b>contents of a \"+char(10)+
	colorWhite+\"</b>do script to macro will define the macro as that do script.\"+char(10)+
	char(10)+
	\"This all may seem complicated, but it is actually rather simple: \"+char(10)+
	\"--define a list of commands as if you were typing them, fire the batch of commands.\"+char(10)+
	\"For more information, please see: <b>do -h, macro -h, dig -h</b>, help alias, and help conventions.\"+char(10)+
	\"Also, visit the 5hell discord for example scripts!\"

	help_daemon = colorWhite+colorRed+\"</b>5</color>hell has a handful daemon commands: htop, hashim, outmon, and rsi.\"+char(10)+
	colorWhite+\"Three of these commands; htop, hashim, and outmon, are controlled by a 'daemon controller.' \"+char(10)+
	colorWhite+\"This controller functions by creating a file named<b> 5hell.d</b> in your root directory and writes a\"+char(10)+
	colorWhite+\"line to that file that matches a daemon process that is running. When this line is removed from the file, or\"+char(10)+
	colorWhite+\"or the file itself is deleted, the daemon process will end. This allows you to start and stop daemons in 5hell\"+char(10)+
	colorWhite+\"without having to kill the whole script with ctrl+c. Note that rsi is not controlled by the daemon manager as it\"+char(10)+
	colorWhite+\"exits daemon mode when a reverse shell connects to it.\"+char(10)+
	\"See also: htop -h, hashim -h, outmon -h, rsi -h\"

	if arg1 == \"-s\" or arg1 == \"show\" or arg1 == \"search\" then
		c_buf = []
		h_buf = []
		for cmd in command.indexes.sort
			if cmd == \"shell\" or cmd == \"help\" or cmd == \"__isa\" or cmd == \"classID\" then continue
			h = @command[cmd]
			c_buf.push(colorWhite+cmd+CT)
			c_buf.push(h(\"help\"))
		end for
		c_buf.push(colorWhite+\"shell\"+char(10)+\"Usage: shell -- outputs instance_name, num_commands and dictionary_size.\")
		c_buf = c_buf+[help_buffer,help_conventions,help_logs,help_tools,help_alias]

		if arg2 then
			invoke_regex = false
			special_chars = [\"*\",\"^\",\"$\",\"#\"]
			for special in special_chars
				if arg2.indexOf(special) >= 0 then invoke_regex = true
			end for
			for c in c_buf
				found = false
				if not invoke_regex then 
					if c.indexOf(arg2) >= 0 then 
						found = true
					end if
				else
					for w in c.split(\" \")
						if globals.re.match(arg2.values, w.values) then 
							c = c.replace(w,colorRed+w+CT)
							found = true
						end if
					end for
				end if
				if found then h_buf.push( c.replace(arg2, colorRed+arg2+CT) +char(10)+ colorGold+\"<u>---</u>\"+ CT +char(10) )
				if DEBUG then print(h_buf[-1])
			end for
			return colorGold+\"<u>= = = = = = Help Search = = = = = =</u>\"+char(10)+colorLightBlue+\"Found: </b>\"+h_buf.len+\"<b> results.\"+CT+char(10)+h_buf.join(char(10))
		end if
		return c_buf.join(char(10))
	end if
	if arg1 == \"home\" then
		return \"  Convention: <b>@home</b> -- indicates a server you, the end user, have set up for 5hell\"+char(10)+
		\"services. Servers should be of type <b>SSH</b> and/or <b>RSHELL</b> and it is recommended to run:\"+char(10)+
		\"<b> pwgen | pwgen hash</b>\"+char(10)+
		\"on ssh servers running the <b>hashim daemon</b>. The @home server is used by:\"+char(10)+
		\"<b> cerebrum, brutus, linkdb, transmit, and rshell/rsi</b>\"+char(10)+
		\"For example: <b>rshell @home notAvirus</b> would create an rshell with ip set as your @home server.\"+char(10)+
		\"That server would be running the rshell_server used by the rsi command. An @home server may also run:\"+char(10)+
		\"<b> hashim, outmon, or other custom services</b>. Please contact Plu70 if you have questions about setting\"+char(10)+
		\"up these resources.\"+char(10)+
		\"Please edit the appropriate line in 5hell.src to setup @home by providing an ip address, port, password,\"+char(10)+
		\"and directory for the pass file. It is important that you secure 5hell with login authentication,\"+char(10)+
		\"either stock or your own, to prevent exposure of this information! \"
	end if
	
	if arg1 == \"alias\" then return help_alias
	if arg1 == \"-c\" or arg1 == \"conventions\" or arg1 == \"-p\" or arg1 == \"prompt\" then return help_conventions
	if arg1 == \"-t\" or arg1 == \"tools\" then return help_tools
	if arg1 == \"-b\" or arg1 == \"buffer\" then return help_buffer
	if arg1 == \"-l\" or arg1 == \"logs\" then return help_logs
	if arg1 == \"-a\" or arg1 == \"automation\" then return help_automation
	if arg1 == \"-d\" or arg1 == \"daemons\" or arg1 == \"daemon\" then return help_daemon

	index = command.indexes
	if index.indexOf(\"__isa\") != null then index.remove( index.indexOf(\"__isa\"))
	if index.indexOf(\"classID\") != null then index.remove( index.indexOf(\"classID\"))
	if arg1 != \"-i\" then
		index = index.sort
	end if

	num_commands = index.len
	columns = 7 // # commands per line
	if globals.DEBUG then print(\"commands: \"+num_commands+\" columns: \"+columns)
	rows = ceil(num_commands / columns)
	if globals.DEBUG then print(\"rows: \"+rows)
	buf = []
	count = 0
	for i in range(0,rows)
		buf.push(\"<color=#FFFFFFFF><b>\"+index[count:count+columns].join(\" \"))
		count = count + columns
	end for
	print(colorGold+\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\"+CT)
	print(format_columns(buf.join(char(10))).replace(\"sphinx\", \"<color=#FF0000FF>sphinx</color>\" ) )
	print
	print(\":><b> help</b> -- print this page: lists commands alphabetically\")
	print(\":><b> help guide</b> -- for a quick getting started guide\")
	//print(\":> help [-c|conventions] -- information about 5hell prompt conventions\")
	print(\":> help [-p|prompt|-c|conventions] -- information about 5hell prompt conventions\")
	print(\":> help [-t|tools] -- a short list of the main tools\")
	print(\":> help [-a|automation] -- print information about automating tasks\")
	print(\":> help [-d|daemon|daemons] -- information about daemon control\")
	print(\":> help [-A|alias] -- a list of the current default aliases in 5hell.src\")
	print(colorOrange+\":> help [-b|buffer] -- buffer, clipboard, and custom_object info\")
	print(\":> help [-l|logs] -- information regarding system.log\")
	print(\":> help [-s|show|search] -- for a full descriptive list of commands\")
	print(colorCyan+\":> help [-s|show|search] [word|string|regex] -- search all help info for pattern\"+char(10)+\"-- see grep -h for regex tokens\")
	print(\":> help [-i] -- list commands by command map index\")
	print(\":> help [home] -- information about the @home system\")
	print(\":> lock -- shortcut for perms lock all\")
	print(\":> prompt -- toggle full_prompt on and off\")
	print(colorCyan+\":> [command] [-h|help] -- for more information on a specific command.\"+char(10))
	return 0
end function"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction8" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Finally, copy [color=cyan]5hell.src[/color] to code editor"
fit_content = true

[node name="5hellCodeEdit" type="CodeEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 300)
layout_mode = 2
text = "// Current as of version 4.0.0
// 5hell.src by Plu70 aka ra'al aka jhook
// 5hell.src (the code below) is open source
// The contents of 5hell.5pk (formerly 5hell.so), however, are not open source.
// Actually it's all open source now*
// 5hell (either the .src, the .so, the .5pk, or the combined script known simply as 5hell)
// is available for a small 1337coin fee. After purchase 5hell may be used in whatever way
// the end user sees fit.
// 5hell.src may be altered in part or in whole by the end user but may ONLY
// be distributed in it's original form. 5hell.src or 5hell as a compiled binary
// that is distributed by a third party and altered MUST make the alteration known
// to the end user. Failure to disclose alterations with redistribution voids
// the license of use and may result in civil penalties. Alterations for personal
// use are, of course, encouraged. Enjoy responsibly.
//
// 5hell is now covered by the MIT license which superscedes the above license.
///////////////////////// INSTRUCTIONS /////////////////////////////////////////

// 5hell.src allows you to customize 5hell to your liking. You may add, remove,
// and even replace commands to, from, and within 5hell. Most users will only
// need to set a password in the SECURITY section below the command.shell function.
// You may delete the security section if you do not want to use a password with 5hell.
// Add imported code lines or your own functions as per the template below the
// command.shell function.
// Note: as of version 3.1.2 the plugin cobble.5pk is available. 
// This is accessed with the cob command. It allows manipulation
// of the new 'custom_object' wich is a shared memory_space for programs within nested launches
// Note: as of version 3.1.2 5hell may be loaded to the custom object.
// see MAP OPTION below and choose one option (default has already been chosen).
//
// //////////////MAP OPTION////////////////
// uncomment only ONE of the 'command =' lines. At least one must be selected.
// option {} == normal 5hell mode. default.
// option get_custom_object == load 5hell to custom object. EXPERIMENTAL!!!
// choose one below:
command = {} // default
//command = get_custom_object // experimental, use with cobble.5pk for best results.
//
//////////END MAP OPTION//////////////////
//
//////////////////// BEGIN @HOME CONFIGURATION!!!!/////////////////////////////////////////////
//-- skipping this configuration means you can't use the transmit command. up to you.
//// important: don't comment it out, just leave at default values if you aren't going to use it.
// edit the below line to include the credentials for your (ssh) hashim server. the transmit command will use this information to connect.
//globals.HOME_SERVER = [\"string: ip\", number: ssh_port, \"string: username\", \"string: password\", \"string: ssh | ftp\", \"string: /path/to/pass (default: /root/pass)\", \"string: /path/to/database.csv (default: /root/rkit/database.csv)\", \"string: /path/to/tables/t5 (default: /root/tables/t5)\", number:rshell_port]
globals.HOME_SERVER = [\"ip.add.rr.ess\", 22, \"root\", \"password\", \"ssh\", \"/root/pass\",\"/root/rkit/tables/t5\", 1222]
// you may set an ip without setting a password if you only want to use the @home alias to fetch the ip
// for example with: rshell @home
  // @home will be replaced with your ip, no password needed in this case
  // password is needed for advanced functions, such as with the transmit command
/////// ALWAYS USE A PASSWORD (SECURITY SECTION BELLOW command.shell) WHEN SETTING AN @HOME_SERVER PASSWORD!!!!! ////////////////////////////////
////// END @HOME CONFIGURATION//////////////////////////////////////////////////
//
//
/////////// IMPRT LINE /////////
//////////// change the below lines to the path where you placed 5hell.5pk //////
// Do not remove the comments in the next two lines, they are necessary for Greybel support
import_code(\"/root/src/5hell.5pk\") // no-emit;no-eval;
//include \"5hell.5pk\"
///////////// END IMPRT LINE /////////
// once built you may use the 'makfit' command to
// build with a smaller filesize. see makfit -h
// note: makfit works on a source, not a binary
// build it once to get access to makfit then
// use makfit to rebuild it with a smaller file size
//////////////////////////////////////////
//
// additional imports should go below main!
// security section is below main!!
// do not forget the security!!
//
////////////////////// END INSTRUCTIONS ////////////////////////////////////////
//
//
//
///////BEGIN MAIN ////////////////////
// only edit this part if you know what you are doing!!!!! ////
command.shell = function(input=null,mute=null)
  //print // an extra line before the prompt, if you want
  running = true
  full_prompt = 1
  while running
    print // an extra line before the prompt, if you want
    pipe = []  // pipe control, do not edit
    prompt = [] // prompt control, do not edit
    next = [] // pipe control, do not edit

    // ###############################################################################
    // ################ begin customizables one ################################################
    /////// begin prompt preparation
    bang = \"|> \" // YOUR PROMPT, edit to your liking /// updated to include get_name
    // see full_prompt section for an advanced prompt
    // below is a simple example
    // if full_prompt then bang = globals.checkUser(shell)+\"@\"+globals.localmachine.get_name+\":\"+globals.currentPath+\"|> \" // stock FULLPROMPT, edit to your liking
    // below is a more complicated example
    // behold the magnificent 5hell prompt! thanks to anonymous and anarchic geniuses whose contributions made this possible
    //////////////////// full prompt for better prompting //////////////////////
    if full_prompt then 
      angle = \"<color=#FF0000>\"+char(20057) 
      part1 = \"<b><rotate=180><voffset=.70em>\"
      if not globals.GLASSPOOL then part2 = \"</rotate></voffset><voffset=1em><size=75%><color=#E2DEDE>\" else part2 = \"</rotate></voffset><voffset=1em><size=75%><color=#2382FFFF>\"
      user_level = globals.checkUser(localmachine) 
      user_level_line = \"<color=#00FF00><u></color>\"
      if user_level == \"root\" then user_level_line = \"<color=#FF0000><u></color>\"
      if user_level == \"guest\" then user_level_line = \"<color=#FFFFFF><u></color>\"
      // info works best with about 31-32 characters
      info = \"[\"+localmachine.public_ip+\"@\"+localmachine.local_ip
      pspace = \"<cspace=-\"+(info.len * .75)+\"em>]</u>\"
      part3 = \"</size></voffset><cspace=-.25em>\"
      scadoosh = \"<color=#FFFFFFFF><b>|></b>\"
      user_guess = active_user
      if globals.GLASSPOOL then 
        scadoosh = \"<color=#2382FFFF>|></b>\"
        user_guess = globals.checkUser(localmachine)
      end if
      bang = part1 + angle + part2 + user_level_line + info + pspace + part3 + angle + \"<voffset=-.25em>\"+\"></b></cspace><color=#E2DEDE><size=75%>\"+user_guess+\"@\"+localmachine.get_name+\":\"+currentPath+\"</size>\"+scadoosh+\" \"
    end if
    ////////////////////////// end full_prompt ////////////////////
    // glasspool prompt, edit to your liking
    if globals.GLASSPOOL then bang = colorLightBlue+bang.trim+\"<color=#FFFFFF> \" 
    ////////// end prompt preperation

    // get user input unless command.shell was called internally (do, cc, glasspool...) // do not edit
    if input then prompt = input.split(\" \") else prompt = user_input(bang).replace(\" \\|\\| \",\" |  | \").split(\" \") //  using || instead of | will go to next command without piping
    // flow control, edit with care
    // add or remove comment characters to/from the string below
    if input and indexOf(\"|#-/\", input[0]) != null then // thanks clover!
      return 
    else 
      input = null
    end if
    if prompt[0] == \"|\" then continue // catch stray pipes in input prompt but not comment lines bc why would you type a comment into a one shot line? like for real?
    // end flow control

    // remove/comment this line if you dont want the command buffer
    globals.command_buffer.push(prompt.join(\" \").remove(\" | return\"))

    // #####################################################################
    // ####################### end customizables one ############################

    // process floating single quote input ie: \" i am a long parameter string \"
    if DEBUG then print \"pre single_quote_prompt\"
    if DEBUG then print prompt
    while prompt.indexOf(char(34)) != null
        s_string = prompt[:prompt.indexOf(char(34))]
        if DEBUG then print \"s_string: \"+s_string
        e_string = prompt[prompt.indexOf(char(34))+1:]
        if DEBUG then print \"e_string: \"+e_string
        if e_string.indexOf(char(34)) != null then 
            f_string = e_string[:e_string.indexOf(char(34))]
            if DEBUG then print \"f_string: \"+f_string
            f_string = f_string.join(char(32))
            z_string = e_string[e_string.indexOf(char(34))+1:]
            prompt = s_string+[f_string]+z_string
        else 
          break
        end if
    end while
    // end floating quote processing

     // process piping
    if DEBUG then print \"debug: pre_pipe prompt is: \"+prompt
    // begin pipe control, edit with extreme caution.
    if prompt.indexOf(\"|\") >= 0 then  
      prompt.push(\"|\")
      while prompt.len
        pipe.push(prompt[:prompt.indexOf(\"|\")])
        prompt = prompt[prompt.indexOf(\"|\")+1:]
      end while
    else
      pipe.push(prompt[0:])
    end if                           
    // end pipe control

    // process the pre_processed input
    while pipe.len > 0                  
      // begin command parsing
      prompt = pipe.pull // no touchy
      if next.len > 0 then prompt.push(next.pull) // no touchy

      // some folks like to edit the below line to do command.cc instead of continue
      if not prompt.len or prompt[0] == \"\" or prompt[0] == 0 or prompt[0] == \"0\" or prompt[0] == null then continue
      //
      if prompt[0] == \"return\" then 
        if not mute then print colorWhite+\"<size=50%><u><color=red>5</color>hell: returning...\"
        if prompt.len > 1 then 
          return prompt[1] 
        else 
          return 0 // might edit this to return a value instead
        end if
      end if
      //
      // ############################### begin customizables two ###########################
      // begin shortcuts
      // macro replacement; do this before all other aliases as macros may contain aliases
      if get_custom_object.macros.hasIndex(prompt[0]) then prompt = [\"macro\"]+prompt
      // end macro replacement
      if prompt[0] == \"bat\" and prompt.hasIndex(1) then prompt = [\"do\",\"1\",\"-f\"]+prompt[1:]
      if prompt[0] == \"set\" or prompt[0] == \"get\" then prompt = [\"cob\"]+prompt
      if prompt[0] == \"lock\" then prompt = \"perms lock all\".split(\" \") // use this shortcut for extra qol!!
      if prompt[0] == \"exit\" then prompt[0] = \"quit\"      // caution: too many shortcuts may slow down the script
      if prompt[0] == \"sc\" then prompt[0] = \"silentclean\"
      if prompt[0] == \"gp\" then prompt[0] = \"glasspool\"
      if prompt[0] == \"prompt\" then // toggle full_prompt on or off
          full_prompt = not full_prompt
          continue
      end if
      // end shortcuts
      // // begin easy clip
      prompt = globals._ez_clip(prompt) // _ez_clip is located in 5phinx.5pk
      // end easy clip
      // ############################ end customizables two ###############################

      // post_pre_processing
      prompt = prompt + ([0] * (5 - prompt.len)) // check this magic out sanity check #1
      prompt = prompt[:5] 
      // sanity check #2
      for pp in prompt 
        if pp == \"\" then prompt[__pp_idx] = 0
      end for

      // processing

      // you know what, there was a distinct lack of using guard clauses here
      // and i dont know if its for performance reasons but i think we
      // can sacrifice a little bit of performance for readability
      // (especially if its in this user facing code) - Clover

      cmdName = prompt[0]

      // handle case where prompt is \"shell\" actually
      if cmdName == \"shell\" then
        // if you'd like the 'shell' command to return additional info, do that here
        if prompt[1] == \"--debug\" then
          print \"shell: \" + (\"de\"*globals.DEBUG) + \"activating DEBUG mode\"
          globals.DEBUG = not globals.DEBUG
          continue
        end if
        if prompt[1] == \"--home\" then 
          if typeof(prompt[2]) == \"string\" and is_valid_ip(prompt[2]) then 
            print(\"shell: updating @home to: \"+prompt[2])
            globals.HOME_SERVER[0] = prompt[2] 
          else 
            print globals.HOME_SERVER[0]
          end if
          continue 
        end if
        print(colorRed+instance.name+char(8482)+CT+\" v \"+ver+\" by Plu70\")
        print(colorOlive+\"[HOME_SERVER: \"+colorWhite+globals.HOME_SERVER[0]+CT+\"] \")
        print(colorOlive+\"[COMMANDS   : \"+colorCyan+command.indexes.len+CT+\"] \")
        print(colorOlive+\"[PASSWORDS  : \"+colorGold+globals.dict_a.len+CT+\"] \")
        print(colorOlive+\"[PUBLIC_IP  : \"+colorWhite+shell.host_computer.public_ip+CT+\"]\")
        print(colorOlive+\"[LOCAL_IP   : \"+colorWhite+shell.host_computer.local_ip+CT+\"]\")
        print(colorOlive+\"[STACK_POOL : \"+colorRed+get_custom_object.stack_pool+CT+\"]\")
        state = \"in\"
        if globals.GLASSPOOL then state = \"\"
        gp = \" \" + state + \"active \"
        print(colorOlive+\"[\"+colorLightBlue+\"GLASSPOOL  \"+CT+\":\"+colorOrange+gp+CT+\"]\")
        print(\"<size=65%>--: use<b> shell --home [ip]</b> to change home_server\")
        print(\"<size=65%>--: use<b> shell --debug</b> to toggle debug mode\")
        continue 
      end if

      if not command.hasIndex(cmdName) then
        print(cmdName+\": unrecognized command (type <b>help</b> for command list)\")
        continue
      end if

      f = @command[cmdName]
      if typeof(@f) != \"function\" then // san check #3
        print(colorOrange+\"shell: use <b>cob get [element]</b> to retrieve element.\")
        continue
      end if

      catch = null
      // we need this for compatibility with improperly constructed functions
      if str(@f) == \"FUNCTION()\" then args = 0 else args = str(@f).split(\", \").len // get the number of args required by the function
      if DEBUG then print(\"target function takes: \"+args+\" arguments.\")
      if DEBUG then print(\"debug: preparing to fire: \"+char(10)+prompt)
      if args == 4 then
        catch = f(prompt[1], prompt[2], prompt[3], prompt[4])
      else if args == 3 then
        catch = f(prompt[1], prompt[2], prompt[3])
      else if args == 2 then
        catch = f(prompt[1], prompt[2])
      else if args == 1 then
        catch = f(prompt[1])
      else
        catch = f
      end if

      if DEBUG then///// begin 3.1.2 compatibility changes
        print(\"@catch: \"+typeof(@catch))  // attn! catch may now be a function!
        //if typeof(@catch) != \"function\" then print(\"catch:  \"+catch)
      end if

      // post processing
      if not @catch then continue
      if DEBUG then print \"debug: pipe.len: \"+pipe.len+\" next: \"+pipe ///////////// fix me for iffffffff
      if pipe.len > 0 and @pipe[0] == \"return\" then return @catch // added by me
      if not mute then print(@catch)
      if pipe.len > 0 then next.push(@catch) // using @reference instead of literal bc functions may now be passed
    end while         // end command parsing
  end while          // end main loop
end function
//////END MAIN//////
//
// 5hell uses the following color palette, changing these values will OVERWRITE the defaults:
// GLOBAL       DEFINITION
colorRed = \"<color=#FF0000FF>\"
colorGreen = \"<color=#00FF00FF>\"
colorOlive = \"<color=#048004FF>\"
colorWhite = \"<color=#FFFFFFFF>\"
colorCyan = \"<color=#00FFFFFF>\"
colorGold = \"<color=#CCCC00FF>\"
colorBlack = \"<color=#000000FF>\"
colorOrange = \"<color=#FF8400FF>\"
colorViolet = \"<color=#8821FDFF>\"
colorMagenta = \"<color=#FF00C8FF>\"
colorLightBlue = \"<color=#2382FFFF>\"
CT = \"</color></b>\"
//
// (reference the above for your own commands)
// (of course you can also add your own!)
// more globals in template.5pk.src
//
if DEBUG then print(\"<size=75%>loading customizations (if any)...</size>\")
////////////////// IMPORTS SECTION ////////////////////////////
/////// PASTE YOUR IMPORTED COMMANDS HERE!!  ////////
/////// BE SURE TO FOLLOW THE TEMPLATE BELOW! ///////
/////// feel free to reference internal functions and globals in your code! ///////
// e.g:
//
// command.my_func = function(arg1, arg2=0,arg3=0,arg4=0)
// if arg1 == \"help\" or arg1 == \"-h\" then return \"Usage: command -- info\"
//    // code and additional functions
//    return 0  // or return soemthing
// end function
//


/////////////////////////////////////////////////////////////////////////////////////////////
// or
//
// imp*cde ( \"/path/your.5pk\")   // where your.5pk contains your function in the above format
// *note the .5pk extension is just a convention and not a hard requirement.
//
//////////////////END IMPRTS SECTION ////////////////////////////
//
//
//////////////////////////////////// SECURITY GOES HERE //////////////////////
///// customize this line fully for the most security ////////
  access_codes = {\"Alpha\":\"your password here\", \"Beta\":\"your other password here if you want\"}//////////////////////////////////////////////////////////////
  // if you rename access_codes be sure to edit the below line
  rnac = access_codes.indexes
  rnac.shuffle
  rnac = rnac.pop
  if user_input(colorCyan+\"Cyberdeck Authentication Code [\"+colorWhite+rnac+colorCyan+\"]: \"+CT,1,0) != access_codes[rnac] then
    wait(300)
    exit(\"frag off, chumba\")
  end if
/////////////////END SECURITY///////////////////
// 
//
if DEBUG then print(\"<size=75%>loaded [\"+command.len+\"] commands...\")
if DEBUG then print(\"<size=75%>starting 5hell in debug mode...</size>\")
//BEGIN AUTOMATION SETUP//
///////////////BEGIN launch_with_do CONTROL /////////////////////////
/////////do not edit the below section (especially do not remove the | return !!)//////////
//// not kidding, it causes an infinite loop ////
// you have been warned! //
// Usage: 5hell do [#] [opt:-f] [opt: command | /path (if -f)] [opt:up_to_2_params (if not -f)]
// What is it: this allows you to launch 5hell with instructions. see \"do -h\" in 5hell for more info
// basically it calls the internal scripting service. this is obscenely powerful! for real, try it out.
// 5hell can be configured to write instructions for itself and launch itself with those instructions.
// just have to be creative. contact Plu70/jhook with -any- questions about how this works.
// e.g. 5hell do 100 ping 1.1.1.1
// e.g. 5hell do 1 -f myMacro.bat
// e.g. 5hell do 1
// (the last one will open the editor where you may type out a list of commands)
//
//
//////////////////////////set-pre-launch-conditions/////////////////////////////////////
if DEBUG then print(\"<size=75%>verifying stack_pool...\")
sp = globals.stack_pool
if DEBUG then print(\"<size=75%>stack_pool: [\"+sp+\"]\") 
if DEBUG then print(\"<color=yellow><size=75%>checking for do.rc...\")
// auto 'do' a batch file on startup
// unlike a standard 5hell do 1 -f /file launch, this will not result in an exit on completion
// only executes if 5hell.rc is located in a folder named rkit
dorc = globals._startup_resource_configuration
if DEBUG then print dorc
if DEBUG then print(\"<color=yellow><size=75%>exporting MetaxploitLib...\")
globals._export_metax // export our metaxploit on each startup
if DEBUG then print(\"<size=75%>checking for tables/tp\")
itp = globals._import_tables // import tables/tp if it exists
if DEBUG then print itp
print(colorRed+\"5hell\"+char(8482)+CT+\" v \"+ver+\" by Plu70\")
//////////////////END prelaunch-conditions///////////////////////////////////
//
/////BEGIN launch_with_do CONTROL///////////////////////////////
//
cmd = params.join(\" \") // start out as though we are not using do
// if 'do' then we exit when we are done
if params and params[0] == \"do\" then
  cmd = \"do\"
  if params.len >= 2 then cmd = cmd + \" \" + params[1]
  if params.len > 2 then 
    if params[2] == \"-f\" then 
      cmd = cmd + \" \"\" \" + \"do 1 -f \" + params[3:].join(\" \")
      print \"FROM FILE\"
    else 
      cmd = cmd + \" \"\" \" + params[2:].join(\" \")
      print \"FROM PARAMS\"
    end if
  end if
  command.quit(command.shell(cmd+\" \"\" | return\"))
end if
////////////////END l_w_d CONTROL/////////////////
//
///begin main///
while true
command.quit(command.shell(cmd))
end while
////end main////
//////////end of do not edit section//////////////
///EOF///"
editable = false
minimap_draw = true
gutters_draw_line_numbers = true

[node name="Instruction9" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "select a password or passwords in the security section of 5hell.src"
fit_content = true

[node name="LineEdit3" type="LineEdit" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
text = "access_codes = {\"Alpha\":\"your_access_code_here\", \"Beta\":\"your_other_access_code_here\"}"
editable = false

[node name="Instruction999" type="RichTextLabel" parent="TabContainer/5hell/ScrollContainer/VBoxContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Now, you may run 5hell by using command 5hell at the install directory or any where (if installed at [color=cyan]/bin/[/color])"
fit_content = true
