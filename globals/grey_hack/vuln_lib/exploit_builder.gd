class_name ExploitBuilder extends Resource

const ACTION_SHELL = "Get access to a shell."
const ACTION_CHG_PWD = "Take advantage of a vulnerability in the <color=#0FABFFFF>%s</color> service to inject a new password to a registered user."
const ACTION_FIREWALL_DISABLE = "Change all firewall entries to 'allowed'"
## Hack Result Random Path
const ACTION_OVERRIDE_SETTINGS = "Unlock the settings of the smart device."
const ACTION_TRAFFIC_LIGHT_CONTROL = "Inject code into an active traffic camera system to allow control of the traffic lights."
const ACTION_COMPUTER_DECIPHER_PASSWD = "Grant access to the file /etc/passwd and decipher its contents."
const ACTION_COMPUTER_DECIPHER_BANK = "Search all the Bank credentials files in the computer to decipher all passwords."
const ACTION_COMPUTER_DECIPHER_MAIL = "Search all the Mail credentials files in the computer to decipher all passwords."
const ACTION_FOLDER_CONTENTS = "Grant access to the path: <b>%s</b> and prints their contents."
const ACTION_FOLDER_ETC_PASSWD = "Prints the contents of the file /etc/passwd."
const ACTION_FOLDER_MAIL_PASSWD = "Prints the contents of the file /home/user/Mail.txt of all users in the computer."

const DECIPHER_DISCLAIMER = "It is neccessary to have the decipher program installed in the computer that launch the exploit."

const REMOTE_USE = "<b>Remote use.</b>"
const LOCAL_USE = "<b>For local use only.</b>"
const PERMISSION_OBTAINED = "<b>Permissions obtained:</b> %s"
const TARGET_LIBRARY = "<b>Target:</b> %s >= %s"

const REQUIRED = "<b>Required:</b>"
const PATH_EXISTS = " - %s exists in the file system"
const REQ_LOGIN = " - %s user logged in the computer."
const REQ_LIBRARY = " - Dependencies on library %s >= %s"
const MIN_USER = " - Minimum number of 1 user registered in the computer"
const MIN_USERS = " - Minimum number of %d users registered in the computer"
const MIN_PORT_FWD = " - 1 port forwarding configured from router to the target computer."
const MIN_PORTS_FWD = " - %d port forwarding configured from router to the target computer."
const MIN_GWY_CONN = " - 1 computers using this router as gateway."
const MIN_GWY_CONNS = " - %d computers using this router as gateway."

const BASE_SCRIPT_FILEPATH = "res://assets/grey_scripts/base_script.src"
const BASE_SCRIPT_REMOTE_FILEPATH = "res://assets/grey_scripts/base_script_remote.src"
const BASE_SCRIPT_ROUTER_FILEPATH = "res://assets/grey_scripts/base_script_router.src"
const BASE_SCRIPT_ROUTER_SHELL_FILEPATH = "res://assets/grey_scripts/base_script_router_shell.src"

const OVERFLOW_BASE_SCRIPT_FILEPATH = "res://assets/grey_scripts/overflow_base_script.src"
const CHANGE_PASS_FILEPATH = "res://assets/grey_scripts/change_pass.src"
const FOLDER_CONFIG_FILEPATH = "res://assets/grey_scripts/folder_config.src"
const SHELL_FILEPATH = "res://assets/grey_scripts/shell.src"

const COMPUTER_DECIPHER_BANK_FILEPATH = "res://assets/grey_scripts/computer_decipher_bank.src"
const COMPUTER_DECIPHER_MAIL_FILEPATH = "res://assets/grey_scripts/computer_decipher_mail.src"
const COMPUTER_DECIPHER_PASSWD_FILEPATH = "res://assets/grey_scripts/computer_decipher_passwd.src"
const FOLDER_CONTENT_FILEPATH = "res://assets/grey_scripts/folder_contents.src"
const FOLDER_ETC_PASSWD_FILEPATH = "res://assets/grey_scripts/folder_etc_passwd.src"
const FOLDER_MAIL_PASSWD_FILEPATH = "res://assets/grey_scripts/folder_mail_passwd.src"

const DEFAULT_PORT = {
	LibraryType.Type.LIB_SSH: 22,
	LibraryType.Type.LIB_FTP: 21,
	LibraryType.Type.LIB_HTTP: 80,
	LibraryType.Type.LIB_SMTP: 25,
	LibraryType.Type.LIB_CHAT: 6667,
	LibraryType.Type.LIB_CAM: 37777,
	LibraryType.Type.LIB_RSHELL: 1222,
	LibraryType.Type.LIB_REPOSITORY: 1542,
	LibraryType.Type.LIB_ADB: 5555,
	LibraryType.Type.LIB_SMART_APPLIANCE: 1883
}

enum ComputerHack {
	DECIPHER_PASSWD,
	DECIPHER_BANK,
	DECIPHER_MAIL
}

enum FolderHack {
	CONTENT,
	ETC_PASSWD,
	MAIL
}

static func build_exploit(library: Lib, zone: MemoryZone, vuln: Vulnerability,
	computer_hack: ComputerHack, folder_hack: FolderHack, new_password: String) -> String:
	var source_arr: PackedStringArray = []
	var instructions = _generate_instructions(library, vuln, computer_hack, folder_hack)
	source_arr.append("usages = []")
	source_arr.append_array(instructions.map(func(e): return "usages.push(\"%s\")" % e))
	var base_script = _generate_base_script(library, vuln)
	source_arr.append(base_script)
	source_arr.append(_generate_exploit_script(library, vuln, computer_hack, folder_hack))
	var source_code = "\n".join(source_arr)
	source_code = source_code.replace("<PATH_LIB>", "\"/lib/%s\"" % LibraryType.translate(library.id_lib))
	source_code = source_code.replace("<MEM_ZONE>", "\"%s\"" % zone.address)
	source_code = source_code.replace("<UNSEC_VALUE>", "\"%s\"" % vuln.unsec_value)
	if library.id_lib in DEFAULT_PORT:
		source_code = source_code.replace("<DEFAULT_PORT>", str(DEFAULT_PORT[library.id_lib]))
	else:
		source_code = source_code.replace("<opt:port><DEFAULT_PORT>", "[port]")
		source_code = source_code.replace("<DEFAULT_PORT>", "0")
	source_code = source_code.replace("<NEW_PASSWORD>", "\"%s\"" % new_password)
	return source_code

static func _generate_instructions(library: Lib, vuln: Vulnerability,
	computer_hack: int, folder_hack: int) -> Array[String]:
	var instructions: Array[String] = []
	# Action Description
	match vuln.helper_hack_result.hack_result:
		HackResultType.Type.SHELL: instructions.append(ACTION_SHELL)
		HackResultType.Type.CHANGE_PASS:
			var lib_name = LibraryType.translate(library.id_lib).replace("lib", "").replace(".so", "")
			instructions.append(ACTION_CHG_PWD % lib_name)
		HackResultType.Type.FIREWALL_DISABLE: instructions.append(ACTION_FIREWALL_DISABLE)
		HackResultType.Type.OVERRIDE_SETTINGS: instructions.append(ACTION_OVERRIDE_SETTINGS)
		HackResultType.Type.TRAFFIC_LIGHT_CONTROL: instructions.append(ACTION_TRAFFIC_LIGHT_CONTROL)
		HackResultType.Type.RANDOM_FOLDER:
			match folder_hack:
				0: instructions.append(ACTION_FOLDER_CONTENTS % vuln.helper_hack_result.random_path)
				1: instructions.append(ACTION_FOLDER_ETC_PASSWD)
				2: instructions.append(ACTION_FOLDER_MAIL_PASSWD)
		HackResultType.Type.COMPUTER: 
			match computer_hack:
				0: instructions.append(ACTION_COMPUTER_DECIPHER_PASSWD)
				1: instructions.append(ACTION_COMPUTER_DECIPHER_BANK)
				2: instructions.append(ACTION_COMPUTER_DECIPHER_MAIL)
			instructions.append("")
			instructions.append(DECIPHER_DISCLAIMER)
	# Use Scope: Remote / Local
	instructions.append(REMOTE_USE if vuln.is_remote else LOCAL_USE)
	instructions.append("")
	# Granted Permission: root, Non root user, guest
	var permission: String = "Non root user" if vuln.helper_hack_result.user == "normal_user" else vuln.helper_hack_result.user
	instructions.append(PERMISSION_OBTAINED % permission)
	# Target library
	var library_name = LibraryType.translate(library.id_lib)
	instructions.append(TARGET_LIBRARY % [library_name, library.version.version_str])
	instructions.append("")
	# Requirements
	if vuln.required_actions.size() > 0:
		instructions.append(REQUIRED)
		for action in vuln.required_actions:
			match action:
				HackRequiredType.Type.LIBRARY: instructions.append(REQ_LIBRARY % [LibraryType.translate(vuln.required_lib), vuln.req_lib_version])
				HackRequiredType.Type.PATH_EXIST: instructions.append(PATH_EXISTS % vuln.helper_hack_result.path_exist)
				HackRequiredType.Type.NUMBER_USERS_REGISTER: instructions.append(MIN_USER if vuln.helper_hack_result.num_register_users <= 1 else MIN_USERS % vuln.helper_hack_result.num_register_users)
				HackRequiredType.Type.PORT_FORWARD: instructions.append(MIN_PORT_FWD if vuln.helper_hack_result.num_port_forward <= 1 else MIN_PORTS_FWD % vuln.helper_hack_result.num_port_forward)
				HackRequiredType.Type.CONN_GATEWAY: instructions.append(MIN_GWY_CONN if vuln.helper_hack_result.num_conn_gateway <= 1 else MIN_GWY_CONNS % vuln.helper_hack_result.num_conn_gateway)
				HackRequiredType.Type.ROOT_ACTIVE_USER: instructions.append(REQ_LOGIN % "Root")
				HackRequiredType.Type.GUEST_ACTIVE_USER: instructions.append(REQ_LOGIN % "Guest")
				HackRequiredType.Type.ANY_ACTIVE_USER: instructions.append(REQ_LOGIN % "Any")
	return instructions

static func _generate_base_script(library: Lib, vuln: Vulnerability) -> String:
	var base_script_filepath = BASE_SCRIPT_FILEPATH
	if vuln.is_remote:
		base_script_filepath = BASE_SCRIPT_REMOTE_FILEPATH
		if library.id_lib == LibraryType.Type.KERNEL_ROUTER:
			if vuln.helper_hack_result.hack_result == HackResultType.Type.COMPUTER:
				base_script_filepath = BASE_SCRIPT_ROUTER_FILEPATH
			if vuln.helper_hack_result.hack_result in [
				HackResultType.Type.SHELL,
				HackResultType.Type.RANDOM_FOLDER,
				HackResultType.Type.FIREWALL_DISABLE]:
					base_script_filepath = BASE_SCRIPT_ROUTER_SHELL_FILEPATH
	return _open_file_content(base_script_filepath)

static func _generate_exploit_script(library: Lib, vuln: Vulnerability,
	computer_hack: int, folder_hack: int) -> String:
	var text = ""
	var hack_result = vuln.helper_hack_result.hack_result
	if (vuln.type_vulner == VulnerabilityType.Type.BUFFER_OVERFLOW):
		var flag = true
		if hack_result == HackResultType.Type.CHANGE_PASS:
			flag = false
		if flag and (not library.id_lib == LibraryType.Type.KERNEL_ROUTER or hack_result != HackResultType.Type.COMPUTER):
			# Which mean this exploit need something after overflow (it will keep result)
			text += _open_file_content(OVERFLOW_BASE_SCRIPT_FILEPATH)
			text += "\n"
	match hack_result:
		HackResultType.Type.SHELL:
			text += _open_file_content(SHELL_FILEPATH)
		HackResultType.Type.RANDOM_FOLDER:
			text += _open_file_content(FOLDER_CONFIG_FILEPATH)
			match folder_hack:
				FolderHack.CONTENT: text += _open_file_content(FOLDER_CONTENT_FILEPATH)
				FolderHack.ETC_PASSWD: text += _open_file_content(FOLDER_ETC_PASSWD_FILEPATH)
				FolderHack.MAIL: text += _open_file_content(FOLDER_MAIL_PASSWD_FILEPATH)
		HackResultType.Type.CHANGE_PASS:
			text += _open_file_content(CHANGE_PASS_FILEPATH)
		HackResultType.Type.COMPUTER:
			match computer_hack:
				ComputerHack.DECIPHER_PASSWD: text += _open_file_content(COMPUTER_DECIPHER_PASSWD_FILEPATH)
				ComputerHack.DECIPHER_BANK: text += _open_file_content(COMPUTER_DECIPHER_BANK_FILEPATH)
				ComputerHack.DECIPHER_MAIL: text += _open_file_content(COMPUTER_DECIPHER_MAIL_FILEPATH)
	return text

static func _open_file_content(file_path: String) -> String:
	var file = FileAccess.open(file_path, FileAccess.READ)
	return file.get_as_text(true)

static func get_suggested_script_name(vuln: Vulnerability, lib: Lib, selected_folder_hack: FolderHack, selected_computer_hack: ComputerHack) -> String:
	var hack_result_str: String
	match  vuln.helper_hack_result.hack_result:
		HackResultType.Type.RANDOM_FOLDER:
			match selected_folder_hack:
				0: hack_result_str = "folder_contents"
				1: hack_result_str = "folder_etc_passwd"
				2: hack_result_str = "folder_mail_passwd"
		HackResultType.Type.COMPUTER:
			match selected_computer_hack:
				0: hack_result_str = "computer_dec_passwd"
				1: hack_result_str = "computer_dec_bank"
				2: hack_result_str = "computer_dec_mail"
		_: hack_result_str = HackResultType.translate(vuln.helper_hack_result.hack_result).replace(" ", "").to_lower()
	
	var suggested_name = "%s-%s-%s-%s" % [
		LibraryType.translate_for_exploit(lib.id_lib).replace("_", "").replace(".so", ""),
		"".join(lib.version.version),
		hack_result_str,
		vuln.helper_hack_result.user[0]
	]
	return suggested_name
